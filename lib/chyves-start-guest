#!/bin/sh

# Copyright (c) 2015, pr1ntf (Trent Thompson) All rights reserved.
# Copyright (c) 2016, Justin D Holcomb All rights reserved.
# Copyright (c) 2016, chyves All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Generates a bhyve PCI slot string from $1
__generate_bhyve_slot_string() {
	local _in_string="$1"                                                 # Required, contains string that is space separated
	local _max_slot="$2"                                                  # Optional, maximum number of buses to use. Important for UEFI ACHI drives.
	local _use_pci_funcions="${3-$_CONSOLIDATE_BHYVE_PCI_DEVICES}"        # Optional with default, use PCI functions. Important for PCI passthrough so physical devices are on same slot. Uses $_CONSOLIDATE_BHYVE_PCI_DEVICES if no set.
	local _max_slot_count=1                                               # Seeds counter used to ensure maximum slots are not exceeded.
	local _num_devices="$( echo $_in_string | tr ' ' '\n' | wc -l )"      # Number of devices to connect from $_in_string, implies slot usage
	local _func=0                                                         # Seeds PCI function number 

	# Return when empty string is provided but erase $_BHYVE_slot_string beforehand.
	[ -z "$_in_string" ] && _BHYVE_slot_string="" && return 0

	# Populate $_PCI_SLOT if empty.
	[ -z "$_PCI_SLOT" ] && _PCI_SLOT="$_PCI_SLOT_START"

	# This will dwindle down the number of max device if not specified.
	[ -z "$_max_slot" ] && local _max_slot=$( expr 30 - $_PCI_SLOT )

	# Choose whether or not to use PCI functions or only use on device per slot
	if [ $_num_devices -gt "$_max_slot" ] || [ "$_use_pci_funcions" = "yes" ]; then
		local _per_slot=$( expr $_num_devices / $_max_slot - 1 )

		# Tell user that chyves can not exceed bhyve's eight PCI functions per PCI slot limit.
		if [ "$_per_slot" -gt 7 ]; then
			echo "More devices than available PCI Slots and PCI functions can provide, some devices will not be attached."
			local _per_slot=7
		fi

	# Use one device per PCI Slot when there are abundant PCI slots available
	else
		local _per_slot="0"
	fi

	# Create the string.
	for _str in $_in_string
	do
		# Skip these off limit PCI slot numbers
		[ -n "$( echo "$_PCI_SLOT" | grep -E "$_OFFLIMIT_PCI_SLOT_NUMS_GREP_STRING" )" ] && _PCI_SLOT="$( expr $_PCI_SLOT + 1)"

		# Exit if above bhyve's maximum number of PCI slots but return the value of what is available. 31 is always used by the lpc
		if [ "$_PCI_SLOT" -gt 30 ]; then
			echo "Can not attach any additional PCI devices to guest per bhyve, attaching what can be attached."
			_BHYVE_slot_string="$_out_string"
			return 0
		fi

		# String generation - where the magic happens
		local _out_string="$_out_string -s ${_PCI_SLOT}:${_func},${_str}"

		# Must meet or be under bhyve's limit of 0-7 functions per PCI slot
		if [ "$_func" -eq "$_per_slot" ]; then

			# Reset function to 0
			local _func=0

			# Increment PCI Slot number
			_PCI_SLOT=$( expr $_PCI_SLOT + 1)

			# Increase counter for MAX slot checker
			local _max_slot_count=$( expr $_max_slot_count + 1)

			# MAX slot counter checker
			if [ "$_max_slot_count" -gt "$_max_slot" ]; then

				# Do not display the warning message for PCI Custom devices or when propery $_CONSOLIDATE_BHYVE_PCI_DEVICES is set to "yes".
				[ "$_use_pci_funcions" != "yes" ] && echo "Can not attach any additional PCI devices to guest per chyves, attaching what can be attached."

				# Return to the function that called this one after setting $_BHYVE_slot_string to what has been done.
				_BHYVE_slot_string="$_out_string"
				return 0
			fi

		# Increment PCI function number.
		else
			local _func=$( expr $_func + 1)
		fi
	done

	# Return the value in the form of a global variable
	_BHYVE_slot_string="$_out_string"
}

# Generates a bhyve slot string for custom PCI devices
__generate_bhyve_custom_pci_string() {
	local _dataset="$1"
	local _custom_pci_devs=$( zfs get -H -o property,value all $_dataset | grep chyves:pcidev: | sort | cut -f2 )


	# Special handling for PCI passthrough devices
	if [ -n "$(echo "$_custom_pci_devs" | grep 'passthru,' )" ]; then

		# Verify VT-d capable CPU when using using PCI passthrough
		__verify_iommu_capable

		# Get unique physical devices on host that share the same PCI slot number
		for _single_pci_phy in `echo $_custom_pci_devs | grep 'passthru,' | cut -d',' -f2 | cut -d'/' -f1 | uniq | tr '\n' ' '`
		do
			# Generate complete bhyve string under one PCI slot per physical device on host.
			local _devs_for_phy="$( echo $_custom_pci_devs | sort -k1 | grep "passthru,$_single_pci_phy/" | tr '\n' ' ' )"
			__generate_bhyve_slot_string "$_devs_for_phy" 1 yes
			local _processed_string="$_processed_string $_BHYVE_slot_string"
		done
	fi

	# Handling for other custom PCI devices
	for _pci in `echo $_custom_pci_devs | grep -v 'passthru,' | tr '\n' ' '`
	do
		__generate_bhyve_slot_string "$_pci" "" no
		local _processed_string="$_processed_string $_BHYVE_slot_string"
	done

	_BHYVE_custom_pci_string="$_processed_string"
}

# Verify I/O MMU (iommu) for guests using PCI passthrough
__verify_iommu_capable() {
	local _acpidump=$( acpidump -t | grep DMAR )

	# CPU missing DMAR are not VT-d capable.
	if [ -z "$_acpidump" ]; then
		__get_cpu_section_from_dmesg
		__fault_detected_exit "CPU missing I/O MMU capability or is disabled in the BIOS. \nPCI Passthrough requires I/O MMU to function. \nPlease check your CPU manufacture's spec page for your CPU. \nI/O MMU is called AMD-Vi for AMD CPUs and VT-d for Intel CPUs."
	fi
}

# Builds the device map file
__create_device_map() {
	local _path="$1"
	local _disk="$2"
	local _iso="$3"
	printf '\(hd0\)\ /dev/zvol/'$_disk'\n' > $_path/device.map
	printf '\(cd0\)\ '$_iso'\n' >> $_path/device.map
}

# Outputs PCI device string for bhyve command
__get_bhyve_cmd() {
	local devices="$1"
	local pci_slot_count=0
	for device in $devices ; do
		echo "-s $pci_slot_count,$device"
		pci_slot_count=$(( pci_slot_count + 1 ))
	done
}

# Get PCI device config from zfs
__get_zfs_pcidev_conf() {
	local pool="$1"
	local oldifs=$IFS
	#local pci
	IFS=$'\n'
	for pcidev in $(zfs get -H -o property,value all $pool | grep chyves:pcidev: | sort )
	do
		echo $pcidev | cut -f2-
	done
	IFS=$oldifs
}

# Install guest
__install() {
	local name="$1"
	local iso="$2"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters $name

	# Check to make sure guest isn't running
	if [ -z "$( __check_bhyve_process_running $name )" ]; then

		echo "Installing $name..."
		# Set install prop
		__multi_chyves_zfs_property "set" "install" "$_GUEST_pool" "guests" "$name" "yes"
		# Load from CD
		__load "$name" "/chyves/ISO/$iso/$iso"
		# Prepare and start guest
		__prepare_guest $name
		_BHYVE_pci="$_BHYVE_pci ahci-cd,/chyves/ISO/$iso/$iso"
		local pci_args=$(__get_bhyve_cmd "$_BHYVE_pci" )
		[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name"
		bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name &
	else
		echo "Guest is already running."
	fi
}

# Generates grub-bhyve command used to start guest.
__generate_grub_bhyve_command() {
	local _guest="$1"
	local _media="/chyves/ISO/$2/$2"
	__get_pool_for_guest "$_guest"
	__verify_binary_available "grub-bhyve"
	local _disk0="$_GUEST_pool/chyves/guests/$_guest/disk0"

	# Create a device map for none custom OSes
	[ $_GP_os != "custom" ] && __create_device_map "$_GP_path" "$_disk0" "$_media"

	# Boot from optical media when present.
	if [ -n "$_media" ]; then
		echo "Booting from optical media."
		if [ $_GP_os = "openbsd59" ]; then
			printf 'kopenbsd -h com0 (cd0)/5.9/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd58" ]; then
			printf 'kopenbsd -h com0 (cd0)/5.8/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd57" ]; then
			printf 'kopenbsd -h com0 (cd0)/5.7/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "netbsd" ]; then
			printf 'knetbsd -h -r cd0a (cd0)/netbsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "debian" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "d8lvm" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "centos6" ] || [ $_GP_os = "centos7" ]; then
			printf 'linux (cd0)/isolinux/vmlinuz\ninitrd (cd0)/isolinux/initrd.img\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "arch" ]; then
			printf 'linux (cd0)/arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=ARCH_'$(date +%Y%m)' ro\ninitrd (cd0)/arch/boot/x86_64/archiso.img\nboot\n' > $_path/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "gentoo" ]; then
			printf 'linux (cd0)/isolinux/gentoo root=/dev/ram0 init=/linuxrc  dokeymap looptype=squashfs loop=/image.squashfs  cdroot \ninitrd (cd0)/isolinux/gentoo.igz\nboot\n' > $_path/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m $_path/device.map -r host -d $_path -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "custom" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		else
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		fi

	# Boot from hard drive.
	else
		echo "Booting from hard drive."
		if [ $_GP_os = "openbsd59" ]; then
			printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd58" ]; then
			printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd57" ]; then
			printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "netbsd" ]; then
			printf 'knetbsd -h -r wd0a (hd0,msdos1)/netbsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "debian" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "d8lvm" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "centos6" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "centos7" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub2 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "custom" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		else
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		fi
	fi
}

# Boot guest
__boot() {
	local name="$1"
	local runmode="$2"
	local pci="$3"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters $name
	local dataset="${_GUEST_pool}/chyves/guests/${name}"

	# Set install prop
	__multi_chyves_zfs_property "set" "install" "$_GUEST_pool" "guests" "$name" "no"

	# Generate list of bhyve -s commands for all devices
	local pci_args=$( __get_bhyve_cmd "$pci" )

	# Handle the starting of the guest inside a spawned subshell so the guest
	# can be restarted automatically if the guest reboots or crashes
	local runstate="1"
	(
		while [ $runstate = "1" ]
		do
			__load "$name" "/dev/zvol/$dataset/disk0"
			[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name"
			bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name &
			local vmpid=$!
			wait $vmpid
			vmrc=$?
			sleep 5
			if [ $runmode == "0" ]; then
				runstate="0"
			elif [ $vmrc == "1" ] && [ $runmode != 2 ]; then
				# VM has been powered off
				runstate="0"
			else
				if [ "$_GP_persist" != 1 ]; then
					runstate="0"
				fi
			fi
		done
		bhyvectl --destroy --vm=chy-$name
		# Resetting the flag so that a vm which we stopped by abusing zfs set/get
		# as as an IPC mechanism is persistent again next time we start it
		if [ ! -z $_GP_persist ]; then
			zfs set chyves:persist="$persist" $dataset
		fi
	) &
}

__prepare_guest() {
	local name="$1"
	__get_pool_for_guest "$name"

	__generate_bhyve_net_string $name
	_BHYVE_pci="$_BHYVE_net_string"

	# Add disk as second PCI device
	_BHYVE_pci="ahci-hd,/dev/zvol/${_GUEST_pool}/chyves/guests/${name}/disk0 $_BHYVE_pci"
	# Add Hostbridge and lpc as the first PCI devices
	_BHYVE_pci="hostbridge lpc $_BHYVE_pci"
}

# Generate bhyve slot string for network devices.
__generate_bhyve_net_string() {
	local name="$1"
	__get_pool_for_guest "$name"

	# Setup interfaces if any are configured.
	local _net_ifaces="$( __multi_chyves_zfs_property "get" "net_ifaces" "$_GUEST_pool" "guests" "$name" )"
	for _iface in `echo $_net_ifaces | tr ',' '\n'`
	do
		[ "$_iface" = "-" ] && continue

		__verify_valid_system_iface $_iface -c

		if [ "$_IFACE_type" = "vale" ]; then
			[ -z "$_VALE_system_compat" ] && __verify_vale_system_compat
		elif [ "$_IFACE_type" = "tap" ]; then
			__get_parent_bridge_for_tap_chyves $_iface
			__network_add_dev_to_bridge $_PARENT_bridge_for_tap_chyves $_iface
			__network_add_phy_to_bridge $_PARENT_bridge_for_tap_chyves
		else
			__fault_detected_exit "Only tap and vale interfaces can be attached to bhyve guests. $_iface was detected as a $_IFACE_type interface."
		fi

		# Add a virtio-net pci device for the tap
		local _mac="$( __multi_chyves_zfs_property "get" "${_iface}_mac" "$_GUEST_pool" "guests" "$name" )"
		if [ $_mac = "-" ] || [ -z "$_mac" ]; then
			local _string="$_string virtio-net,$_iface"
		else
			_string="$_string virtio-net,${_iface},mac=${_mac}"
		fi
	done

	__generate_bhyve_slot_string "$_string"
	_BHYVE_net_string="$_BHYVE_slot_string"
}

# All inclusive start function
__start() {
	local _guests_list="$1"
	local _media="$2"

	# Load kernel modules if set to or just check they are loaded.
	if [ "$_AUTO_LOAD_KERNEL_MODS" = "yes" ]; then
		__verify_all_kernel_modules -l      # This checks and loads the missing modules.
	else
		__verify_all_kernel_modules         # This only checks but does not load.
	fi

	# Multi-guest support.
	# Eg.: chyves start guest1,guest2,guest3 auto-install.iso
	for _guest in `echo $_guests_list | tr ',' ' '`
	do
		__get_pool_for_guest "$_guest"
		__verify_valid_guest "$_guest" "$_GUEST_pool" -s
		echo "Preparing to start guest: $_guest"
		echo -n "Loading guest parameters... "
		__load_guest_parameters $_guest
		echo "done."

		echo -n "Checking if guest is running... "
		[ -n "$( __check_bhyve_process_running $_guest )" ] && __fault_detected_exit "Guest ($_guest) already running."
		echo "not running."

		echo -n "Checking if VMM resources allocated... "
		[ "$( __check_vmm_alocated $_guest )" ] && __fault_detected_exit "\nVMM resources already allocated. The guest likely did not exit the bhyve process correctly when shutting down or restarting. Please destroy the VMM resources before starting the guest with: chyves destroy $_guest"
		# Maybe just check if grub-bhyve is running for this guest instead?
		echo "not allocated."

		# Exit if starting a non-FreeBSD guest on an Intel host missing the UG CPU feature
		[ "$_CPU_MISSING_UG" ] && [ "$_GP_loader" != "bhyveload" ] && __get_cpu_section_from_dmesg && __fault_detected_exit "Missing CPU feature UG, can only start FreeBSD guests."

		echo -n "Checking which type of loader to use... "

		# bhyveload
		if [ "$_GP_loader" = "bhyveload" ]; then
			echo "bhyveload."

			echo -n "Generating command string for bhyveload... "
			_LOADER_cmd="bhyveload $_GP_wire_memory -m $_GP_ram -d /chyves/ISO/$_media/$_media -c /dev/${_GP_con}A chy-$_guest"
			echo "done."

			echo -n "Generating bhyve PCI string for disks... "
			__generate_bhyve_disk_string $_guest
			echo "done."

		# grub-bhyve
		elif [ "$_GP_loader" = "grub-bhyve" ]; then
			echo "grub-bhyve."

			echo -n "Generating command string for grub-bhyve... "
			__generate_grub_bhyve_command "$_guest" "$_media"    # _LOADER_cmd is set here.
			echo "done."

			echo -n "Generating bhyve PCI string for disks... "
			__generate_bhyve_disk_string $_guest
			echo "done."

		# uefi
		elif [ "$_GP_loader" = "uefi" ]; then
			echo "UEFI."

			# Check if firmware is set for guest
			[ $_GP_fw = '-' ] && __fault_detected_exit "You must set a firmware resource name to boot a UEFI guest..."

			echo -n "Generating bhyve string for UEFI firmware... "
			_BHYVE_uefi_firmware_string="-l bootrom,/chyves/Firmware/$_GP_fw/$_GP_fw"
			echo "done."

			# Optical Media is required by UEFI
			[ -z "$_media" ] && local _media="null.iso"

			echo -n "Generating bhyve PCI string for disks... "
			__generate_bhyve_disk_string $_guest
			echo "done."

			# Special handling for VNC console
			if [ "$_GP_uefi_console_output" = "vnc" ]; then

				echo -n "Generating bhyve PCI string for VNC console... "
				__generate_bhyve_vnc_string
				_BHYVE_console_string="$_BHYVE_vnc_string"
				echo "done."

				# Attach USB 3.0 Mouse? - Only useful for VNC.
				echo -n "Generating bhyve PCI string for mouse... "
				if [ "$_GP_uefi_mouse_type" = "usb3" ]; then
					echo "xHCI mouse... "
					local _uefi_usb3_mouse_string="xhci,tablet"
					__generate_bhyve_slot_string "$_uefi_usb3_mouse_string"
					_BHYVE_uefi_usb3_string="$_BHYVE_slot_string"
					echo "done."
				else
					echo "PS/2 mouse... done."
				fi
			fi
		fi

		# Declare console if UEFI VNC did not set this value
		[ -z "$_BHYVE_console_string" ] && _BHYVE_console_string="-l com1,/dev/${_GP_con}A"

		# Attach media if present. Always use 3 due to UEFI requiring ahci devices on PCI slots 3-6 && simplicity.
		[ -n "$_media" ] && _BHYVE_optical_media_string="-s 3,ahci-cd,/chyves/ISO/$_media/$_media"

		echo "Generating bhyve string for network devices... "
		__generate_bhyve_net_string $_guest
		echo "   ...done."

		echo -n "Generating bhyve string for custom PCI devices (if any)... "
		__generate_bhyve_custom_pci_string "$_GUEST_pool/chyves/guests/$_guest"
		echo "done."

		# Print the command to start the UEFI guest when $_DEVELOPER_MODE is not "off".
		if [ "$_DEVELOPER_MODE" != "off" ]; then
			echo "loader command ($_GP_loader):"
			echo "$_LOADER_cmd"
			echo "bhyve command:"
			echo "bhyve $_GP_bargs -c $_GP_cpu -U $_GP_uuid -m $_GP_ram -s 0,hostbridge -s 31,lpc $_BHYVE_optical_media_string $_BHYVE_disk_string $_BHYVE_net_string $_BHYVE_custom_pci_string $_BHYVE_console_string $_BHYVE_uefi_usb3_string $_BHYVE_uefi_firmware_string chy-$_guest"
		fi

		# Start this portion in a seperated process
		(
			# Use while loop to make sure guest will reboot correctly.
			while [ 1 ]
			do
				# Special handling for non-UEFI guests - UEFI does not need a loader as it uses the firmware to boot.
				if [ "$_GP_loader" != "uefi" ]; then

					# Execute the loader
					$_LOADER_cmd

					# Save the loader exit code
					local _loader_exit_code="$?"

					[ "$_DEVELOPER_MODE" != "off" ] && echo "Exit code for $_GP_loader guest '$_guest' was '$_loader_exit_code'"

					# Only exit codes of "0" are properly functioning.
					[ "$_loader_exit_code" -ne 0 ] && __fault_detected_exit "$_GP_loader exited with a '$_loader_exit_code' code. '0' is the expected code for proper booting. Halting boot process for $_guest."
				fi

				# Execute bhyve - Blank variables just create additional whitespace which is ignored.
				bhyve $_GP_bargs -c $_GP_cpu -U $_GP_uuid -m $_GP_ram -s 0,hostbridge -s 31,lpc $_BHYVE_optical_media_string $_BHYVE_disk_string $_BHYVE_net_string $_BHYVE_custom_pci_string $_BHYVE_console_string $_BHYVE_uefi_usb3_string $_BHYVE_uefi_firmware_string chy-$_guest
				# Is it not the least bit amusing this tool exists because of the <insert-judgemental-adjective> of not want to enter the command above by hand.

				# Save bhyve's exit code
				local _bhyve_exit_code="$?"

				[ "$_DEVELOPER_MODE" != "off" ] && echo "Exit code for bhyve guest '$_guest' was '$_bhyve_exit_code'"

				# Only reboots will exit with a code "0", all other exit codes need to destroy the VMM resources and exit
				if [ "$_bhyve_exit_code" != 0 ]; then
					bhyvectl --destroy --vm=chy-$_guest
					exit $_bhyve_exit_code
				fi

				echo "Rebooting chyves guest: $_guest... "
				sleep 5
			done
		) &

		echo ""                           # Create visual space for next multi-guest.
		_PCI_SLOT="$_PCI_SLOT_START"      # Reset $_PCI_SLOT value for next multi-guest.
	done
}

# Start a UEFI enabled bhyve instance.
# This is experimental, use with caution.
__uefi() {
	local name="$1"
	local media="${2-null.iso}"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters
	[ "${_CPU_MISSING_UG}" ] && __get_cpu_section_from_dmesg && __fault_detected_exit "This CPU lacks the 'UG' feature of EPT. UEFI guests are disabled."
	local dataset="${_GUEST_pool}/chyves/guests/${name}"

	# Create tap if needed
	# check to see if tap is already created before attempting to create new tap interface
	local tapif="$(ifconfig -l | tr ' ' '\n' | grep -F -w $_GP_tap)"
	if [ -z $tapif ]; then
		# create tap interface
		ifconfig $_GP_tap create descr "chyves-$name"
		ifconfig bridge0 addm $_GP_tap
	fi

	# Check if firmware is set for guest
	[ $_GP_fw = '-' ] && __fault_detected_exit "You must set a firmware file property to use UEFI..."

	# Check to make sure guest isn't running
	[ -n "$( __check_bhyve_process_running $name )" ] && __fault_detected_exit "$name is already running."

	# Print the command to start the UEFI guest
	if [ "$_DEVELOPER_MODE" != "off" ]; then
	echo "bhyve -c $_GP_cpu $_GP_bargs -m $_GP_ram "
	echo "        -s 0,hostbridge "
	echo "        -s 3,ahci-cd,/chyves/ISO/$media/$media "
	echo "        -s 4,ahci-hd,/dev/zvol/$dataset/disk0 "
	echo "        -s 10,virtio-net,$_GP_tap "
	echo "        -s 31,lpc "
	echo "        -l com1,/dev/${_GP_con}A "
	echo "        -l bootrom,/chyves/Firmware/$_GP_fw/$_GP_fw "
	echo "        -U $_GP_uuid "
	echo "        chy-$name"
	fi

	bhyve -c $_GP_cpu $_GP_bargs -m $_GP_ram \
	        -s 0,hostbridge \
	        -s 3,ahci-cd,/chyves/ISO/$media/$media \
	        -s 4,ahci-hd,/dev/zvol/$dataset/disk0 \
	        -s 10,virtio-net,$_GP_tap \
	        -s 31,lpc \
	        -l com1,/dev/${_GP_con}A \
	        -l bootrom,/chyves/Firmware/$_GP_fw/$_GP_fw \
	        -U $_GP_uuid \
	        chy-$name &
}
