#!/bin/sh

# Copyright (c) 2015, pr1ntf (Trent Thompson) All rights reserved.
# Copyright (c) 2016, Justin D Holcomb All rights reserved.
# Copyright (c) 2016, chyves All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Verify I/O MMU (iommu) for guests using PCI passthrough
__verify_iommu_capable() {
	local _acpidump=$( acpidump -t | grep DMAR )

	# CPU missing DMAR are not VT-d capable.
	if [ -z "$_acpidump" ]; then
		__get_cpu_section_from_dmesg
		__fault_detected_exit "CPU missing I/O MMU capability or is disabled in the BIOS. \nPCI Passthrough requires I/O MMU to function. \nPlease check your CPU manufacture's spec page for your CPU. \nI/O MMU is called AMD-Vi for AMD CPUs and VT-d for Intel CPUs."
	fi
}

# Builds the device map file
__create_device_map() {
	local _path="$1"
	local _disk="$2"
	local _iso="$3"
	printf '\(hd0\)\ /dev/zvol/'$_disk'\n' > $_path/device.map
	printf '\(cd0\)\ '$_iso'\n' >> $_path/device.map
}

# Outputs PCI device string for bhyve command
__get_bhyve_cmd() {
	local devices="$1"
	local pci_slot_count=0
	for device in $devices ; do
		echo "-s $pci_slot_count,$device"
		pci_slot_count=$(( pci_slot_count + 1 ))
	done
}

# Get PCI device config from zfs
__get_zfs_pcidev_conf() {
	local pool="$1"
	local oldifs=$IFS
	#local pci
	IFS=$'\n'
	for pcidev in $(zfs get -H -o property,value all $pool | grep chyves:pcidev: | sort )
	do
		echo $pcidev | cut -f2-
	done
	IFS=$oldifs
}

# Install guest
__install() {
	local name="$1"
	local iso="$2"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters $name

	# Check to make sure guest isn't running
	if [ -z "$( __check_bhyve_process_running $name )" ]; then

		echo "Installing $name..."
		# Set install prop
		__multi_chyves_zfs_property "set" "install" "$_GUEST_pool" "guests" "$name" "yes"
		# Load from CD
		__load "$name" "/chyves/ISO/$iso/$iso"
		# Prepare and start guest
		__prepare_guest $name
		_BHYVE_pci="$_BHYVE_pci ahci-cd,/chyves/ISO/$iso/$iso"
		local pci_args=$(__get_bhyve_cmd "$_BHYVE_pci" )
		[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name"
		bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name &
	else
		echo "Guest is already running."
	fi
}

# Generates grub-bhyve command used to start guest.
__generate_grub_bhyve_command() {
	local _guest="$1"
	local _media="/chyves/ISO/$2/$2"
	__get_pool_for_guest "$_guest"
	__verify_binary_available "grub-bhyve"
	local _disk0="$_GUEST_pool/chyves/guests/$_guest/disk0"

	# Create a device map for none custom OSes
	[ $_GP_os != "custom" ] && __create_device_map "$_GP_path" "$_disk0" "$_media"

	# Boot from optical media when present.
	if [ -n "$_media" ]; then
		echo "Booting from optical media."
		if [ $_GP_os = "openbsd59" ]; then
			printf 'kopenbsd -h com0 (cd0)/5.9/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd58" ]; then
			printf 'kopenbsd -h com0 (cd0)/5.8/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd57" ]; then
			printf 'kopenbsd -h com0 (cd0)/5.7/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "netbsd" ]; then
			printf 'knetbsd -h -r cd0a (cd0)/netbsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "debian" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "d8lvm" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "centos6" ] || [ $_GP_os = "centos7" ]; then
			printf 'linux (cd0)/isolinux/vmlinuz\ninitrd (cd0)/isolinux/initrd.img\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "arch" ]; then
			printf 'linux (cd0)/arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=ARCH_'$(date +%Y%m)' ro\ninitrd (cd0)/arch/boot/x86_64/archiso.img\nboot\n' > $_path/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "gentoo" ]; then
			printf 'linux (cd0)/isolinux/gentoo root=/dev/ram0 init=/linuxrc  dokeymap looptype=squashfs loop=/image.squashfs  cdroot \ninitrd (cd0)/isolinux/gentoo.igz\nboot\n' > $_path/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m $_path/device.map -r host -d $_path -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "custom" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		else
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		fi

	# Boot from hard drive.
	else
		echo "Booting from hard drive."
		if [ $_GP_os = "openbsd59" ]; then
			printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd58" ]; then
			printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "openbsd57" ]; then
			printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "netbsd" ]; then
			printf 'knetbsd -h -r wd0a (hd0,msdos1)/netbsd\nboot\n' > ${_GP_path}/grub.cfg
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "debian" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "d8lvm" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "centos6" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "centos7" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub2 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		elif [ $_GP_os = "custom" ]; then
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		else
			_LOADER_cmd="grub-bhyve $_GP_wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -c /dev/${_GP_con}A -M $_GP_ram chy-$_guest"
		fi
	fi
}

# Boot guest
__boot() {
	local name="$1"
	local runmode="$2"
	local pci="$3"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters $name
	local dataset="${_GUEST_pool}/chyves/guests/${name}"

	# Set install prop
	__multi_chyves_zfs_property "set" "install" "$_GUEST_pool" "guests" "$name" "no"

	# Generate list of bhyve -s commands for all devices
	local pci_args=$( __get_bhyve_cmd "$pci" )

	# Handle the starting of the guest inside a spawned subshell so the guest
	# can be restarted automatically if the guest reboots or crashes
	local runstate="1"
	(
		while [ $runstate = "1" ]
		do
			__load "$name" "/dev/zvol/$dataset/disk0"
			[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name"
			bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name &
			local vmpid=$!
			wait $vmpid
			vmrc=$?
			sleep 5
			if [ $runmode == "0" ]; then
				runstate="0"
			elif [ $vmrc == "1" ] && [ $runmode != 2 ]; then
				# VM has been powered off
				runstate="0"
			else
				if [ "$_GP_persist" != 1 ]; then
					runstate="0"
				fi
			fi
		done
		bhyvectl --destroy --vm=chy-$name
		# Resetting the flag so that a vm which we stopped by abusing zfs set/get
		# as as an IPC mechanism is persistent again next time we start it
		if [ ! -z $_GP_persist ]; then
			zfs set chyves:persist="$persist" $dataset
		fi
	) &
}

__prepare_guest() {
	local name="$1"
	__get_pool_for_guest "$name"

	__generate_bhyve_net_string $name
	_BHYVE_pci="$_BHYVE_net_string"

	# Add disk as second PCI device
	_BHYVE_pci="ahci-hd,/dev/zvol/${_GUEST_pool}/chyves/guests/${name}/disk0 $_BHYVE_pci"
	# Add Hostbridge and lpc as the first PCI devices
	_BHYVE_pci="hostbridge lpc $_BHYVE_pci"
}

# Generate bhyve slot string for network devices.
__generate_bhyve_net_string() {
	local name="$1"
	__get_pool_for_guest "$name"

	# Setup interfaces if any are configured.
	local _net_ifaces="$( __multi_chyves_zfs_property "get" "net_ifaces" "$_GUEST_pool" "guests" "$name" )"
	for _iface in `echo $_net_ifaces | tr ',' '\n'`
	do
		[ "$_iface" = "-" ] && continue

		__verify_valid_system_iface $_iface -c

		if [ "$_IFACE_type" = "vale" ]; then
			[ -z "$_VALE_system_compat" ] && __verify_vale_system_compat
		elif [ "$_IFACE_type" = "tap" ]; then
			__get_parent_bridge_for_tap_chyves $_iface
			__network_add_dev_to_bridge $_PARENT_bridge_for_tap_chyves $_iface
			__network_add_phy_to_bridge $_PARENT_bridge_for_tap_chyves
		else
			__fault_detected_exit "Only tap and vale interfaces can be attached to bhyve guests. $_iface was detected as a $_IFACE_type interface."
		fi

		# Add a virtio-net pci device for the tap
		local _mac="$( __multi_chyves_zfs_property "get" "${_iface}_mac" "$_GUEST_pool" "guests" "$name" )"
		if [ $_mac = "-" ] || [ -z "$_mac" ]; then
			local _string="$_string virtio-net,$_iface"
		else
			_string="$_string virtio-net,${_iface},mac=${_mac}"
		fi
	done

	__generate_bhyve_slot_string "$_string"
	_BHYVE_net_string="$_BHYVE_slot_string"
}

# Start guest (combine load and boot)
__start() {
	local name="$1"
	local flag="$2"
	__get_pool_for_guest "$name"
	__verify_valid_guest "$name" "$_GUEST_pool" -s
	__verify_all_kernel_modules
	__load_guest_parameters $name
	local dataset="$_GUEST_pool/chyves/guests/$name"
	local pci=""
	local runmode="1"

	# Check for special handling.
	if [ "$_CPU_MISSING_UG" ] && [ "$_GP_loader" != "bhyveload" ]; then
	 __get_cpu_section_from_dmesg
	 __fault_detected_exit "Missing CPU feature UG, can only start guests with loader=bhyveload."
	elif [ $_GP_loader = "grub-bhyve" ]; then
		__verify_binary_available "grub-bhyve"
	elif [ $_GP_loader = "uefi" ]; then
		__uefi "$name"
		exit
	fi

	# Check to make sure guest isn't running
	if [ -z "$( __check_bhyve_process_running $name )" ]; then
		case "$flag" in
			-s)  runmode="0"    # single - start only once
			;;
			-a)  runmode="2"    # always - persist regardless what
			;;
			*)   runmode="1"    # persist - persists until guest is powering off
			;;
		esac
		echo "Starting $name..."
		# Prepare and boot guest
		__prepare_guest $name
		__boot "$name" "$runmode" "$_BHYVE_pci"
	fi
}

# Start a UEFI enabled bhyve instance.
# This is experimental, use with caution.
__uefi() {
	local name="$1"
	local media="${2-null.iso}"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters
	[ "${_CPU_MISSING_UG}" ] && __get_cpu_section_from_dmesg && __fault_detected_exit "This CPU lacks the 'UG' feature of EPT. UEFI guests are disabled."
	local dataset="${_GUEST_pool}/chyves/guests/${name}"

	# Create tap if needed
	# check to see if tap is already created before attempting to create new tap interface
	local tapif="$(ifconfig -l | tr ' ' '\n' | grep -F -w $_GP_tap)"
	if [ -z $tapif ]; then
		# create tap interface
		ifconfig $_GP_tap create descr "chyves-$name"
		ifconfig bridge0 addm $_GP_tap
	fi

	# Check if firmware is set for guest
	[ $_GP_fw = '-' ] && __fault_detected_exit "You must set a firmware file property to use UEFI..."

	# Check to make sure guest isn't running
	[ -n "$( __check_bhyve_process_running $name )" ] && __fault_detected_exit "$name is already running."

	# Print the command to start the UEFI guest
	if [ "$_DEVELOPER_MODE" != "off" ]; then
	echo "bhyve -c $_GP_cpu $_GP_bargs -m $_GP_ram "
	echo "        -s 0,hostbridge "
	echo "        -s 3,ahci-cd,/chyves/ISO/$media/$media "
	echo "        -s 4,ahci-hd,/dev/zvol/$dataset/disk0 "
	echo "        -s 10,virtio-net,$_GP_tap "
	echo "        -s 31,lpc "
	echo "        -l com1,/dev/${_GP_con}A "
	echo "        -l bootrom,/chyves/Firmware/$_GP_fw/$_GP_fw "
	echo "        -U $_GP_uuid "
	echo "        chy-$name"
	fi

	bhyve -c $_GP_cpu $_GP_bargs -m $_GP_ram \
	        -s 0,hostbridge \
	        -s 3,ahci-cd,/chyves/ISO/$media/$media \
	        -s 4,ahci-hd,/dev/zvol/$dataset/disk0 \
	        -s 10,virtio-net,$_GP_tap \
	        -s 31,lpc \
	        -l com1,/dev/${_GP_con}A \
	        -l bootrom,/chyves/Firmware/$_GP_fw/$_GP_fw \
	        -U $_GP_uuid \
	        chy-$name &
}
