#!/bin/sh

# Copyright (c) 2015, pr1ntf (Trent Thompson) All rights reserved.
# Copyright (c) 2016, Justin D Holcomb All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Frontend interface to get chyves properties
__get() {
	local guests="$1"
	local prop="$2"

	# Multi-guest support.
	# Eg.: chyves get cpu guest1,guest2,guest3
	for name in `echo "$guests" | tr ',' ' '`
	do
		_GUEST_name="$name"
		__gvset_guest_pool

		if [ "$prop" = "all" ]; then
			echo "Getting all $name's chyves properties..."
			zfs get -o property,value all $_GUEST_pool/chyves/guests/$_GUEST_name/.config | grep chyves: | sort | sed -e 's/chyves://g'
		else
			echo -n "Getting $name's property '$prop'="
			__return_chyves_zfs_property_value "$prop" "guest"
		fi
	done
}

# Corrects user input when setting RAM properties and size for .defaults
__get_corrected_byte_nomenclature() {
	local _var="$1"

	[ -n "$( echo "$_var" | grep -v -E '^[0-9]{1,}[kmgtKMGT]?$' )" ] && __fault_detected_exit "Unrecognized size: '$_var', must be any integer and optionally a suffix K, M, G, or T. Megabytes are assumed if not specified."

	# Change to upper case
	local _var=$( echo "$_var" | tr '[:lower:]' '[:upper:]' )

	# Break _var into two parts number and size suffix
	local _num=$( echo "$_var" | grep -o -E "[0-9]{1,}" )
	local _suffix=$( echo "$_var" | grep -o "[kmgtKMGT]" )

	# If no suffix, then use the bhyve default of Megabytes
	if [ -z "$_suffix" ]; then
		local _suffix="M"
	fi

	# If devisable by 1024, then increase the file size denomination
	while [ "$( expr $_num % 1024 )" -eq 0 ] && [ "$_suffix" != "T" ]
	do
		local _num=$( expr $_num / 1024 )
		[ "$_suffix" = "G" ] && local _suffix="T"
		[ "$_suffix" = "M" ] && local _suffix="G"
		[ "$_suffix" = "K" ] && local _suffix="M"
	done

	_CORRECTED_byte_nomenclature="$_num$_suffix"
}

# Loads .defaults parameters to global variables
__load_guest_default_parameters() {
	_GDP_parameters_loaded=1

	# GDP = Guest Default Parameter
	# Parameters held in ZFS user properties:
	_GDP_bargs="$( __return_chyves_zfs_property_value       "bargs"       "defaults" )"
	_GDP_bridge="$( __return_chyves_zfs_property_value      "bridge"      "defaults" )"
	_GDP_cpu="$( __return_chyves_zfs_property_value         "cpu"         "defaults" )"
	_GDP_loader="$( __return_chyves_zfs_property_value      "loader"      "defaults" )"
	_GDP_os="$( __return_chyves_zfs_property_value          "os"          "defaults" )"
	_GDP_ram="$( __return_chyves_zfs_property_value         "ram"         "defaults" )"
	_GDP_rcboot="$( __return_chyves_zfs_property_value      "rcboot"      "defaults" )"
	_GDP_size="$( __return_chyves_zfs_property_value        "size"        "defaults" )"
	_GDP_template="$( __return_chyves_zfs_property_value    "template"    "defaults" )"

	# UEFI
	_GDP_uefi_console_output="$( __return_chyves_zfs_property_value  "uefi_console_output"                  "defaults" )"
	_GDP_uefi_firmware="$( __return_chyves_zfs_property_value        "uefi_firmware"                        "defaults" )"
	_GDP_uefi_mouse_type="$( __return_chyves_zfs_property_value      "uefi_mouse_type"                      "defaults" )"
	_GDP_uefi_vnc_ip="$( __return_chyves_zfs_property_value          "uefi_vnc_ip"                          "defaults" )"
	_GDP_uefi_vnc_res="$( __return_chyves_zfs_property_value         "uefi_vnc_res"                         "defaults" )"
	_GDP_uefi_vnc_pause="$( __return_chyves_zfs_property_value       "uefi_pause_until_vnc_client_connect"  "defaults" )"

	# Get _disk specific properties
	_GDP_disk_volmode="$( __return_chyves_zfs_property_value         "disk_volmode"         "defaults" )"
	_GDP_disk_volblocksize="$( __return_chyves_zfs_property_value    "disk_volblocksize"    "defaults" )"
	_GDP_disk_dedup="$( __return_chyves_zfs_property_value           "disk_dedup"           "defaults" )"
	_GDP_disk_compression="$( __return_chyves_zfs_property_value     "disk_compression"     "defaults" )"
	_GDP_disk_primarycache="$( __return_chyves_zfs_property_value    "disk_primarycache"    "defaults" )"
	_GDP_disk_secondarycache="$( __return_chyves_zfs_property_value  "disk_secondarycache"  "defaults" )"
}

# Load guest parameters to global variables
__load_guest_parameters() {
	_GUEST_name="$1"
	__gvset_guest_pool  # Sets $_GUEST_pool

	# GP = Guest Parameter
	# Parameters held in ZFS user properties:
	_GP_bargs="$( __return_chyves_zfs_property_value                 "bargs"                 "guest" )"
	_GP_cpu="$( __return_chyves_zfs_property_value                   "cpu"                   "guest" )"
	_GP_chyves_guest_version="$( __return_chyves_zfs_property_value  "chyves_guest_version"  "guest" )"
	_GP_description="$( __return_chyves_zfs_property_value           "description"           "guest" )"
	_GP_loader="$( __return_chyves_zfs_property_value                "loader"                "guest" )"
	_GP_net_ifaces="$( __return_chyves_zfs_property_value            "net_ifaces"            "guest" )"
	_GP_notes="$( __return_chyves_zfs_property_value                 "notes"                 "guest" )"
	_GP_os="$( __return_chyves_zfs_property_value                    "os"                    "guest" )"
	_GP_ram="$( __return_chyves_zfs_property_value                   "ram"                   "guest" )"
	_GP_rcboot="$( __return_chyves_zfs_property_value                "rcboot"                "guest" )"
	_GP_serial="$(__return_chyves_zfs_property_value                 "serial"                "guest" )"
	_GP_template="$( __return_chyves_zfs_property_value              "template"              "guest" )"
	_GP_uuid="$( __return_chyves_zfs_property_value                  "uuid"                  "guest" )"

	# Load UEFI specific values if necessary.
	if [ "$_GP_loader" = "uefi" ]; then
		# UEFI GOP Support
		_GP_uefi_console_output="$( __return_chyves_zfs_property_value  "uefi_console_output"                  "guest" )"
		_GP_uefi_firmware="$( __return_chyves_zfs_property_value        "uefi_firmware"                        "guest" )"
		_GP_uefi_mouse_type="$( __return_chyves_zfs_property_value      "uefi_mouse_type"                      "guest" )"
		_GP_uefi_vnc_ip="$( __return_chyves_zfs_property_value          "uefi_vnc_ip"                          "guest" )"
		_GP_uefi_vnc_port="$( __return_chyves_zfs_property_value        "uefi_vnc_port"                        "guest" )"
		_GP_uefi_vnc_res="$( __return_chyves_zfs_property_value         "uefi_vnc_res"                         "guest" )"
		_GP_uefi_vnc_pause="$( __return_chyves_zfs_property_value       "uefi_pause_until_vnc_client_connect"  "guest" )"
	fi

	# Other parameters
	_GUEST_mountpoint="$( __return_guest_dataset_mountpoint )"
	_GUEST_wire_memory="$( [ -n "$( echo "$_GP_bargs" | grep '\-S' )" ] && echo "-S" )"
}

# For use by commands which do not support multi-guest to load parameters
__load_one_guest_parameters() {
	__verify_one_guest_supplied "$1"
	_GUEST_name="$1"
	__load_guest_parameters $_GUEST_name
}

# Backend interface to get chyves properties with ZFS
__return_chyves_zfs_property_value() {
	local _manual_resource _property _resource _zfs_dataset
	local _property="$1"          # <property name>
	local _resource="$2"          # global|guest|defaults|manual
	local _manual_resource="$3"   #

	#
	if [ "$_resource" = "global" ]; then
		local _zfs_dataset="$_PRIMARY_POOL/chyves/.config"
	elif [ "$_resource" = "defaults" ]; then
		local _zfs_dataset="$_PRIMARY_POOL/chyves/guests/.defaults"
	elif [ "$_resource" = "guest" ]; then
		local _zfs_dataset="$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
	elif [ "$_resource" = "manual" ]; then
		local _zfs_dataset="$_manual_resource"
	fi

	# If CPU feature "UG" is missing limit to one CPU
	if [ "$_property" = "cpu" ] && [ "${_CPU_MISSING_UG}" ]; then
		echo "1"
	else
		zfs get -H -o value chyves:$_property $_zfs_dataset
	fi
}

# Get all chyves properties that are set on the system
__return_property_list() {
	local _flags="$1"
	local _guest="$2"
	# $null   Get a list of guest properties
	# -a      [all] Get a list of all guest properties including .defaults
	# -d      [defaults] Get a list of .defaults only properties
	# -c      [config] Get a list of .config only properties

	if [ -n "${_guest}" ]; then
		__gvset_guest_pool
		zfs get -r -H -t filesystem -o name,property all | grep -w  "$_GUEST_pool/chyves/guests/$_guest" | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-a" ]; then
		zfs get -r -H -t filesystem -o name,property all | grep /guests/ | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-d" ]; then
		zfs get -r -H -t filesystem -o name,property all $_PRIMARY_POOL/chyves/guests/.defaults | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-c" ]; then
		zfs get -r -H -t filesystem -o name,property all $_PRIMARY_POOL/chyves/.config | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	else
		zfs get -r -H -t filesystem -o name,property all | grep /guests/ | grep -v .defaults | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	fi
}

# Frontend interface to set chyves properties
__set() {
	local _guests_list _lastguest _prop _val
	local _guests_list="$1"          # This is script indexed.

	shift 2   # Keep from setting "set" or guest name as a property.
	for arg in "$@"; do

		# Guest name detector
		if [ -z "$( echo "$arg" | grep '=' )" ]; then
			local _guests_list="$arg"
			__verify_guests $arg

			# Skip remaining loop, as it is property specific.
			continue
		fi

		# Multi-guest support.
		# Eg.: chyves set cpu=8 guest1,guest2,guest3 ram=512M
		for _guest in `echo "$_guests_list" | tr ',' ' '`
		do
			_GUEST_name="$_guest"

			# Set the pool when no pool is set or if new guest is being used.
			if [ "$_GUEST_name" != "$_lastguest" ]; then
				if [ "$_GUEST_name" = "global" ]; then
					__log 2 "Switching to setting properties for global on: $_PRIMARY_POOL"
					local _type="$_GUEST_name"
				elif [ "$_GUEST_name" = "defaults" ]; then
					__log 2 "Switching to setting properties for defaults on: $_PRIMARY_POOL"
					local _type="$_GUEST_name"
				else
					__log 2 "Switching to setting properties for guest: $_GUEST_name"
					__gvset_guest_pool "$_GUEST_name"
					local _type="guest"
				fi
			fi

			# Parse property name and desired value from $arg (aka positional parameter)
			local _prop="$( echo $arg | cut -d '=' -f1 )"
			local _val="$( echo $arg | cut -d '=' -f2 )"

			__verify_user_input_for_properties "$_prop" "$_val" "$_type"

			# Update value if adjusted
			if [ -n "$_ADJUSTED_value" ]; then
				__log 3 "Value adjust from '$_val' to '$_ADJUSTED_value'."
				local _val="$_ADJUSTED_value"
			fi

			# Use function to set ZFS property
			if [ "$_guest" = "global" ]; then
				__set_chyves_zfs_property "$_prop" "$_val" "global"
			elif [ "$_guest" = "defaults" ]; then
				__set_chyves_zfs_property "$_prop" "$_val" "defaults"
			else
				__set_chyves_zfs_property "$_prop" "$_val" "guest"
			fi

			# Used to save some cycles
			local _lastguest="$_GUEST_name"

		done
	done
}

# Backend interface to set chyves properties with ZFS
__set_chyves_zfs_property() {
	local _property="$1"          # <property name>
	local _value="$2"             # <property value>
	local _resource="$3"          # global|guest|defaults|manual
	local _manual_resource="$4"   #
	local _guest_message=

	#
	if [ "$_resource" = "global" ]; then
		local _zfs_dataset="$_PRIMARY_POOL/chyves/.config"
	elif [ "$_resource" = "defaults" ]; then
		local _zfs_dataset="$_PRIMARY_POOL/chyves/guests/.defaults"
	elif [ "$_resource" = "guest" ]; then
		local _zfs_dataset="$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
		local _guest_message="for guest $_GUEST_name"
	elif [ "$_resource" = "manual" ]; then
		local _zfs_dataset="$_manual_resource"
	fi

	# Set the value for the property.
	__log 2 "Setting $_resource property '${_property}' to value: '${_value}' $_guest_message"
	zfs set chyves:${_property}="${_value}" $_zfs_dataset
}

# Middleware for setting properties, verifies user input for properties.
__verify_user_input_for_properties() {
	local _property _resource _value
	local _property="$1"
	local _value="$2"
	local _resource="$3"
	_ADJUSTED_value=""        # Needs to be reset due to being reused.

	# Do not ever allow for setting new defaults properties, to prevent confusion (except for setup)
	if [ "$_resource" = "defaults" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "master-override" ]; then
		local _valid_properties=$( __return_property_list -d )
		local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" )
		if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
			__fault_detected_exit "$_property is not a defined defaults property. \nCreating new properties for defaults is not possible."
		fi

	# Do not ever allow for setting new .config properties except bridge{n}_phy_attach and bridge{n}_tap_members, this is to prevent confusion.
	# $2 in __convert_list_to_grep_string under _string_to_grep is what is needed to allow setting bridge{n}_phy_attach and bridge{n}_tap_members as needed.
	# Use "set" directly is not recommended as it is not fully restrictive and will allow invalid bridge numbers be used which will later fail.
	elif [ "$_resource" = "global" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "master-override" ]; then
		local _valid_properties="$( __return_property_list -c )"
		local _string_to_grep="$( __convert_list_to_grep_string "$_valid_properties" "bridge([0-9]{1,5})_phy_attach|bridge([0-9]{1,5})_tap_members" )"
		if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
			__fault_detected_exit "$_property is not a defined global property. \nCreating new properties for global is not possible."
		fi

	# Property control for guests.
	elif [ "$_NUMBER_OF_ALL_GUESTS" -gt 0 ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "master-override" ]; then
		# If new property restrition is on, see if a new property name is being supplied.
		if [ "$_RESTRICT_NEW_PROPERTY_NAMES" = "on" ] && [ "$_NUMBER_OF_ALL_GUESTS" -gt "0" ]; then
			local _valid_properties=$( __return_property_list -a )
			local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" "^template$" )
			if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
				__fault_detected_exit "$_property is not a defined guest property and creation of new property creation is set to off, see 'restrict_new_property_names'."
			fi
		fi
	fi

	#
	if [ "$_resource" = "" ]; then
		__fault_detected_exit "No value supplied for $_property, aborting."

	# Guest and Defaults share many common properties. Last elif handles properties unique to defaults.
	elif [ "$_resource" = "guest" ] || [ "$_resource" = "defaults" ]; then

		# cpu
		if [ "$_property" = "cpu" ]; then
			if [ "$_value" -gt "16" ]; then
				_ADJUSTED_value="16"
				__log 1 "bhyve has a 16 CPU core limit. Setting cpu=16"
			fi
			if [ "$_value" -lt "1" ]; then
				_ADJUSTED_value="1"
				__log 1 "bhyve must be assigned at least one core. Setting cpu=1"
			fi

		# chyves_guest_version
		elif [ "$_property" = "chyves_guest_version" ]; then
			__fault_detected_warning_break 1 "Not user settable."

		# description and notes
		elif [ "$_property" = "description" ] || [ "$_property" = "notes" ]; then
			local _length="$( echo "$_value" | wc -m )"
			if [ "$_length" -gt "1024" ]; then
				_ADJUSTED_value="$( echo "$_value" | colrm 1025 )"
				__log 1 "ZFS has a 1024 character limit, truncating to the first 1024 characters."
			fi

		# loader
		elif [ "$_property" = "loader" ]; then
			if [ -z "$( echo "$_value" | grep -E '^uefi$|^bhyveload$|^grub-bhyve$' )" ]; then
				__fault_detected_warning_break 1 "Unrecognized loader type. Recognized values are bhyveload, grub-bhyve, uefi"
			fi

			# Special handling for UEFI guests
			if [ "$_value" = "uefi" ]; then
				local _uefi_firmware_source="$( zfs get -H -o source chyves:uefi_firmware $_GUEST_pool/chyves/guests/$_GUEST_name/.config )"

				# Check to see if uefi property has been previously set.
				if [ "$_uefi_firmware_source" != "local" ]; then
					__log 2 "\nTurning on other UEFI properties, using defaults to set values." -e
					__load_guest_default_parameters
					__get_next_vnc_port
					local _previous_restrict_state="$_RESTRICT_NEW_PROPERTY_NAMES"
					_RESTRICT_NEW_PROPERTY_NAMES="master-override"                 # If this is the first guest with UEFI the following properties would fail to be set without this.
					__set_chyves_zfs_property "uefi_console_output"                  "$_GDP_uefi_console_output" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_firmware"                        "$_GDP_uefi_firmware" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_mouse_type"                      "$_GDP_uefi_mouse_type" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_vnc_port"                        "$_NEXT_vnc_port" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_vnc_ip"                          "$_GDP_uefi_vnc_ip" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_vnc_res"                         "$_GDP_uefi_vnc_res" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_pause_until_vnc_client_connect"  "$_GDP_uefi_vnc_pause" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					_RESTRICT_NEW_PROPERTY_NAMES="$_previous_restrict_state"       # Turn back to previous state.
				else
					__log 2 "Existing UEFI configuration on guest."
				fi
			fi

		# net_ifaces
		elif [ "$_property" = "net_ifaces" ]; then
		__fault_detected_warning_break 1 "Not user settable."

		# os
		elif [ "$_property" = "os" ]; then
			if [ -z "$( echo "$_value" | grep -E '^openbsd59$|^openbsd58$|^openbsd57$|^netbsd$|^debian$|^d8lvm$|^centos6$|^centos7$|^arch$|^gentoo$|^custom$|^default$' )" ]; then
				__log 1 "Unrecognized os type. Valid values are required for grub-bhyve guests to boot properly. See man page for valid values."
			fi

		# ram
		elif [ "$_property" = "ram" ]; then
			__get_corrected_byte_nomenclature "$_value"
			_ADJUSTED_value="$_CORRECTED_byte_nomenclature"

		# rcboot
		elif [ "$_property" = "rcboot" ]; then
			if [ -n "$( echo "$_value" | tr '[:lower:]' '[:upper:]' | grep -E '^NO$|^N$' )" ]; then
				__log 2 "Correct syntax is to use '0' rather than '$value'."
				_ADJUSTED_value=0
			elif [ -z "$( echo "$_value" | grep -E '^[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'rcboot' property is any positive integer or zero."
			fi

		# serial
		elif [ "$_property" = "serial" ]; then
			if [ -z "$( echo "$_value" | grep -E '^nmdm[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'serial' property is 'nmdm' followed by any unique positive integer."
			fi
			echo "It is not recommmended to set this property manually."

		# template
		elif [ "$_property" = "template" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' property is 'yes' or 'no'."
			fi

		# uefi_console_output
		elif [ "$_property" = "uefi_console_output" ]; then
			if [ -z "$( echo "$_value" | grep -E '^serial$|^vnc$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_console_output property is 'serial' or 'vnc'."
			fi

		# uefi_firmware
		elif [ "$_property" = "uefi_firmware" ]; then
			__log 2 "Verifying firmware resource dataset... " -n
			__verify_valid_dataset "Firmware/$_value"
			__log 2 "done"

		# uefi_mouse_type
		elif [ "$_property" = "uefi_mouse_type" ]; then
			if [ -z "$( echo "$_value" | grep -E '^ps2$|^usb3$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_mouse_type' is 'ps2' or 'usb3'."
			fi

		# uefi_pause_until_vnc_client_connect
		elif [ "$_property" = "uefi_pause_until_vnc_client_connect" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_pause_until_vnc_client_connect' is 'yes' or 'no'."
			fi

		# uefi_vnc_ip
		elif [ "$_property" = "uefi_vnc_ip" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}$' )" ]; then
				__fault_detected_warning_break 1 "Correct value for '$_property' is an IPv4 address. Example: 192.168.100.2"
			fi

			# Check IP octets are correct.
			for _octet in `echo "$_value" | tr '.' ' '`
			do
				if [ "$_octet" -gt 255 ] || [ "$_octet" -lt 0 ]; then
					__fault_detected_warning_break 1 "Invalid IPv4 octet value"
				fi
			done

			# Check if IP is configured on system.
			if [ "$_value" = "0.0.0.0" ]; then
				__log 2 "Keep in mind, using the default value '0.0.0.0' for '$_property' does pose a security risk."
			elif [ -z "$( echo "$_value" | grep -E "$( __return_new_line_delimit_as_grep_string "$( ifconfig | grep inet | awk '{ print $2 }' | grep -E '^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}$' )" )" )" ]; then
				__log 1 "IPv4 address ($_value), not found on system. Connection to VNC will fail."
			fi

		# uefi_vnc_port
		elif [ "$_property" = "uefi_vnc_port" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,5}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' property is a positive integer 0 through 65535."
			fi
			if [ "$_value" -lt 0 ] || [ "$_value" -gt 65535 ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' property is a positive integer within 0 through 65535 range."
			fi

		# uefi_vnc_res
		elif [ "$_property" = "uefi_vnc_res" ]; then
			if [ -z "$( echo "$_value" | grep -E '^1920x1200$|^1920x1080$|^1600x1200$|^1600x900$|^1280x1024$|^1280x720$|^1024x768$|^800x600$|^640x480$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_vnc_res' are in the man page."
			fi

		# uuid
		elif [ "$_property" = "uuid" ]; then
			if [ -z "$( echo "$_value" | grep -E '$_UUID_CHECK_GREP_STRING' )" ]; then
				__fault_detected_warning_break 1 "Value for '$_property', not in UUID format. Example: '21EC2020-3AEA-4069-A2DD-08002B30309D'"
			fi

		# Verify properties unique to defaults. This always needs to be just before the else catch all.
		elif [ "$_resource" = "defaults" ]; then

			# bridge
			if [ "$_property" = "bridge" ]; then
				__verify_valid_iface_format $_value
				if [ "$_IFACE_type" != "bridge" ]; then
					__fault_detected_warning_break 1 "Valid value for 'bridge' must be a bridge name."
				fi

			# disk_compression
			elif [ "$_property" = "disk_compression" ]; then
				if [ -z "$( echo "$_value" | grep -E '^on$|^off$|^lzjb$|^gzip$|^gzip-[1-9]{1}$|^zle$|^lz4$|^inherit$' )" ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi

			# disk_primarycache & disk_secondarycache
			elif [ "$_property" = "disk_primarycache" ] || [ "$_property" = "disk_secondarycache" ]; then
				if [ -z "$( echo "$_value" | grep -E '^all$|^none$|^metadata$|^inherit$' )" ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi

			# disk_volblocksize
			elif [ "$_property" = "disk_volblocksize" ]; then
				__gvset_user_input_to_bytes "$_value"
				_ADJUSTED_value="$_USER_input_to_bytes"
				if [ "$_ADJUSTED_value" -gt 131072 ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi

			# disk_volmode
			elif [ "$_property" = "disk_volmode" ]; then
				if [ -z "$( echo "$_value" | grep -E '^geom$|^dev$|^inherit$' )" ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi
				if [ "$_value"="geom" ]; then
					__log 1 "[WARNING] While setting the value for 'disk_volmode' to 'geom' will work, the host OS can interfere and possibly corrupt the guest disk."
				fi

			# size
			elif [ "$_property" = "size" ]; then
				__get_corrected_byte_nomenclature "$_value"
				_ADJUSTED_value="$_CORRECTED_byte_nomenclature"
			fi

		# Catch all for guests.
		else
			__log 1 "No input verification for guest '$_property' property written. Beware of dragons."
		fi

	# Verify global properties
	elif [ "$_resource" = "global" ]; then

		# auto_load_kernel_mods
		if [ "$_property" = "auto_load_kernel_mods" ]; then
			if [ -z "$( echo "$_value" | grep -E '^no$|^yes$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'yes' or 'no'"
			fi

		# bridge{n}_tap_members
		elif [ -n "$( echo "$_property" | grep -E '^bridge[0-9]{1,5}_tap_members$' )" ]; then
			__fault_detected_warning_break 1 "Use 'chyves network' to indirectly manage property: '$_property'."

		# check_for_updates
		elif [ "$_property" = "check_for_updates" ]; then
			if [ -z "$( echo "$_value" | grep -E '^daily$|^weekly$|^monthly$|^always$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are: daily, weekl, monthly, and always."
			fi

		# check_for_updates_last_check
		elif [ "$_property" = "check_for_updates_last_check" ]; then
			if [ -z "$( echo "$_value" | grep -E '^20[0-9]{2}[01]{1}[0-9]{1}[0-3]{1}[0-9]{1}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', must be in YYYYMMDD."
			fi

		# check_for_updates_last_check_status
		elif [ "$_property" = "check_for_updates_last_check_status" ]; then
			if [ -z "$( echo "$_value" | grep -E '^0$|^1$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are '0' or '1'."
			fi

		# check_for_updates_timeout_seconds
		elif [ "$_property" = "check_for_updates_timeout_seconds" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property'."
			fi

		# check_for_updates_unique_id
		elif [ "$_property" = "check_for_updates_unique_id" ]; then
			if [ -z "$( echo "$_value" | grep -E '$_UUID_CHECK_GREP_STRING' )" ]; then
				__fault_detected_warning_break 1 "Value for '$_property', not in UUID format. Example: '21EC2020-3AEA-4069-A2DD-08002B30309D'"
			fi

		# chyves_version
		elif [ "$_property" = "chyves_version" ]; then
			__fault_detected_warning_break 1 "Not user settable."

		# chyves_version_int
		elif [ "$_property" = "chyves_version_int" ]; then
			__fault_detected_warning_break 1 "Not user settable."

		# console_start_offset
		elif [ "$_property" = "console_start_offset" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property'."
			fi

		# consolidate_bhyve_pci_devices
		elif [ "$_property" = "consolidate_bhyve_pci_devices" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'yes' or 'no'."
			fi

		# dataset_role
		elif [ "$_property" = "dataset_role" ]; then
			__fault_detected_warning_break 1 "Not user settable, use 'chyves dataset' to manage."

		# dataset_version
		elif [ "$_property" = "dataset_version" ]; then
			__fault_detected_warning_break 1 "Not user settable, use 'chyves dataset' to manage."

		# default_info_flags
		elif [ "$_property" = "default_info_flags" ]; then
			if [ -z "$( echo "$_value" | grep -E '^-[zbprvstcdnakl]{1,}$|^-h$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', see 'chyves info -h' for valid values."
			fi

		# default_list_flags
		elif [ "$_property" = "default_list_flags" ]; then
			if [ -z "$( echo "$_value" | grep -E '^-[zbprvstcdnakl]{1,}$|^-h$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', this function share the same backend as 'chyves info' see man page for valid values."
			fi

		# dev_mode
		elif [ "$_property" = "dev_mode" ]; then
			if [ -z "$( echo "$_value" | grep -E '^on$|^off$|^-[xvn]{1}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property'."
			fi

		# log_mode
		elif [ "$_property" = "log_mode" ]; then
			if [ -z "$( echo "$_value" | grep -E '^host$|^guest$|^dual$|^off$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'host', 'guest', or 'dual'."
			fi

		# log_to_file
		elif [ "$_property" = "log_to_file" ]; then
			if [ -z "$( echo "$_value" | grep -E '^on$|^off$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'on' or 'off'."
			fi

		# network_design_mode
		elif [ "$_property" = "network_design_mode" ]; then
			if [ -z "$( echo "$_value" | grep -E '^auto$|^system$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'auto' or 'system'."
			fi

		# restrict_new_property_names
		elif [ "$_property" = "restrict_new_property_names" ]; then
			if [ -z "$( echo "$_value" | grep -E '^on$|^off$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'on' and 'off'."
			fi

		# stdout_level
		elif [ "$_property" = "stdout_level" ]; then
			if [ -z "$( echo "$_value" | grep -E '[0-4]{1}' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are '0', '1', '2', '3', or '4'. See man page for meaning."
			fi

		# tap_start_offset
		elif [ "$_property" = "tap_start_offset" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,5}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 32768."
			elif [ "$_value" -lt 0 ] && [ "$_value" -gt 32768 ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 32768."
			fi

		# tap_up_by_default
		elif [ "$_property" = "tap_up_by_default" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'yes' or 'no'. "
			fi

		# uefi_vnc_port_start_offset
		elif [ "$_property" = "uefi_vnc_port_start_offset" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,5}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 65535."
			elif [ "$_value" -lt 0 ] && [ "$_value" -gt 65535 ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 65535."
			fi

		# vlan_iface_base_name
		elif [ "$_property" = "vlan_iface_base_name" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[a-z]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are any alphabetic words."
			fi
		fi
	fi

	# Check to not exceed ZFS 1024 character limit, this does not apply to desc or notes as those are truncated. For other properties it might be detrimental to do so, such as the net properties.
	local _length="$( echo "$_value" | wc -m )"
	if [ "$_length" -gt "1024" ]; then
		__fault_detected_warning_break 1 "Value is longer than 1024 character. ZFS's limit is 1024, aborting rather than causing futher issues."
	fi

	# echo "Valid user input... "
}
