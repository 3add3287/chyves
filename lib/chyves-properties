#!/bin/sh

# Copyright (c) 2015, pr1ntf (Trent Thompson) All rights reserved.
# Copyright (c) 2016, Justin D Holcomb All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Backend interface to set chyves properties with ZFS
__multi_chyves_zfs_property() {
	local _action="$1"      # get|set
	local _property="$2"    # <property name>
	local _pool="$3"        # primary|<pool name>
	local _resource="$4"    # .config|guests
	local _guest="$5"       # -|<guest name>
	local _value="$6"       # <property value>

	# Null out value when "-" used. Used for setting .config
	[ "${_guest}" = "-" ] && local _guest=""

	# If the guest variable is populated, prepend a "/" - This is for .config compatibility
	[ -n "${_guest}" ] && local _guest="/$_guest"

	# Set _pool to the primary pool name when "primary" is used in the _pool name variable.
	[ "${_pool}" = "primary" ] && local _pool=$_PRIMARY_POOL

	# Which action? get / set
	if [ "${_action}" = "get" ]; then

		# If CPU feature "UG" is missing limit to one CPU
		if [ "$_property" = "cpu" ] && [ "${_CPU_MISSING_UG}" ]; then
			echo "1"
		else
			zfs get -H -o value chyves:$_property $_pool/chyves/${_resource}${_guest}
		fi

	elif [ "${_action}" = "set" ]; then

		# If new property restrition is on, see if a new property name is being supplied.
		if [ "$_RESTRICT_NEW_PROPERTY_NAMES" = "on" ] && [ "$_NUMBER_OF_ALL_GUESTS" -gt "0" ]; then

			# Do not ever allow for setting new .defaults properties, to prevent confusion (except for setup)
			if [ "$_guest" = ".defaults" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "primary-pool-initial-setup" ]; then
				local _valid_properties=$( __get_property_list -d )
				local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" )
				if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
					__fault_detected_exit "${_property} is not a defined property ($_string_to_grep) pool. \nCreating new properties for .defaults is not possible."
				fi

			# Do not ever allow for setting new .config properties except bridge{n}_phy_attach and bridge{n}_tap_members, this is to prevent confusion.
			# $2 in __convert_list_to_grep_string under _string_to_grep is what is needed to allow setting bridge{n}_phy_attach and bridge{n}_tap_members as needed.
			# Use "set" directly is not recommended as it is not fully restrictive and will allow invalid bridge numbers be used which will later fail.
			elif [ "$_resource" = ".config" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "primary-pool-initial-setup" ]; then
				local _valid_properties=$( __get_property_list -c )
				local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" "bridge([0-9]{1,5})_phy_attach|bridge([0-9]{1,5})_tap_members" )
				if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
					__fault_detected_exit "${_property} is not a defined property ($_string_to_grep) pool. \nCreating new properties for .config is not possible."
				fi

			else
				local _valid_properties=$( __get_property_list -a )
				local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" )
				if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
					__fault_detected_exit "${_property} is not a defined property ($_string_to_grep). \nCreation of new properties turned off with 'restrict_new_property_names' in .config"
				fi
			fi
		fi

		# Correct byte nomenclature for RAM and size for .default
		if [ "$_property" = "ram" ] || [ "$_property" = "size" ]; then
			__get_corrected_byte_nomenclature "$_value"
			local _value="$_CORRECTED_byte_nomenclature"
		fi

		# Do not exceed bhyve CPU capability
		[ "$_property" = "cpu" ] && [ "$_value" -gt "16" ] && local _value="16" && echo "bhyve has a 16 CPU core limit. Setting cpu=16"

		# Made it this far, set the value for the property.
		echo "Setting \"${_property}\" to value: \"${_value}\" for ${_resource}${_guest}"
		zfs set chyves:${_property}="${_value}" $_pool/chyves/${_resource}${_guest}
	fi
}

# Load guest parameters to global variables
__load_guest_parameters() {
	local _guest="$1"
	__get_pool_for_guest "$_guest"
	_GP_parameters_loaded=1

	# GP = Guest Parameter
	# Parameters held in ZFS user properties:
	_GP_bargs="$( __multi_chyves_zfs_property       "get" "bargs"       "$_GUEST_pool" "guests" "$_guest" )"
	_GP_con="$(__multi_chyves_zfs_property          "get" "con"         "$_GUEST_pool" "guests" "$_guest" )"
	_GP_cpu="$( __multi_chyves_zfs_property         "get" "cpu"         "$_GUEST_pool" "guests" "$_guest" )"
	_GP_fw="$( __multi_chyves_zfs_property          "get" "fw"          "$_GUEST_pool" "guests" "$_guest" )"
	_GP_loader="$( __multi_chyves_zfs_property      "get" "loader"      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_os="$( __multi_chyves_zfs_property          "get" "os"          "$_GUEST_pool" "guests" "$_guest" )"
	_GP_ram="$( __multi_chyves_zfs_property         "get" "ram"         "$_GUEST_pool" "guests" "$_guest" )"
	_GP_rcboot="$( __multi_chyves_zfs_property      "get" "rcboot"      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_net_ifaces="$( __multi_chyves_zfs_property  "get" "net_ifaces"  "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uuid="$( __multi_chyves_zfs_property        "get" "uuid"        "$_GUEST_pool" "guests" "$_guest" )"

	# UEFI GOP Support
	_GP_uefi_console_output="$( __multi_chyves_zfs_property "get" "uefi_console_output"                  "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_mouse_type="$( __multi_chyves_zfs_property     "get" "uefi_mouse_type"                      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_ip="$( __multi_chyves_zfs_property         "get" "uefi_vnc_ip"                          "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_port="$( __multi_chyves_zfs_property       "get" "uefi_vnc_port"                        "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_res="$( __multi_chyves_zfs_property        "get" "uefi_vnc_res"                         "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_pause="$( __multi_chyves_zfs_property      "get" "uefi_pause_until_vnc_client_connect"  "$_GUEST_pool" "guests" "$_guest" )"

	# Other parameters
	_GP_path="$( __get_path_for_guest_dataset "$_guest" "$_GUEST_pool" )"
	_GP_wire_memory="$( [ -n "$( echo "$_GP_bargs" | grep '\-S' )" ] && echo "-S" )"
}

# Loads .defaults parameters to global variables
__load_guest_default_parameters() {
	_GDP_parameters_loaded=1

	# GDP = Guest Default Parameter
	# Parameters held in ZFS user properties:
	_GDP_bargs="$( __multi_chyves_zfs_property      "get" "bargs"      "primary" "guests" ".defaults" )"
	_GDP_bridge="$( __multi_chyves_zfs_property     "get" "bridge"     "primary" "guests" ".defaults" )"
	_GDP_cpu="$( __multi_chyves_zfs_property        "get" "cpu"        "primary" "guests" ".defaults" )"
	_GDP_fw="$( __multi_chyves_zfs_property         "get" "fw"         "primary" "guests" ".defaults" )"
	_GDP_guest_role="$( __multi_chyves_zfs_property "get" "guest_role" "primary" "guests" ".defaults" )"
	_GDP_loader="$( __multi_chyves_zfs_property     "get" "loader"     "primary" "guests" ".defaults" )"
	_GDP_os="$( __multi_chyves_zfs_property         "get" "os"         "primary" "guests" ".defaults" )"
	_GDP_persist="$( __multi_chyves_zfs_property    "get" "persist"    "primary" "guests" ".defaults" )"
	_GDP_ram="$( __multi_chyves_zfs_property        "get" "ram"        "primary" "guests" ".defaults" )"
	_GDP_rcboot="$( __multi_chyves_zfs_property     "get" "rcboot"     "primary" "guests" ".defaults" )"
	_GDP_size="$( __multi_chyves_zfs_property       "get" "size"       "primary" "guests" ".defaults" )"

	# UEFI GOP Support
	_GDP_uefi_console_output="$( __multi_chyves_zfs_property "get" "uefi_console_output"                  "primary" "guests" ".defaults" )"
	_GDP_uefi_mouse_type="$( __multi_chyves_zfs_property     "get" "uefi_mouse_type"                      "primary" "guests" ".defaults" )"
	_GDP_uefi_vnc_ip="$( __multi_chyves_zfs_property         "get" "uefi_vnc_ip"                          "primary" "guests" ".defaults" )"
	_GDP_uefi_vnc_res="$( __multi_chyves_zfs_property        "get" "uefi_vnc_res"                         "primary" "guests" ".defaults" )"
	_GDP_uefi_vnc_pause="$( __multi_chyves_zfs_property      "get" "uefi_pause_until_vnc_client_connect"  "primary" "guests" ".defaults" )"

	# Get _disk specific properties
	_GDP_disk_volmode="$( __multi_chyves_zfs_property         "get" "disk_volmode"        "primary" "guests" ".defaults" )"
	_GDP_disk_volblocksize="$( __multi_chyves_zfs_property    "get" "disk_volblocksize"   "primary" "guests" ".defaults" )"
	_GDP_disk_dedup="$( __multi_chyves_zfs_property           "get" "disk_dedup"          "primary" "guests" ".defaults" )"
	_GDP_disk_compression="$( __multi_chyves_zfs_property     "get" "disk_compression"    "primary" "guests" ".defaults" )"
	_GDP_disk_primarycache="$( __multi_chyves_zfs_property    "get" "disk_primarycache"   "primary" "guests" ".defaults" )"
	_GDP_disk_secondarycache="$( __multi_chyves_zfs_property  "get" "disk_secondarycache" "primary" "guests" ".defaults" )"
}

# Corrects user input when setting RAM properties and size for .defaults
__get_corrected_byte_nomenclature() {
	local _var="$1"

	[ -n "$( echo "$_var" | grep -v -E '^[0-9]{1,}[kmgtKMGT]?$' )" ] && __fault_detected_exit "Unrecognized size: '$_var', must be any integer and optionally a suffix K, M, G, or T. Megabytes are assumed if not specified."

	# Change to upper case
	local _var=$( echo "$_var" | tr '[:lower:]' '[:upper:]' )

	# Break _var into two parts number and size suffix
	local _num=$( echo "$_var" | grep -o -E "[0-9]{1,}" )
	local _suffix=$( echo "$_var" | grep -o "[kmgtKMGT]" )

	# If no suffix, then use the bhyve default of Megabytes
	[ -z "$_suffix" ] && local _suffix="M"

	# If devisable by 1024, then increase the file size denomination
	while [ "$( expr $_num % 1024 )" -eq 0 ] && [ "$_suffix" != "T" ]
	do
		local _num=$( expr $_num / 1024 )
		[ "$_suffix" = "G" ] && local _suffix="T"
		[ "$_suffix" = "M" ] && local _suffix="G"
		[ "$_suffix" = "K" ] && local _suffix="M"
	done

	_CORRECTED_byte_nomenclature="$_num$_suffix"
}

# Frontend interface to set chyves properties
__set() {
	local _name="$3"          # This is script indexed.

	# Legacy command syntax support
	if [ -z "$( echo "$2" | grep '=' )" ] && [ -n "$( echo "$3" | grep '=' )" ]; then
		echo "[WARNING] The correct syntax is 'chyves set ${3} ${2}...', correcting syntax for temporary backwards compatibility. This will be deprecated at some point."
	elif [ -n "$( echo "$2" | grep '=' )" ] && [ -n "$( echo "$3" | grep '=' )" ]; then
		__help
		__fault_detected_exit "Incorrect syntax used. See above for correct syntax"
	else
		# Needed to seed first iteration.
		local guests="$_name"
		# Kind of amusing how the new syntax is a little more complicated
	fi

	shift 1   # Keep from setting "set" as a property or using as a guest name.
	for arg in "$@"; do

		# Guest name detector
		if [ -n "$( echo "$arg" | grep -v '=' )" ]; then
			local guests="$arg"

			# Skip remain loop as it is property specific.
			continue
		fi

		# Multi-guest support.
		# Eg.: chyves set cpu=8 guest1,guest2,guest3 ram=512M
		for name in `echo "$guests" | tr ',' ' '`
		do

			if [ "$name" != "$_lastguest" ]; then
				if [ "$name" = ".config" ]; then
					echo "Switching to setting properties for .config on: $_PRIMARY_POOL"
				elif [ "$name" = ".defaults" ]; then
					echo "Switching to setting properties for .defaults on: $_PRIMARY_POOL"
					_GUEST_pool="$_PRIMARY_POOL"
				else
					echo "Switching to setting properties for guest: $name"
					__get_pool_for_guest "$name"
				fi
			fi

			# Parse property name and desired value from $arg (aka positional parameter)
			local prop="$(echo $arg | cut -d '=' -f1)"
			local val="$(echo $arg | cut -d '=' -f2)"

			__verify_user_input_for_properties "$_prop" "$_val" "$_type"

			# Update value if adjusted
			if [ -n "$_ADJUSTED_value" ]; then
				__log 3 "Value adjust from '$_val' to '$_ADJUSTED_value'."
				local _val="$_ADJUSTED_value"
			fi

			# Use function to set ZFS property
			if [ "$name" = ".config" ]; then
				__multi_chyves_zfs_property "set" "$prop" "$_PRIMARY_POOL" ".config" "-" "$val"
			else
				__multi_chyves_zfs_property "set" "$prop" "$_GUEST_pool" "guests" "$name" "$val"
			fi

			# Used to save some cycles
			local _lastguest=$name
		done
	done
}

# Frontend interface to get chyves properties
__get() {
	local prop="$1"
	local guests="$2"

	# Multi-guest support.
	# Eg.: chyves get cpu guest1,guest2,guest3
	for name in `echo "$guests" | tr ',' ' '`
	do
		__get_pool_for_guest "$name"

		if [ "$prop" = "all" ]; then
			echo "Getting all $name's chyves properties..."
			zfs get -o property,value all ${_GUEST_pool}/chyves/guests/${name} | grep chyves: | sort | sed -e 's/chyves://g'
# Middleware for setting properties, verifies user input for properties.
__verify_user_input_for_properties() {
	local _property _resource _value
	local _property="$1"
	local _value="$2"
	local _resource="$3"
	_ADJUSTED_value=""        # Needs to be reset due to being reused.

	# Do not ever allow for setting new defaults properties, to prevent confusion (except for setup)
	if [ "$_resource" = "defaults" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "master-override" ]; then
		local _valid_properties=$( __return_property_list -d )
		local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" )
		if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
			__fault_detected_exit "$_property is not a defined defaults property. \nCreating new properties for defaults is not possible."
		fi

	# Do not ever allow for setting new .config properties except bridge{n}_phy_attach and bridge{n}_tap_members, this is to prevent confusion.
	# $2 in __convert_list_to_grep_string under _string_to_grep is what is needed to allow setting bridge{n}_phy_attach and bridge{n}_tap_members as needed.
	# Use "set" directly is not recommended as it is not fully restrictive and will allow invalid bridge numbers be used which will later fail.
	elif [ "$_resource" = "global" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "master-override" ]; then
		local _valid_properties="$( __return_property_list -c )"
		local _string_to_grep="$( __convert_list_to_grep_string "$_valid_properties" "bridge([0-9]{1,5})_phy_attach|bridge([0-9]{1,5})_tap_members" )"
		if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
			__fault_detected_exit "$_property is not a defined global property. \nCreating new properties for global is not possible."
		fi

	# Property control for guests.
	elif [ "$_NUMBER_OF_ALL_GUESTS" -gt 0 ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "master-override" ]; then
		# If new property restrition is on, see if a new property name is being supplied.
		if [ "$_RESTRICT_NEW_PROPERTY_NAMES" = "on" ] && [ "$_NUMBER_OF_ALL_GUESTS" -gt "0" ]; then
			local _valid_properties=$( __return_property_list -a )
			local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" "^template$" )
			if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
				__fault_detected_exit "$_property is not a defined guest property and creation of new property creation is set to off, see 'restrict_new_property_names'."
			fi
		fi
	fi

	#
	if [ "$_resource" = "" ]; then
		__fault_detected_exit "No value supplied for $_property, aborting."

	# Guest and Defaults share many common properties. Last elif handles properties unique to defaults.
	elif [ "$_resource" = "guest" ] || [ "$_resource" = "defaults" ]; then

		# cpu
		if [ "$_property" = "cpu" ]; then
			if [ "$_value" -gt "16" ]; then
				_ADJUSTED_value="16"
				__log 1 "bhyve has a 16 CPU core limit. Setting cpu=16"
			fi
			if [ "$_value" -lt "1" ]; then
				_ADJUSTED_value="1"
				__log 1 "bhyve must be assigned at least one core. Setting cpu=1"
			fi

		# clone and clone_assc
		elif [ "$_property" = "clone" ] || [ "$_property" = "clone_assc" ]; then
			__fault_detected_warning_break 1 "Not user settable."

		# description and notes
		elif [ "$_property" = "description" ] || [ "$_property" = "notes" ]; then
			local _length="$( echo "$_value" | wc -m )"
			if [ "$_length" -gt "1024" ]; then
				_ADJUSTED_value="$( echo "$_value" | colrm 1025 )"
				__log 1 "ZFS has a 1024 character limit, truncating to the first 1024 characters."
			fi

		# loader
		elif [ "$_property" = "loader" ]; then
			if [ -z "$( echo "$_value" | grep -E '^uefi$|^bhyveload$|^grub-bhyve$' )" ]; then
				__fault_detected_warning_break 1 "Unrecognized loader type. Recognized values are bhyveload, grub-bhyve, uefi"
			fi

			# Special handling for UEFI guests
			if [ "$_value" = "uefi" ]; then
				local _uefi_firmware_source="$( zfs get -H -o source chyves:uefi_firmware $_GUEST_pool/chyves/guests/$_GUEST_name/.config )"

				# Check to see if uefi property has been previously set.
				if [ "$_uefi_firmware_source" != "local" ]; then
					__log 2 "\nTurning on other UEFI properties, using defaults to set values." -e
					__load_guest_default_parameters
					__get_next_vnc_port
					local _previous_restrict_state="$_RESTRICT_NEW_PROPERTY_NAMES"
					_RESTRICT_NEW_PROPERTY_NAMES="master-override"                 # If this is the first guest with UEFI the following properties would fail to be set without this.
					__set_chyves_zfs_property "uefi_console_output"                  "$_GDP_uefi_console_output" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_firmware"                        "$_GDP_uefi_firmware" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_mouse_type"                      "$_GDP_uefi_mouse_type" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_vnc_port"                        "$_NEXT_vnc_port" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_vnc_ip"                          "$_GDP_uefi_vnc_ip" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_vnc_res"                         "$_GDP_uefi_vnc_res" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					__set_chyves_zfs_property "uefi_pause_until_vnc_client_connect"  "$_GDP_uefi_vnc_pause" "manual" "$_GUEST_pool/chyves/guests/$_GUEST_name/.config"
					_RESTRICT_NEW_PROPERTY_NAMES="$_previous_restrict_state"       # Turn back to previous state.
				else
					__log 2 "Existing UEFI configuration on guest."
				fi
			fi

		# os
		elif [ "$_property" = "os" ]; then
			if [ -z "$( echo "$_value" | grep -E '^openbsd59$|^openbsd58$|^openbsd57$|^netbsd$|^debian$|^d8lvm$|^centos6$|^centos7$|^arch$|^gentoo$|^custom$|^default$' )" ]; then
				__log 1 "Unrecognized os type. Valid values are required for grub-bhyve guests to boot properly. See man page for valid values."
			fi

		# ram
		elif [ "$_property" = "ram" ]; then
			__get_corrected_byte_nomenclature "$_value"
			_ADJUSTED_value="$_CORRECTED_byte_nomenclature"

		# rcboot
		elif [ "$_property" = "rcboot" ]; then
			if [ -n "$( echo "$_value" | tr '[:lower:]' '[:upper:]' | grep -E '^NO$|^N$' )" ]; then
				__log 2 "Correct syntax is to use '0' rather than '$value'."
				_ADJUSTED_value=0
			elif [ -z "$( echo "$_value" | grep -E '^[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'rcboot' property is any positive integer or zero."
			fi

		# serial
		elif [ "$_property" = "serial" ]; then
			if [ -z "$( echo "$_value" | grep -E '^nmdm[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'serial' property is 'nmdm' followed by any unique positive integer."
			fi
			echo "It is not recommmended to set this property manually."

		# template
		elif [ "$_property" = "template" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' property is 'yes' or 'no'."
			fi

		# uefi_console_output
		elif [ "$_property" = "uefi_console_output" ]; then
			if [ -z "$( echo "$_value" | grep -E '^serial$|^vnc$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_console_output property is 'serial' or 'vnc'."
			fi

		# uefi_firmware
		elif [ "$_property" = "uefi_firmware" ]; then
			__log 2 "Verifying firmware resource dataset... " -n
			__verify_valid_dataset "Firmware/$_value"
			__log 2 "done"

		# uefi_mouse_type
		elif [ "$_property" = "uefi_mouse_type" ]; then
			if [ -z "$( echo "$_value" | grep -E '^ps2$|^usb3$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_mouse_type' is 'ps2' or 'usb3'."
			fi

		# uefi_pause_until_vnc_client_connect
		elif [ "$_property" = "uefi_pause_until_vnc_client_connect" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_pause_until_vnc_client_connect' is 'yes' or 'no'."
			fi

		# uefi_vnc_ip
		elif [ "$_property" = "uefi_vnc_ip" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}$' )" ]; then
				__fault_detected_warning_break 1 "Correct value for '$_property' is an IPv4 address. Example: 192.168.100.2"
			fi

			# Check IP octets are correct.
			for _octet in `echo "$_value" | tr '.' ' '`
			do
				if [ "$_octet" -gt 255 ] || [ "$_octet" -lt 0 ]; then
					__fault_detected_warning_break 1 "Invalid IPv4 octet value"
				fi
			done

			# Check if IP is configured on system.
			if [ "$_value" = "0.0.0.0" ]; then
				__log 2 "Keep in mind, using the default value '0.0.0.0' for '$_property' does pose a security risk."
			elif [ -z "$( echo "$_value" | grep -E "$( __return_new_line_delimit_as_grep_string "$( ifconfig | grep inet | awk '{ print $2 }' | grep -E '^[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}$' )" )" )" ]; then
				__log 1 "IPv4 address ($_value), not found on system. Connection to VNC will fail."
			fi

		# uefi_vnc_port
		elif [ "$_property" = "uefi_vnc_port" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,5}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' property is a positive integer 0 through 65535."
			fi
			if [ "$_value" -lt 0 ] || [ "$_value" -gt 65535 ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' property is a positive integer within 0 through 65535 range."
			fi

		# uefi_vnc_res
		elif [ "$_property" = "uefi_vnc_res" ]; then
			if [ -z "$( echo "$_value" | grep -E '^1920x1200$|^1920x1080$|^1600x1200$|^1600x900$|^1280x1024$|^1280x720$|^1024x768$|^800x600$|^640x480$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for 'uefi_vnc_res' are in the man page."
			fi

		# uuid
		elif [ "$_property" = "uuid" ]; then
			if [ -z "$( echo "$_value" | grep -E '$_UUID_CHECK_GREP_STRING' )" ]; then
				__fault_detected_warning_break 1 "Value for '$_property', not in UUID format. Example: '21EC2020-3AEA-4069-A2DD-08002B30309D'"
			fi

		# Verify properties unique to defaults. This always needs to be just before the else catch all.
		elif [ "$_resource" = "defaults" ]; then

			# bridge
			if [ "$_property" = "bridge" ]; then
				__verify_valid_iface_format $_value
				if [ "$_IFACE_type" != "bridge" ]; then
					__fault_detected_warning_break 1 "Valid value for 'bridge' must be a bridge name."
				fi

			# disk_compression
			elif [ "$_property" = "disk_compression" ]; then
				if [ -z "$( echo "$_value" | grep -E '^on$|^off$|^lzjb$|^gzip$|^gzip-[1-9]{1}$|^zle$|^lz4$|^inherit$' )" ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi

			# disk_primarycache & disk_secondarycache
			elif [ "$_property" = "disk_primarycache" ] || [ "$_property" = "disk_secondarycache" ]; then
				if [ -z "$( echo "$_value" | grep -E '^all$|^none$|^metadata$|^inherit$' )" ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi

			# disk_volblocksize
			elif [ "$_property" = "disk_volblocksize" ]; then
				__gvset_user_input_to_bytes "$_value"
				_ADJUSTED_value="$_USER_input_to_bytes"
				if [ "$_ADJUSTED_value" -gt 131072 ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi

			# disk_volmode
			elif [ "$_property" = "disk_volmode" ]; then
				if [ -z "$( echo "$_value" | grep -E '^geom$|^dev$|^inherit$' )" ]; then
					__fault_detected_warning_break 1 "Invalid value for '$_property', think of the kittens."
				fi
				if [ "$_value"="geom" ]; then
					__log 1 "[WARNING] While setting the value for 'disk_volmode' to 'geom' will work, the host OS can interfere and possibly corrupt the guest disk."
				fi

			# size
			elif [ "$_property" = "size" ]; then
				__get_corrected_byte_nomenclature "$_value"
				_ADJUSTED_value="$_CORRECTED_byte_nomenclature"
			fi

		# Catch all for guests.
		else
			echo "Getting $name's property \"$prop\"..."
			__multi_chyves_zfs_property "get" "$prop" "$_GUEST_pool" "guests" "$name"
			__log 1 "No input verification for guest '$_property' property written. Beware of dragons."
		fi
	done

	# Verify global properties
	elif [ "$_resource" = "global" ]; then

		# auto_load_kernel_mods
		if [ "$_property" = "auto_load_kernel_mods" ]; then
			if [ -z "$( echo "$_value" | grep -E '^no$|^yes$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'yes' or 'no'"
			fi

		# bridge{n}_tap_members
		elif [ -n "$( echo "$_property" | grep -E '^bridge[0-9]{1,5}_tap_members$' )" ]; then
			__fault_detected_warning_break 1 "Use 'chyves network' to indirectly manage property: '$_property'."

		# check_for_updates
		elif [ "$_property" = "check_for_updates" ]; then
			if [ -z "$( echo "$_value" | grep -E '^daily$|^weekly$|^monthly$|^always$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are: daily, weekl, monthly, and always."
			fi

		# check_for_updates_last_check
		elif [ "$_property" = "check_for_updates_last_check" ]; then
			if [ -z "$( echo "$_value" | grep -E '^20[0-9]{2}[01]{1}[0-9]{1}[0-3]{1}[0-9]{1}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', must be in YYYYMMDD."
			fi

		# check_for_updates_last_check_status
		elif [ "$_property" = "check_for_updates_last_check_status" ]; then
			if [ -z "$( echo "$_value" | grep -E '^0$|^1$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are '0' or '1'."
			fi

		# check_for_updates_timeout_seconds
		elif [ "$_property" = "check_for_updates_timeout_seconds" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property'."
			fi

		# check_for_updates_unique_id
		elif [ "$_property" = "check_for_updates_unique_id" ]; then
			if [ -z "$( echo "$_value" | grep -E '$_UUID_CHECK_GREP_STRING' )" ]; then
				__fault_detected_warning_break 1 "Value for '$_property', not in UUID format. Example: '21EC2020-3AEA-4069-A2DD-08002B30309D'"
			fi

		# chyves_version
		elif [ "$_property" = "chyves_version" ]; then
			__fault_detected_warning_break 1 "Not user settable."

		# chyves_version_int
		elif [ "$_property" = "chyves_version_int" ]; then
			__fault_detected_warning_break 1 "Not user settable."

		# console_start_offset
		elif [ "$_property" = "console_start_offset" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property'."
			fi

		# consolidate_bhyve_pci_devices
		elif [ "$_property" = "consolidate_bhyve_pci_devices" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'yes' or 'no'."
			fi

		# dataset_role
		elif [ "$_property" = "dataset_role" ]; then
			__fault_detected_warning_break 1 "Not user settable, use 'chyves dataset' to manage."

		# dataset_version
		elif [ "$_property" = "dataset_version" ]; then
			__fault_detected_warning_break 1 "Not user settable, use 'chyves dataset' to manage."

		# default_info_flags
		elif [ "$_property" = "default_info_flags" ]; then
			if [ -z "$( echo "$_value" | grep -E '^-[zbprvstcdnakl]{1,}$|^-h$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', see 'chyves info -h' for valid values."
			fi

		# default_list_flags
		elif [ "$_property" = "default_list_flags" ]; then
			if [ -z "$( echo "$_value" | grep -E '^-[zbprvstcdnakl]{1,}$|^-h$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', this function share the same backend as 'chyves info' see man page for valid values."
			fi

		# dev_mode
		elif [ "$_property" = "dev_mode" ]; then
			if [ -z "$( echo "$_value" | grep -E '^on$|^off$|^-[xvn]{1}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property'."
			fi

		# log_mode
		elif [ "$_property" = "log_mode" ]; then
			if [ -z "$( echo "$_value" | grep -E '^host$|^guest$|^dual$|^off$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'host', 'guest', or 'dual'."
			fi

		# log_to_file
		elif [ "$_property" = "log_to_file" ]; then
			if [ -z "$( echo "$_value" | grep -E '^on$|^off$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'on' or 'off'."
			fi

		# network_design_mode
		elif [ "$_property" = "network_design_mode" ]; then
			if [ -z "$( echo "$_value" | grep -E '^auto$|^system$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'auto' or 'system'."
			fi

		# restrict_new_property_names
		elif [ "$_property" = "restrict_new_property_names" ]; then
			if [ -z "$( echo "$_value" | grep -E '^on$|^off$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'on' and 'off'."
			fi

		# stdout_level
		elif [ "$_property" = "stdout_level" ]; then
			if [ -z "$( echo "$_value" | grep -E '[0-4]{1}' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are '0', '1', '2', '3', or '4'. See man page for meaning."
			fi

		# tap_start_offset
		elif [ "$_property" = "tap_start_offset" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,5}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 32768."
			elif [ "$_value" -lt 0 ] && [ "$_value" -gt 32768 ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 32768."
			fi

		# tap_up_by_default
		elif [ "$_property" = "tap_up_by_default" ]; then
			if [ -z "$( echo "$_value" | grep -E '^yes$|^no$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are 'yes' or 'no'. "
			fi

		# uefi_vnc_port_start_offset
		elif [ "$_property" = "uefi_vnc_port_start_offset" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[0-9]{1,5}$' )" ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 65535."
			elif [ "$_value" -lt 0 ] && [ "$_value" -gt 65535 ]; then
				__fault_detected_warning_break 1 "Correct values for '$_property' is a positive integer 0 through 65535."
			fi

		# vlan_iface_base_name
		elif [ "$_property" = "vlan_iface_base_name" ]; then
			if [ -z "$( echo "$_value" | grep -E '^[a-z]{1,}$' )" ]; then
				__fault_detected_warning_break 1 "Invalid value for '$_property', valid values are any alphabetic words."
			fi
		fi
	fi

	# Check to not exceed ZFS 1024 character limit, this does not apply to desc or notes as those are truncated. For other properties it might be detrimental to do so, such as the net properties.
	local _length="$( echo "$_value" | wc -m )"
	if [ "$_length" -gt "1024" ]; then
		__fault_detected_warning_break 1 "Value is longer than 1024 character. ZFS's limit is 1024, aborting rather than causing futher issues."
	fi

	# echo "Valid user input... "
}
