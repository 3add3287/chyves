#!/bin/sh

# Copyright (c) 2015, pr1ntf (Trent Thompson) All rights reserved.
# Copyright (c) 2016, Justin D Holcomb All rights reserved.
# Copyright (c) 2016, chyves All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

_VERSION=0.0.0                        # Example: v11.6.25 - XXX.YY.ZZZ
_VERSION_LONG="v0.0.0 2016/04/00"     # Example: v11.6.25 2021/12/31
_VERSION_INT="00000000"               # Example: 01106025 XXXYYZZZ
_VERSION_DATASET="0001"
_VERSION_BRANCH=master
_OS=$( sysctl -n kern.ostype )
_OS_VERSION_DATE=$( sysctl -n kern.osreldate )
_OS_VERSION_FREENAS=$( [ -e "/etc/version" ] && cat /etc/version )
_OS_VERSION_REL=$( sysctl -n kern.osrelease )
_OS_VERSION_REV=$( sysctl -n kern.osrevision )
_PROJECT_URL=http://chyves.org
_PROJECT_URL_GIT="https://github.com/chyves/chyves"
_DATE_YMD=$( date +"%Y%m%d" )
_UUID_GENERAL_USE="$(/bin/uuidgen)"
_UUID_GUEST_USE="$(/bin/uuidgen)"
_OLD_VERSION_DATASETS="$(zfs get -H -o name,value -t filesystem -r chyves:dataset_version | grep chyves/.config | grep -v "${_VERSION_DATASET}" )"
_OFFLINE_POOLS_GREP_STRING=$(zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "offline" | cut -d'/' -f1 | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g')
_TEMPLATE_GUESTS_GREP_STRING=$(zfs get -H -o name,value -t filesystem -r chyves:guest_role | grep "chyves/guests" | grep "template" | cut -d'/' -f1 | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g')
_FREEBSD_NET_DRIVERS_GREP_STRING='^bxe[0-9]?[0-9]?$|^de[0-9]?[0-9]?$|^em[0-9]?[0-9]?$|^igb[0-9]?[0-9]?$|^ix[0-9]?[0-9]?$|^ixv[0-9]?[0-9]?$|^ixl[0-9]?[0-9]?$|^ixlv[0-9]?[0-9]?$|^le[0-9]?[0-9]?$|^ti[0-9]?[0-9]?$|^txp[0-9]?[0-9]?$|^vx[0-9]?[0-9]?$|^miibus[0-9]?[0-9]?$|^ae[0-9]?[0-9]?$|^age[0-9]?[0-9]?$|^alc[0-9]?[0-9]?$|^ale[0-9]?[0-9]?$|^bce[0-9]?[0-9]?$|^bfe[0-9]?[0-9]?$|^bge[0-9]?[0-9]?$|^cas[0-9]?[0-9]?$|^dc[0-9]?[0-9]?$|^et[0-9]?[0-9]?$|^fxp[0-9]?[0-9]?$|^gem[0-9]?[0-9]?$|^hme[0-9]?[0-9]?$|^jme[0-9]?[0-9]?$|^lge[0-9]?[0-9]?$|^msk[0-9]?[0-9]?$|^nfe[0-9]?[0-9]?$|^nge[0-9]?[0-9]?$|^nve[0-9]?[0-9]?$|^pcn[0-9]?[0-9]?$|^re[0-9]?[0-9]?$|^rl[0-9]?[0-9]?$|^sf[0-9]?[0-9]?$|^sge[0-9]?[0-9]?$|^sis[0-9]?[0-9]?$|^sk[0-9]?[0-9]?$|^ste[0-9]?[0-9]?$|^stge[0-9]?[0-9]?$|^tl[0-9]?[0-9]?$|^tx[0-9]?[0-9]?$|^vge[0-9]?[0-9]?$|^vr[0-9]?[0-9]?$|^wb[0-9]?[0-9]?$|^xl[0-9]?[0-9]?$|^cs[0-9]?[0-9]?$|^ed[0-9]?[0-9]?$|^ex[0-9]?[0-9]?$|^ep[0-9]?[0-9]?$|^fe[0-9]?[0-9]?$|^sn[0-9]?[0-9]?$|^xe[0-9]?[0-9]?$|^an[0-9]?[0-9]?$|^ath[0-9]?[0-9]?$|^ath_pci[0-9]?[0-9]?$|^ath_hal[0-9]?[0-9]?$|^bwi[0-9]?[0-9]?$|^bwn[0-9]?[0-9]?$|^ipw[0-9]?[0-9]?$|^iwi[0-9]?[0-9]?$|^iwn[0-9]?[0-9]?$|^malo[0-9]?[0-9]?$|^mwl[0-9]?[0-9]?$|^ral[0-9]?[0-9]?$|^wi[0-9]?[0-9]?$|^wpi[0-9]?[0-9]?$'
_KERNEL_MODULES=$(printf "%s\n%s\n%s\n%s\n%s" "vmm" "nmdm" "if_tap" "bridgestp" "if_bridge")
_NUMBER_OF_ALL_GUESTS=$( zfs list -d 3 -r -o name | grep chyves/guests/ | grep -v .defaults | wc -l )
_FORBIDDEN_GUEST_NAMES=".defaults|reorder|reset"

##### More global variables set in __preflight_check #####
PATH=${PATH}:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin

# This function gets ran before any other.
__preflight_check() {

	# Checks to see variable is empty as grep needs an arguement and a UUID stastically should not have a collision if there are no pools in an offline role
	if [ -z "$_OFFLINE_POOLS_GREP_STRING" ]; then
	  _OFFLINE_POOLS_GREP_STRING=${_UUID_GENERAL_USE}
	fi

	# Appends ".defaults" to $_TEMPLATE_GUESTS_GREP_STRING
	if [ -z "$_TEMPLATE_GUESTS_GREP_STRING" ]; then
	  _TEMPLATE_GUESTS_GREP_STRING=".defaults"
	else
	  _TEMPLATE_GUESTS_GREP_STRING=$( echo "${_TEMPLATE_GUESTS_GREP_STRING}|.defaults" )
	fi

	# Check for out of date datasets when not running setup.
	if [ ! -z "$_OLD_VERSION_DATASETS" ] && [ "$1" != "setup" ]; then
	  __fault_detected_exit "Out of date chyves\' dataset(s) version found. \nPlease install sysutils/chyves-utils and then run: \nchyves-upgrade"
	fi

	# Check to see if more than one pool has the primary role set.
	if [ "$(zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "primary" | wc -l )" -gt "1" ]; then
		__fault_detected_exit "More than one primary pool set, fix it!"
	fi

	# Check for out of date datasets when not running setup.
	if [ ! -z "$_OLD_VERSION_DATASETS" ] && [ "$1" != "setup" ]; then
		echo "Out of date chyves\' dataset(s) version found."
		echo "Please install sysutils/chyves-utils and then run:"
		echo "chyves-upgrade"
		exit 1
	fi

	# If no sub-command is used, run the help function
	if [ -z "$1" ] ; then
		__help
		exit 0
	fi

	# Check to see if running with elevated credentials
	if [ $(__readonly_cmd "$1") != "0" -a "$(whoami)" != "root" ] ; then
		echo "The $1 command needs root credentials!"
		exit 1
	fi

	# CPU feature check
	# First check to see if EPT/RVI is available then complain if "unrestricted guests" is not found on an Intel CPU.
	if [ -n "$( __get_cpu_section_from_dmesg | grep 'Features2=' | grep 'POPCNT' )" ]; then
		if [ -n "$( __get_cpu_section_from_dmesg | grep 'CPU:' | grep 'Intel' )" ] && [ -z "$( __get_cpu_section_from_dmesg | grep 'VT-x:' | grep 'UG' )" ]; then
			echo "This CPU lacks the 'UG' feature of EPT. This is required by bhyve to run to the full extent."
			echo "Due to this missing CPU feature: a guest is limited to one virtual CPU and starting UEFI guests is disabled."
			echo "See CPU feature flags below:"
			__get_cpu_section_from_dmesg
			# Insert way to disable this warning later on.
			_CPU_MISSING_UG=1
		fi
	else
		__fault_detected_exit "Your CPU lacks the basic feature to run bhyve. For AMD CPUs this means RVI. For Intel CPUs this means EPT."
	fi

	# Variables that need functions loaded:
	__get_primary_pool_name   # _PRIMARY_POOL
	_NUMBER_OF_ACTIVE_POOLS=$( zfs get -H -o name -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING" | wc -l )
	if [ -z "$_PRIMARY_POOL" ]; then
		echo "Run setup to install chyves dataset on a pool."
		[ "$1" != "setup" ] && __fault_detected_exit "No seriously, run \"chyves setup pool=<ZFS-pool-name>\""
	else
		_DEVELOPER_MODE=$( __multi_chyves_zfs_property                       "get" "dev_mode"                             "primary" ".config" )
		_RESTRICT_NEW_PROPERTY_NAMES=$( __multi_chyves_zfs_property          "get" "restrict_new_property_names"          "primary" ".config" )
		_VLAN_IFACE_BASE_NAME=$( __multi_chyves_zfs_property                 "get" "vlan_iface_base_name"                 "primary" ".config" )
		_TAP_UP_BY_DEFAULT=$( __multi_chyves_zfs_property                    "get" "tap_up_by_default"                    "primary" ".config" )
		_CHECK_FOR_UPDATES=$( __multi_chyves_zfs_property                    "get" "check_for_updates"                    "primary" ".config" )
		_CHECK_FOR_UPDATES_TIMEOUT_SECONDS=$( __multi_chyves_zfs_property    "get" "check_for_updates_timeout_seconds"    "primary" ".config" )
		_CHECK_FOR_UPDATES_LAST_CHECK=$( __multi_chyves_zfs_property         "get" "check_for_updates_last_check"         "primary" ".config" )
		_CHECK_FOR_UPDATES_LAST_CHECK_STATUS=$( __multi_chyves_zfs_property  "get" "check_for_updates_last_check_status"  "primary" ".config" )
		_CHECK_FOR_UPDATES_UNIQUE_ID=$( __multi_chyves_zfs_property          "get" "check_for_updates_unique_id"          "primary" ".config" )
		_CHECK_FOR_UPDATES_URL="$_PROJECT_URL_GIT/raw/${_VERSION_BRANCH}/lib/chy-version"
	fi

	if [ "$_TAP_UP_BY_DEFAULT" = yes ]; then
		__verify_kernel_module_loaded if_tap -l
		sysctl net.link.tap.up_on_open=1 > /dev/null 2>&1
	fi
}

# Function used to exit with a message.
__fault_detected_exit() {
  local message="$1"
  echo "Critical error detected. Exiting for following reason:"
  echo -e "${message}"
  exit 1
}

# See whether given command is readonly
# and therefore doesn't need root credentials
__readonly_cmd() {
    case "$1" in
        help|-h|get|getall|info|list|version) echo "0"
            ;;
        *) echo "1"
            ;;
    esac
}

# Verify I/O MMU (iommu) for guests using PCI passthrough
__verify_iommu_capable() {
	local _acpidump=$( acpidump -t | grep DMAR )

	# CPU missing DMAR are not VT-d capable.
	if [ -z "$_acpidump" ]; then
		__get_cpu_section_from_dmesg
		__fault_detected_exit "CPU missing I/O MMU capability or is disabled in the BIOS. \nPCI Passthrough requires I/O MMU to function. \nPlease check your CPU manufacture's spec page for your CPU. \nI/O MMU is called AMD-Vi for AMD CPUs and VT-d for Intel CPUs."
	fi
}

# Validates if a given pool name exists.
__verify_valid_pool() {
	local _name_to_check="$1"
	local _flags="$2"
	# Valid _flags are:
	# $null   [no flag used] Validates the supplied pool is in fact a ZFS pool
	# -p      [primary] Validates the supplied pool has the primary role set
	# -c      [chyves] Validates the supplied pool is setup for chyves
	# -n      [no-exit] Escape from a normally fatal exit. Good for __setup.

	# Check to see if pool exists
	zfs list -H $_name_to_check > /dev/null 2>&1
	if [ "$?" = 0 ]; then

		# Check to see if the pool has been setup for chyves
		if [ -n "$(echo $_flags | grep -E "c|p" )" ]; then
			zfs list -H ${_name_to_check}/chyves > /dev/null 2>&1
			if [ "$?" = 0 ]; then
				if [ -n "$(echo $_flags | grep 'n')" ]; then  # If -n flag is used, exit.
					__fault_detected_exit "${_name_to_check} has been setup with chyves."
				fi
			else
				if [ -z "$(echo $_flags | grep 'n')" ]; then  # If -n flag is not used, exit.
					__fault_detected_exit "${_name_to_check} has not been setup with chyves."
				fi
			fi
		fi

		# Check to see if the pool is in the primary dataset_role
		if [ -n "$(echo $_flags | grep 'p')" ] && [ "$( zfs get -H -o value chyves:dataset_role $_name_to_check/chyves/.config )" != "primary" ]; then
			if [ -z "$(echo $_flags | grep 'n')" ]; then  # If -n flag is not used, exit.
				__fault_detected_exit "${_name_to_check} is not a primary pool."
			fi
		fi
	else
		# If -n flag is not used, exit.
		if [ -z "$(echo $_flags | grep 'n')" ]; then
			__fault_detected_exit "Invalid pool name supplied."
		fi
	fi
}

# Validates if a given guest name on a given pool exists.
__verify_valid_guest() {
	local _guest_to_check="$1"
	local _pool="$2"
	local _flags="$3"
	# Valid _flags are:
	# $null   [no flag used] Validates the supplied pool is in fact on the supplied ZFS pool
	# -s      [start] Exits if guest is a template or on an offline pool

	# Check to see if guest name used more than once
	if [ "$(zfs list -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_to_check" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING" | wc -l )" -gt "1" ]; then
		__fault_detected_exit "More than one \"$_guest_to_check\" exists on system within active pools and guests."
	fi

	# Checks to run when validating unused guest name for create/clone/etc
	if [ -z "$_pool" ]; then

		# Check if guest name is forbidden
		[ -n  "$( echo "$_guest_to_check" | grep -E "$_FORBIDDEN_GUEST_NAMES" )" ] && __fault_detected_exit "\"$_guest_to_check\" name is forbidden."

		# Check for valid guest name and length
		[ -n "$( echo "$_guest_to_check" | grep -v -E "^[a-zA-Z0-9_.-]{1,27}$" )" ] && __fault_detected_exit "Unsuitable name: '$_guest_to_check', must be alphanumeric between 1 and 27 characters and optionally can contain dashes '-', underscores '_', and or periods '.'."

		# Check if guest name in use on active pool.
		if [ "$(zfs list -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_to_check" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" | wc -l )" -gt "0" ]; then
			__fault_detected_exit "\"$_guest_to_check\" name already in use on system within active pools and guests."
		fi

	# Normal check of guest and pool combo
	else
		# Check to see if pool has chyves setup on it.
		__verify_valid_pool "$_pool" "-c"

		# Check if valid guest name and pool given.
		if [ ! -n "$(zfs list -H $_pool/chyves/guests/$_guest_to_check | grep -v "dataset does not exist" | grep -v "No such file or directory" )" ]; then
			__fault_detected_exit "Invalid guest name (${_guest_to_check}) supplied."
		fi

		# Exits if guest is a template or on an offline pool.
		if [ -n "$(echo $_flags | grep 's')" ] && [ -z "$(zfs list -r -H -t filesystem -o name | grep "$_pool/chyves/guests/$_guest_to_check" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" )" ]; then
			__fault_detected_exit "$_guest_to_check is either a template or contained within a chyves dataset where the dataset_role is set to 'offline'."
		fi
	fi
}

# Verify kernel module loaded
__verify_kernel_module_loaded() {
	local _module="$1"
	local _flags="$2"
	local _status=$(kldstat -v | grep $_module )
	# Valid _flags are:
	# $null   [no flag used] check only
	# -l      [load] Load module if not loaded
	# -u      [unload] Unload module

	# When erroring out the following message is displayed:
	# kldload: can't load $_module: No such file or directory
	if [ -z "$_status" ]; then
		if [ "$_flags" = "-l" ]; then
			kldload $_module
			sleep 5
			__verify_kernel_module_loaded "$_module"
		else
			__fault_detected_exit "Kernel module '$_module' not loaded. Run 'chyves setup kmod=1'"
		fi
	elif [ "$_flags" = "-u" ]; then
		kldunload -v $_module
		echo "Kernel module '$_module' loaded."
	else
		# echo "Kernel module '$_module' already loaded."
	fi
}

# Verify all modules in $_KERNEL_MODULES
__verify_all_kernel_modules(){
	local _flag="$1"
	# Valid _flag are:
	# $null   [no flag used] check only
	# -l      [load] Load module if not loaded
	# -u      [unload] Unload module

	if [ -z "$_flag" ] || [ "$_flag" = "-l" ] || [ "$_flag" = "-u" ]; then
		for _module in $_KERNEL_MODULES ; do
			echo "Checking module: $_module"
			__verify_kernel_module_loaded "$_module" "$_flag"
		done
	fi
}

# Verify that a binary is available
__verify_binary_available() {
	local _binary_to_check_for="$1"
	local _path_to_binary=$( which ${_binary_to_check_for} )

	if [ ! -x "${_path_to_binary}" ]; then
		__fault_detected_exit "Failed to find executable binary: '$_binary_to_check_for'"
	fi
}

# Verifies the number of parameters and exits if met or exceeded
__verify_number_of_arguments() {
	local _number_of_minimum_parameters=$1        # Minimum number of parameters
	local _number_of_supplied_parameters=$2       # As counted by "$#"
	local _number_of_maximum_parameters=$3        # (Optional) Maximum number of parameters

	# While $3 is optional, it does need a value if not set.
	[ -z "${_number_of_maximum_parameters}" ] && local _number_of_maximum_parameters=$_number_of_supplied_parameters

	if [ "${_number_of_supplied_parameters}" -lt "${_number_of_minimum_parameters}" ] || [ "${_number_of_supplied_parameters}" -gt "${_number_of_maximum_parameters}" ]; then
		__help
		__fault_detected_exit "Incorrect number of arguments used. Please see above for correct syntax."
	fi
}

# Checks to see if on FreeNAS
# The web UI references this file to display the version
__check_if_freenas() {
	if [ -e /etc/version ]; then
		local OS=$( cat /etc/version | cut -d - -f1 )
		if [ "$OS" = "FreeNAS" ]; then
			echo 1
		fi
	fi
}

# Check for chyves updated
__check_for_chyves_update() {
	if [ "$_CHECK_FOR_UPDATES" != "off" ]; then
		[ "$_CHECK_FOR_UPDATES" = "daily" ] && local _num_of_updays=1
		[ "$_CHECK_FOR_UPDATES" = "monthly" ] && local _num_of_updays=30
		[ "$_CHECK_FOR_UPDATES" = "always" ] && local _num_of_updays=0
		[ -z "$_num_of_updays" ] && local _num_of_updays=7
		local _check_again_date=`date -v -${_num_of_updays}d +"%Y%m%d"`

		if [ "$_CHECK_FOR_UPDATES_LAST_CHECK_STATUS" -eq 1 ]; then
			echo "NEWER VERSION of chyves available. Check $_PROJECT_URL_GIT/tree/$_VERSION_BRANCH"
		elif [ "$_check_again_date" -ge "$_CHECK_FOR_UPDATES_LAST_CHECK" ]; then
			echo "Checking for newer version of chyves on the $_VERSION_BRANCH branch from $_CHECK_FOR_UPDATES_URL."
			local _fetched_version_library=$( fetch --timeout $_CHECK_FOR_UPDATES_TIMEOUT_SECONDS --quiet -o - --user-agent="chyves $_VERSION_LONG ( $_OS $_OS_VERSION_REL $_OS_VERSION_DATE $_OS_VERSION_REV $_OS_VERSION_FREENAS ; ${_CHECK_FOR_UPDATES_UNIQUE_ID}; )" $_CHECK_FOR_UPDATES_URL )
			local _grepped_version=$( echo "$_fetched_version_library" | grep '$_VERSION_INT' | cut -d'"' -f1 )

			if [ -z "$_grepped_version" ]; then
				echo "Unable to obtain current available version information from $_CHECK_FOR_UPDATES_URL after $_CHECK_FOR_UPDATES_TIMEOUT_SECONDS seconds."
			elif [ "$_grepped_version" -gt "$_VERSION_INT" ]; then
				__multi_chyves_zfs_property "set" "check_for_updates_last_check" "primary" ".config" "-" "$_DATE_YMD"
				echo "NEWER VERSION of chyves available. Check $_PROJECT_URL_GIT/tree/$_VERSION_BRANCH"
				__multi_chyves_zfs_property "set" "check_for_updates_last_check_status" "primary" ".config" "-" "1"
			elif [ "$_grepped_version" -eq "$_VERSION_INT" ]; then
				local _next_check_date=`date -v +${_num_of_updays}d +"%Y%m%d"`
				__multi_chyves_zfs_property "set" "check_for_updates_last_check" "primary" ".config" "-" "$_DATE_YMD"
				echo "On current version, will check again on: $_next_check_date"
				__multi_chyves_zfs_property "set" "check_for_updates_last_check_status" "primary" ".config" "-" "0"
			fi
		fi
	fi
}

# Set new UUID in _UUID_GUEST_USE
__set_new_uuid_guest_use() {
	_UUID_GUEST_USE="$(/bin/uuidgen)"
}

# Gets pool names from ZFS with flag options for active/inactive
__get_pool_names() {
	local _flags="$1"
	# Valid flags are:
	# -a [all] for  primary|secondary|offline pools
	# -i [inactive] only display offline pools

	if [ -n "$(echo "$_flags" | grep 'a')" ]; then
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq )"
	elif [ -n "$(echo "$_flags" | grep 'i')" ]; then
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq | grep -E "$_OFFLINE_POOLS_GREP_STRING" )"
	else
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq | grep -E -v "$_OFFLINE_POOLS_GREP_STRING" )"
	fi
}

# Get pool name for guest
__get_pool_for_guest() {
	local _guest_name="$1"
	[ -z $( zfs list -d 3 -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_name" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" ) ] && __fault_detected_exit "Invalid active guest name, '$_guest_name'"
	_GUEST_pool="$(zfs list -d 3 -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_name" | cut -d '/' -f 1 )"
	__verify_valid_pool "$_GUEST_pool"
	__verify_valid_guest "$_guest_name" "$_GUEST_pool"
}

# Get primary pool name
__get_primary_pool_name() {
	_PRIMARY_POOL="$( zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "primary" | cut -d'/' -f1 )"
	if [ -n "$_PRIMARY_POOL" ]; then
		__verify_valid_pool "$_PRIMARY_POOL" "-p"
	fi
}

# Get guests name by supplied pid
__get_guest_name_by_pid() {
	local _pid="$1"

	for _guest in `__get_guests_list`
	do
		local _this_guest_pid=$( __check_bhyve_process_running $_guest )
		[ -z "$_this_guest_pid" ] && continue
		if [ "$_pid" -eq "$_this_guest_pid" ]; then
			_GUEST_name_by_pid="$_guest"
			break
		fi
	done
}

#  Get all chyves properties that are set on the system
__get_property_list() {
	local _flags="$1"
	local _guest="$2"
	# $null   Get a list of guest properties
	# -a      [all] Get a list of all guest properties including .defaults
	# -d      [defaults] Get a list of .defaults only properties
	# -c      [config] Get a list of .config only properties

	if [ -n "${_guest}" ]; then
		__get_pool_for_guest $_guest
		zfs get -r -H -t filesystem -o name,property all | grep -w  "$_GUEST_pool/chyves/guests/$_guest" | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-a" ]; then
		zfs get -r -H -t filesystem -o name,property all | grep /guests/ | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-d" ]; then
		zfs get -r -H -t filesystem -o name,property all $_PRIMARY_POOL/chyves/guests/.defaults | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-c" ]; then
		zfs get -r -H -t filesystem -o name,property all $_PRIMARY_POOL/chyves/.config | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	else
		zfs get -r -H -t filesystem -o name,property all | grep /guests/ | grep -v .defaults | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	fi
}

# Return the next console to use
__get_next_console() {
	local _conlast="$( zfs get -H -o value chyves:con | grep -v - | sort -V | tail -n1 | cut -c 5- )"
	if [ -z $_conlast ]; then
		local _conlast="$( __multi_chyves_zfs_property "get" "console_start_offset" "primary" ".config" )"
	else
		local _conlast="$( expr $_conlast + 1 )"
	fi
	_NEXT_console="nmdm$_conlast"
}

# Return the next tap interface to use
__get_next_tap() {
	local _taplast="$( zfs get -H -o value chyves:tap | grep -v - | tr ',' '\n' | grep -v vale | sort -V | tail -n1 | cut -c 4- )"
	if [ -z $_taplast ]; then
		local _tap_num="$( __multi_chyves_zfs_property "get" "tap_start_offset" "primary" ".config" )"
	else
		local _tap_num="$( expr $_taplast + 1 )"
	fi
	_NEXT_tap="tap$_tap_num"
}

# Return the next vnc port to use
__get_next_vnc_port() {
	local _vnc_port_last="$( zfs get -H -o value chyves:uefi_vnc_port | grep -v - | sort -V | tail -n1 | cut -c 5- )"
	if [ -z $_vnc_port_last ]; then
		local _vnc_port_last="$( __multi_chyves_zfs_property "get" "uefi_vnc_port_start_offset" "primary" ".config" )"
	else
		local _vnc_port_last="$( expr $_vnc_port_last + 1 )"
	fi
	_NEXT_vnc_port="$_vnc_port_last"
}

# Get a list of guests on system
__get_guests_list() {
	local _flags="$1"
	local _pool="$2"   # Optional
	# $null   Get a list of active guests
	# -d      [disks] Get a list of guests and their disks.
	# -a      [all] Get a list of all guests regardless if dataset_role is offline or if guest_roll is set to template
	# -f      [full] List as a full dataset name.

	if [ -n "$(echo "$_flags" | grep 'd')" ]; then
		local _zfs_command='zfs list -d 4 -r -H -t filesystem,volume -o name'

		if [ -n "$(echo "$_flags" | grep 'f')" ]; then
			local _PIPE_what_type_of_cutter='cut -f1'
		else
			local _PIPE_what_type_of_cutter='cut -d/ -f4-'
		fi
	else
		local _zfs_command='zfs list -d 3 -r -H -t filesystem -o name'
		local _PIPE_what_type_of_cutter='cut -d/ -f4'
	fi

	[ -n "${_pool}" ] && local _pool="$_pool/chyves/guests"

	if [ -n "$(echo "$_flags" | grep 'a')" ]; then
		$_zfs_command $_pool | grep chyves/guests | grep -v .defaults | $_PIPE_what_type_of_cutter | sed '/^$/d'
	else
		$_zfs_command $_pool | grep -E -v "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" | grep chyves/guests | grep -v .defaults | $_PIPE_what_type_of_cutter | sed '/^$/d'
	fi
}

# Get path for dataset
__get_path_for_guest_dataset() {
	local _guest_name="$1"
	local _pool="$2"
	local _path="$( zfs list -r -H -t filesystem -o mountpoint $_pool/chyves/guests/$_guest_name )"
	echo "$_path"
}

# Pulls CPU section from boot dmesg
__get_cpu_section_from_dmesg() {
	cat /var/run/dmesg.boot | grep -B 100 "real memory" | grep -v "real memory" | grep -A 20 "CPU:"
}

# Builds the device map file
__create_device_map() {
	local _path="$1"
	local _disk="$2"
	local _iso="$3"
	printf '\(hd0\)\ /dev/zvol/'$_disk'\n' > $_path/device.map
	printf '\(cd0\)\ '$_iso'\n' >> $_path/device.map
}

# Creates string used to create ZFS volume for disks
__create_zvol_disk_options_string() {

	# Compile a variable string to be used in the ZFS volume creation
	[ "${_GDP_disk_volmode}" != "inherit" ] && local _disk_options="-o volmode=$_GDP_disk_volmode"
	[ "${_GDP_disk_volblocksize}" != "inherit" ] && local _disk_options="$_disk_options -o volblocksize=$_GDP_disk_volblocksize"
	[ "${_GDP_disk_dedup}" != "inherit" ] && local _disk_options="$_disk_options -o dedup=$_GDP_disk_dedup"
	[ "${_GDP_disk_compression}" != "inherit" ] && local _disk_options="$_disk_options -o compression=$_GDP_disk_compression"
	[ "${_GDP_disk_primarycache}" != "inherit" ] && local _disk_options="$_disk_options -o primarycache=$_GDP_disk_primarycache"
	[ "${_GDP_disk_secondarycache}" != "inherit" ] && local _disk_options="$_disk_options -o secondarycache=$_GDP_disk_secondarycache"

	echo "$_disk_options"
}

#  get|set chyves: properties
__multi_chyves_zfs_property() {
	local _action="$1"      # get|set
	local _property="$2"    # <property name>
	local _pool="$3"        # primary|<pool name>
	local _resource="$4"    # .config|guests
	local _guest="$5"       # -|<guest name>
	local _value="$6"       # <property value>

	# Null out value when "-" used. Used for setting .config
	[ "${_guest}" = "-" ] && local _guest=""

	# If the guest variable is populated, prepend a "/" - This is for .config compatibility
	[ -n "${_guest}" ] && local _guest="/$_guest"

	# Set _pool to the primary pool name when "primary" is used in the _pool name variable.
	[ "${_pool}" = "primary" ] && local _pool=$_PRIMARY_POOL

	# Which action? get / set
	if [ "${_action}" = "get" ]; then

		# If CPU feature "UG" is missing limit to one CPU
		if [ "$_property" = "cpu" ] && [ "${_CPU_MISSING_UG}" ]; then
			echo "1"
		else
			zfs get -H -o value chyves:$_property $_pool/chyves/${_resource}${_guest}
		fi

	elif [ "${_action}" = "set" ]; then

		# If new property restrition is on, see if a new property name is being supplied.
		if [ "$_RESTRICT_NEW_PROPERTY_NAMES" = "on" ] && [ "$_NUMBER_OF_ALL_GUESTS" -gt "0" ]; then

			# Do not ever allow for setting new .defaults properties, to prevent confusion (except for setup)
			if [ "$_guest" = ".defaults" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "primary-pool-initial-setup" ]; then
				local _valid_properties=$( __get_property_list -d )
				local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" )
				if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
					__fault_detected_exit "${_property} is not a defined property ($_string_to_grep) pool. \nCreating new properties for .defaults is not possible."
				fi

			# Do not ever allow for setting new .config properties except bridge{n}_phy_attach and bridge{n}_tap_members, this is to prevent confusion.
			# $2 in __convert_list_to_grep_string under _string_to_grep is what is needed to allow setting bridge{n}_phy_attach and bridge{n}_tap_members as needed.
			# Use "set" directly is not recommended as it is not fully restrictive and will allow invalid bridge numbers be used which will later fail.
			elif [ "$_resource" = ".config" ] && [ "$_RESTRICT_NEW_PROPERTY_NAMES" != "primary-pool-initial-setup" ]; then
				local _valid_properties=$( __get_property_list -c )
				local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" "bridge([0-9]{1,5})_phy_attach|bridge([0-9]{1,5})_tap_members" )
				if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
					__fault_detected_exit "${_property} is not a defined property ($_string_to_grep) pool. \nCreating new properties for .config is not possible."
				fi

			else
				local _valid_properties=$( __get_property_list -a )
				local _string_to_grep=$( __convert_list_to_grep_string "$_valid_properties" )
				if [ -z "$( echo "$_property" | grep -w -E "$_string_to_grep" )" ]; then
					__fault_detected_exit "${_property} is not a defined property ($_string_to_grep). \nCreation of new properties turned off with 'restrict_new_property_names' in .config"
				fi
			fi
		fi

		# Correct byte nomenclature for RAM and size for .default
		if [ "$_property" = "ram" ] || [ "$_property" = "size" ]; then
			__get_corrected_byte_nomenclature "$_value"
			local _value="$_CORRECTED_byte_nomenclature"
		fi

		# Do not exceed bhyve CPU capability
		[ "$_property" = "cpu" ] && [ "$_value" -gt "16" ] && local _value="16" && echo "bhyve has a 16 CPU core limit. Setting cpu=16"

		# Made it this far, set the value for the property.
		echo "Setting \"${_property}\" to value: \"${_value}\" for ${_resource}${_guest}"
		zfs set chyves:${_property}="${_value}" $_pool/chyves/${_resource}${_guest}
	fi
}

# Check VMM resource allocation status
__check_vmm_alocated() {
	local _guest=$1
	local _flags=$2
	local _vmm_dev="/dev/vmm/chy-$_guest"
	# Valid flags are:
	# null    Return nothing or a 1
	# -h      [human] for a "YES" or "NO" indicator

	if [ "$_flags" = "-h" ]; then
		if [ -e "$_vmm_dev" ]; then
			echo "YES"
		else
			echo "NO"
		fi
	elif [ -e "$_vmm_dev" ]; then
		echo "1"
	fi
}

# Check bhyve process running status
__check_bhyve_process_running() {
	local _guest=$1
	local _flags=$2
	local _bhyve_process_running=$( pgrep -fx "bhyve: chy-$_guest" )
	# Valid flags are:
	# null    Return nothing or the PID
	# -h      [human] for a "YES (pid)" or "NO" indicator

	if [ "$_flags" = "-h" ]; then
		if [ -n "$_bhyve_process_running" ]; then
			echo "YES ($_bhyve_process_running)"
		else
			echo "NO"
		fi
	elif [ -n "$_bhyve_process_running" ]; then
		echo "$_bhyve_process_running"
	fi
}

# Displays the boot priority of a guest "YES (xxx)" where number is the priority
__display_rcboot_priority() {
	local _pool=$1
	local _guest=$2
	local _rcboot_property="$( __multi_chyves_zfs_property "get" "rcboot" "$_pool" "guests" "$_guest" )"

	if [ "$_rcboot_property" -gt '0' ]; then
		echo "YES ($_rcboot_property)"
	else
		echo "NO"
	fi
}

# Coverts a list to string that can be used for grep
# List can be delimited by a single space for each item or a new line
__convert_list_to_grep_string() {
	local _string_to_convert="$1"
	local _append_this="$2"

	if [ -z "$_string_to_convert" ]; then
		echo "$_UUID_GENERAL_USE"
	else
		local _var=$( echo "$_string_to_convert" | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g' )
		if [ -z "$_append_this" ]; then
			echo "$_var"
		else
			echo "${_var}|${_append_this}"
		fi
	fi
}

# Load guest parameters to global variables
__load_guest_parameters() {
	local _guest="$1"
	__get_pool_for_guest "$_guest"
	_GP_parameters_loaded=1

	# GP = Guest Parameter
	# Parameters held in ZFS user properties:
	_GP_bargs="$( __multi_chyves_zfs_property    "get" "bargs"    "$_GUEST_pool" "guests" "$_guest" )"
	_GP_con="$(__multi_chyves_zfs_property       "get" "con"      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_cpu="$( __multi_chyves_zfs_property      "get" "cpu"      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_fw="$( __multi_chyves_zfs_property       "get" "fw"       "$_GUEST_pool" "guests" "$_guest" )"
	_GP_loader="$( __multi_chyves_zfs_property   "get" "loader"   "$_GUEST_pool" "guests" "$_guest" )"
	_GP_os="$( __multi_chyves_zfs_property       "get" "os"       "$_GUEST_pool" "guests" "$_guest" )"
	_GP_persist="$( __multi_chyves_zfs_property  "get" "persist"  "$_GUEST_pool" "guests" "$_guest" )"
	_GP_ram="$( __multi_chyves_zfs_property      "get" "ram"      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_rcboot="$( __multi_chyves_zfs_property   "get" "rcboot"   "$_GUEST_pool" "guests" "$_guest" )"
	_GP_tap="$( __multi_chyves_zfs_property      "get" "tap"      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uuid="$( __multi_chyves_zfs_property     "get" "uuid"     "$_GUEST_pool" "guests" "$_guest" )"

	# UEFI GOP Support
	_GP_uefi_console_output="$( __multi_chyves_zfs_property "get" "uefi_console_output"                  "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_mouse_type="$( __multi_chyves_zfs_property     "get" "uefi_mouse_type"                      "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_ip="$( __multi_chyves_zfs_property         "get" "uefi_vnc_ip"                          "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_port="$( __multi_chyves_zfs_property       "get" "uefi_vnc_port"                        "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_res="$( __multi_chyves_zfs_property        "get" "uefi_vnc_res"                         "$_GUEST_pool" "guests" "$_guest" )"
	_GP_uefi_vnc_pause="$( __multi_chyves_zfs_property      "get" "uefi_pause_until_vnc_client_connect"  "$_GUEST_pool" "guests" "$_guest" )"

	# Other parameters
	_GP_path="$( __get_path_for_guest_dataset "$_guest" "$_GUEST_pool" )"
	_GP_disk0_blocksize="$( zfs get -H -o value volblocksize "$_GUEST_pool/chyves/guests/${_guest}/disk0" )"
}

# Loads .defaults parameters to global variables
__load_guest_default_parameters() {
	_GDP_parameters_loaded=1

	# GDP = Guest Default Parameter
	# Parameters held in ZFS user properties:
	_GDP_bargs="$( __multi_chyves_zfs_property      "get" "bargs"      "primary" "guests" ".defaults" )"
	_GDP_bridge="$( __multi_chyves_zfs_property     "get" "bridge"     "primary" "guests" ".defaults" )"
	_GDP_cpu="$( __multi_chyves_zfs_property        "get" "cpu"        "primary" "guests" ".defaults" )"
	_GDP_fw="$( __multi_chyves_zfs_property         "get" "fw"         "primary" "guests" ".defaults" )"
	_GDP_guest_role="$( __multi_chyves_zfs_property "get" "guest_role" "primary" "guests" ".defaults" )"
	_GDP_loader="$( __multi_chyves_zfs_property     "get" "loader"     "primary" "guests" ".defaults" )"
	_GDP_os="$( __multi_chyves_zfs_property         "get" "os"         "primary" "guests" ".defaults" )"
	_GDP_persist="$( __multi_chyves_zfs_property    "get" "persist"    "primary" "guests" ".defaults" )"
	_GDP_ram="$( __multi_chyves_zfs_property        "get" "ram"        "primary" "guests" ".defaults" )"
	_GDP_rcboot="$( __multi_chyves_zfs_property     "get" "rcboot"     "primary" "guests" ".defaults" )"
	_GDP_size="$( __multi_chyves_zfs_property       "get" "size"       "primary" "guests" ".defaults" )"

	# UEFI GOP Support
	_GDP_uefi_console_output="$( __multi_chyves_zfs_property "get" "uefi_console_output"                  "primary" "guests" ".defaults" )"
	_GDP_uefi_mouse_type="$( __multi_chyves_zfs_property     "get" "uefi_mouse_type"                      "primary" "guests" ".defaults" )"
	_GDP_uefi_vnc_ip="$( __multi_chyves_zfs_property         "get" "uefi_vnc_ip"                          "primary" "guests" ".defaults" )"
	_GDP_uefi_vnc_res="$( __multi_chyves_zfs_property        "get" "uefi_vnc_res"                         "primary" "guests" ".defaults" )"
	_GDP_uefi_vnc_pause="$( __multi_chyves_zfs_property      "get" "uefi_pause_until_vnc_client_connect"  "primary" "guests" ".defaults" )"

	# Get _disk specific properties
	_GDP_disk_volmode="$( __multi_chyves_zfs_property         "get" "disk_volmode"        "primary" "guests" ".defaults" )"
	_GDP_disk_volblocksize="$( __multi_chyves_zfs_property    "get" "disk_volblocksize"   "primary" "guests" ".defaults" )"
	_GDP_disk_dedup="$( __multi_chyves_zfs_property           "get" "disk_dedup"          "primary" "guests" ".defaults" )"
	_GDP_disk_compression="$( __multi_chyves_zfs_property     "get" "disk_compression"    "primary" "guests" ".defaults" )"
	_GDP_disk_primarycache="$( __multi_chyves_zfs_property    "get" "disk_primarycache"   "primary" "guests" ".defaults" )"
	_GDP_disk_secondarycache="$( __multi_chyves_zfs_property  "get" "disk_secondarycache" "primary" "guests" ".defaults" )"
}

__get_corrected_byte_nomenclature() {
	local _var="$1"

	[ -n "$( echo "$_var" | grep -v -E '^[0-9]{1,}[kmgtKMGT]?$' )" ] && __fault_detected_exit "Unrecognized size: '$_var', must be any integer and optionally a suffix K, M, G, or T. Megabytes are assumed if not specified."

	# Change to upper case
	local _var=$( echo "$_var" | tr '[:lower:]' '[:upper:]' )

	# Break _var into two parts number and size suffix
	local _num=$( echo "$_var" | grep -o -E "[0-9]{1,}" )
	local _suffix=$( echo "$_var" | grep -o "[kmgtKMGT]" )

	# If no suffix, then use the bhyve default of Megabytes
	[ -z "$_suffix" ] && local _suffix="M"

	# If devisable by 1024, then increase the file size denomination
	while [ "$( expr $_num % 1024 )" -eq 0 ] && [ "$_suffix" != "T" ]
	do
		local _num=$( expr $_num / 1024 )
		[ "$_suffix" = "G" ] && local _suffix="T"
		[ "$_suffix" = "M" ] && local _suffix="G"
		[ "$_suffix" = "K" ] && local _suffix="M"
	done

	_CORRECTED_byte_nomenclature="$_num$_suffix"
}

# Process command line
__parse_cmd () {
  case "$1" in
    version)  __verify_number_of_arguments "1" "$#"
              __version
              exit
    ;;
    setup)    __verify_number_of_arguments "2" "$#" "2"
              __setup "$2"
              exit
    ;;
    list)     __verify_number_of_arguments "1" "$#" "3"
              __list "$2" "$3"
              exit
    ;;
    info)     __verify_number_of_arguments "1" "$#" "2"
              __info "$2"
              exit
    ;;
    firmware) __verify_number_of_arguments "2" "$#" "5"
              __resource_functions "firmware" "$2" "$3" "$4"
              exit
    ;;
    iso)      __verify_number_of_arguments "2" "$#" "5"
              __resource_functions "iso" "$2" "$3" "$4"
              exit
    ;;
    create)   __verify_number_of_arguments "2" "$#" "4"
              __create "$2" "$3" "$4"
              exit
    ;;
    install)  __verify_number_of_arguments "3" "$#" "3"
              __install "$2" "$3"
              exit
    ;;
    start)    __verify_number_of_arguments "2" "$#" "3"
              __start "$2" "$3"
              exit
    ;;
    uefi)     __verify_number_of_arguments "2" "$#" "3"
              __uefi "$2" "$3"
              exit
    ;;
    stop)     __verify_number_of_arguments "2" "$#" "2"
              __stop "$2"
              exit
    ;;
    forcekill) __verify_number_of_arguments "2" "$#" "2"
               __forcekill "$2"
               exit
    ;;
    scram)    __verify_number_of_arguments "1" "$#" "1"
              __scram
              exit
    ;;
    destroy)  __verify_number_of_arguments "2" "$#" "2"
              __destroy "$2"
              exit
    ;;
    rename)   __verify_number_of_arguments "3" "$#" "3"
              __resource_functions "guest" "rename" "$2" "$3"
              exit
    ;;
    delete)   __verify_number_of_arguments "2" "$#" "2"
              __resource_functions "guest" "delete" "$2"
              exit
    ;;
    set)      __verify_number_of_arguments "3" "$#"           # Technically unlimited number of properties can be set.
              __set "$@"
              exit
    ;;
    get)      __verify_number_of_arguments "2" "$#" "3"
              __get "$2" "$3"
              exit
    ;;
    rmpci)    __verify_number_of_arguments "3" "$#" "4"       # Soon to be consolidated
              __rmpci "$2" "$3" "$4"
              exit
    ;;
    add)      __verify_number_of_arguments "3" "$#" "3"
              __add "$2" "$3"
              exit
    ;;
    remove)   __verify_number_of_arguments "3" "$#" "4"
              __remove "$2" "$3" "$4"
              exit
    ;;
    resize)   __verify_number_of_arguments "4" "$#" "4"
              __resize "$2" "$3" "$4"
              exit
    ;;
    disks)    __verify_number_of_arguments "2" "$#" "2"       # Can be consolidated to __list()
              __disks "$2"
              exit
    ;;
    snap)     __verify_number_of_arguments "2" "$#" "2"       # Needs a rework
              __snapguest "$2"
              exit
    ;;
    roll)     __verify_number_of_arguments "2" "$#" "2"       # Needs a rework
              __rollguest "$2"
              exit
    ;;
    clone)    __verify_number_of_arguments "3" "$#" "5"
              __cloneguest "$2" "$3" "$4" "$5"
              exit
    ;;
    export)   __verify_number_of_arguments "2" "$#" "2"       # Going to be moved to chyves-utils
              __exportguest "$2"
              exit
    ;;
    console)  __verify_number_of_arguments "2" "$#" "3"       # Tmux support soon
              __console "$2" "$3"
              exit
    ;;
    conreset) __verify_number_of_arguments "1" "$#" "1"       # Can be built to reset just one console
              __conreset
              exit
    ;;
    help|-h)  __help
              exit
    ;;
    dev)      [ "$_DEVELOPER_MODE" == "off" ] && __fault_detected_exit "Developer mode is set to "off", if desired turn on by running 'chyves set .config primary dev_mode=on'"
              [ "$_DEVELOPER_MODE" != "on" ] && set "$_DEVELOPER_MODE"
              $2 "$3" "$4" "$5" "$6" "$7" "$8" "$9"           # Used for developer to test a function directly
              [ "$_DEVELOPER_MODE" != "on" ] && set "$( echo $_DEVELOPER_MODE | sed 's/-/+/g' )"
              exit
    ;;
    *)        __help
              __fault_detected_exit "Unrecognized command: $1. See above for list of correct sub-commands."
    ;;
  esac
}

# Show version
__version() {
	echo "chyves ${_VERSION_LONG}"
}

# Setup chyves on a dataset
__setup() {
	local pool="$1"
	__verify_valid_pool "$pool" -cn
	echo "Setting up chyves on $pool..."
	zfs create $pool/chyves
	zfs create $pool/chyves/guests
	zfs create $pool/chyves/.config
	zfs set chyves:chyves_version="${_VERSION}" $pool/chyves/.config
	zfs set chyves:chyves_version_int="${_VERSION_INT}" $pool/chyves/.config
	zfs set chyves:dataset_version="${_VERSION_DATASET}" $pool/chyves/.config

	# A chyves pool is already setup, so setup as secondary pool.
	if [ -n "$_PRIMARY_POOL" ]; then
		echo "Secondary pool set up..."
		zfs set mountpoint="/chyves/$pool" $pool/chyves
		zfs set chyves:dataset_role=secondary $pool/chyves/.config

	# chyves is not set up yet, setup primary pool.
	else
		_PRIMARY_POOL=$pool
		_RESTRICT_NEW_PROPERTY_NAMES="primary-pool-initial-setup"
		zfs set mountpoint="/chyves" $_PRIMARY_POOL/chyves
		zfs create $_PRIMARY_POOL/chyves/ISO
		zfs create $_PRIMARY_POOL/chyves/Firmware

		echo "Setting up .defaults dataset and properties on primary pool..."
		zfs create $_PRIMARY_POOL/chyves/guests/.defaults
		__multi_chyves_zfs_property "set" "bargs"         "primary" "guests" ".defaults" "-A -H -P"
		__multi_chyves_zfs_property "set" "bridge"        "primary" "guests" ".defaults" "bridge0"
		__multi_chyves_zfs_property "set" "cpu"           "primary" "guests" ".defaults" "1"
		__multi_chyves_zfs_property "set" "fw"            "primary" "guests" ".defaults" "-"
		__multi_chyves_zfs_property "set" "guest_role"    "primary" "guests" ".defaults" "active"
		__multi_chyves_zfs_property "set" "loader"        "primary" "guests" ".defaults" "bhyveload"
		__multi_chyves_zfs_property "set" "network_type"  "primary" "guests" ".defaults" "bridge"
		__multi_chyves_zfs_property "set" "os"            "primary" "guests" ".defaults" "default"
		__multi_chyves_zfs_property "set" "persist"       "primary" "guests" ".defaults" "1"
		__multi_chyves_zfs_property "set" "ram"           "primary" "guests" ".defaults" "256M"
		__multi_chyves_zfs_property "set" "rcboot"        "primary" "guests" ".defaults" "0"
		__multi_chyves_zfs_property "set" "size"          "primary" "guests" ".defaults" "8G"

		__multi_chyves_zfs_property "set" "uefi_console_output"                  "primary" "guests" ".defaults" "serial"
		__multi_chyves_zfs_property "set" "uefi_mouse_type"                      "primary" "guests" ".defaults" "ps2"
		__multi_chyves_zfs_property "set" "uefi_vnc_ip"                          "primary" "guests" ".defaults" "0.0.0.0"
		__multi_chyves_zfs_property "set" "uefi_vnc_res"                         "primary" "guests" ".defaults" "800x600"
		__multi_chyves_zfs_property "set" "uefi_pause_until_vnc_client_connect"  "primary" "guests" ".defaults" "yes"

		__multi_chyves_zfs_property "set" "disk_volmode"         "primary" "guests" ".defaults" "dev"
		__multi_chyves_zfs_property "set" "disk_volblocksize"    "primary" "guests" ".defaults" "512"
		__multi_chyves_zfs_property "set" "disk_dedup"           "primary" "guests" ".defaults" "inherit"
		__multi_chyves_zfs_property "set" "disk_compression"     "primary" "guests" ".defaults" "inherit"
		__multi_chyves_zfs_property "set" "disk_primarycache"    "primary" "guests" ".defaults" "inherit"
		__multi_chyves_zfs_property "set" "disk_secondarycache"  "primary" "guests" ".defaults" "inherit"

		echo "Setting up .config properties on primary pool..."
		__multi_chyves_zfs_property "set" "console_start_offset"                 "primary" ".config" "-" "50"
		__multi_chyves_zfs_property "set" "dataset_role"                         "primary" ".config" "-" "primary"
		__multi_chyves_zfs_property "set" "dev_mode"                             "primary" ".config" "-" "on"
		__multi_chyves_zfs_property "set" "log_mode"                             "primary" ".config" "-" "on"
		__multi_chyves_zfs_property "set" "restrict_new_property_names"          "primary" ".config" "-" "on"
		__multi_chyves_zfs_property "set" "tap_start_offset"                     "primary" ".config" "-" "50"
		__multi_chyves_zfs_property "set" "tap_up_by_default"                    "primary" ".config" "-" "yes"        # net.link.tap.up_on_open
		__multi_chyves_zfs_property "set" "vlan_iface_base_name"                 "primary" ".config" "-" "vlan"
		__multi_chyves_zfs_property "set" "uefi_vnc_port_start_offset"           "primary" ".config" "-" "5900"
		__multi_chyves_zfs_property "set" "check_for_updates"                    "primary" ".config" "-" "weekly"
		__multi_chyves_zfs_property "set" "check_for_updates_timeout_seconds"    "primary" ".config" "-" "2"
		__multi_chyves_zfs_property "set" "check_for_updates_last_check"         "primary" ".config" "-" "$_DATE_YMD"
		__multi_chyves_zfs_property "set" "check_for_updates_last_check_status"  "primary" ".config" "-" "0"
		__multi_chyves_zfs_property "set" "check_for_updates_unique_id"          "primary" ".config" "-" "$_UUID_GENERAL_USE"

		echo "Creating null.iso for UEFI use..."
		touch /tmp/null.iso
		if [ -e /tmp/null.iso ]; then
			echo "importing null.iso into ISO resources..."
			__resource_functions iso import /tmp/null.iso
		fi

		echo "Done setting up primary pool: $pool"
	fi

	# If on FreeNAS do a couple of needed changes.
	if [ "$( __check_if_freenas )" ]; then
		echo "On FreeNAS installation."
		echo "Checking for symbolic link to /chyves from /mnt/chyves..."
		if [ -d /mnt/chyves ]; then
			if [ ! -e /chyves ]; then
				ln -s /mnt/chyves /chyves
				if [ -L /chyves ]; then
					echo "Symbolic link to /chyves from /mnt/chyves successfully created."
				else
					echo "Failed to create symbolic link."
					echo "Please manually do so by running the following as root:"
					echo "# ln -s /mnt/chyves /chyves"
				fi
			elif [ -L /chyves ]; then
				echo "Symbolic link to /chyves already exists."
			fi
		elif [ "$val" = "freenas-boot" ] && [ -d /chyves ]; then
			echo "Symbolic link not needed. /chyves exists."
			echo "chyves is installed on the freenas-boot pool."
			echo "This is not recommended configuration."
		else
			echo "chyves does not seem to be setup."
		fi
	fi
}

# Outputs PCI device string for bhyve command
__get_bhyve_cmd() {
	local devices="$1"
	local pci_slot_count=0
	for device in $devices ; do
		echo "-s $pci_slot_count,$device"
		pci_slot_count=$(( pci_slot_count + 1 ))
	done
}

# Get PCI device config from zfs
__get_zfs_pcidev_conf() {
	local pool="$1"
	local oldifs=$IFS
	#local pci
	IFS=$'\n'
	for pcidev in $(zfs get -H -o property,value all $pool | grep chyves:pcidev: | sort )
	do
		echo $pcidev | cut -f2-
	done
	IFS=$oldifs
}

# List Guests
__list() {
	local output_type="$1"
	local _arg2="$2"         # Used for tap and processes

	# Lists the traditional output
	if [ -z "${output_type}" ]; then

		local pools=$( __get_pool_names )
		(
		printf "%s^%s^%s^%s^%s^%s\n" "Guest" "VMM" "Running" "rcboot" "Pool" "Description"
		for pool in $pools; do
			local guests="$( __get_guests_list - $pool )"
			for g in $guests; do
				local _vmm_status=$( __check_vmm_alocated $g -h  )
				local _bhyve_status=$( __check_bhyve_process_running $g -h )
				local _rcboot_priority=$( __display_rcboot_priority $pool $g )
				local description="$( __multi_chyves_zfs_property "get" "description" "$pool" "guests" "$g" )"
				printf "%s^%s^%s^%s^%s^%s\n" "$g" "$_vmm_status" "$_bhyve_status" "$_rcboot_priority" "$pool" "$description"
			done
		done
		) | column -ts^

	# Dynamically lists the guest chyves properties
	elif [ "${output_type}" = "properties" ]; then
		echo "Use the following syntax to display of list of the guests on the system and a property."
		echo "These are the available properties: "
		__get_property_list
		echo "Run 'chyves list <property>' to see what that property is for each guest."

	# List ISO firmware resources.
	elif [ "${output_type}" = "iso" ]; then
		local pool=$_PRIMARY_POOL
		echo "Listing ISOs..."
		zfs list -H -r $pool/chyves/ISO | cut -f 1 | cut -d '/' -f 4 | sed 1d

	# List Firmware resources. Using "firmware" lists the property firmware rather than the resource
	elif [ "${output_type}" = "firmwares" ]; then
		echo "Listing Firmware..."
		zfs list -H -r $pool/chyves/Firmware | cut -f1 | cut -d '/' -f 4 | sed 1d

	# List snapshots
	elif [ "${output_type}" = "snapshots" ]; then
		echo "Listing snapshots..."
		zfs list -H -t snapshot | grep chyves/guests | grep -v ".defaults" | cut -f1 | cut -d '/' -f4- | sed '/^$/d'

	# List properties set in .config
	elif [ "${output_type}" = ".config" ]; then
		local _pool=$arg2

		echo "Listing properties set in .config"
		[ "$_arg2" = "primary" ] && _pool=$_PRIMARY_POOL

		if [ -n "${_pool}" ]; then
			(
			echo -e "Property:\t Value:"
			zfs get -r -t filesystem -o property,value all $_pool/chyves/.config | grep chyves: | sed -e 's/chyves://g'
			) | column -t
		else
			(
			echo -e "Dataset:\t Property:\t Value:"
			( zfs get -r -t filesystem -o name,property,value all | grep chyves/.config | grep chyves: | sed -e 's/chyves://g' | sed -e 's/\/chyves\/\.config//g' ) | sort -k2
			) | column -t
		fi

	# List pools and roles
	elif [ "${output_type}" = "pools" ]; then
		local _pools=$( __get_pool_names -a )
		(
			printf "%s^%s\n" "Pool:" "Role:"
			for _pool in $_pools; do
				local _dataset_role=$( zfs get -H -o value chyves:dataset_role $_pool/chyves/.config )
				printf "%s^%s\n" "$_pool" "$_dataset_role"
			done
		) | sort -k1 | column -ts^

	# List properties set in .defaults
	elif [ "${output_type}" = ".defaults" ]; then
			echo -e "Properties:\t     defaults:"
			zfs get -r -t filesystem -o property,value all $_PRIMARY_POOL/chyves/guests/.defaults | grep chyves: | sed -e 's/chyves://g' | sort -k1

	# List processes
	elif [ "${output_type}" = "processes" ]; then
		local _guest_name=$_arg2

		echo "Listing processes..."
		if [ -z "$_guest_name" ]; then
			ps -aux | grep -E "chy-|chyves|bhyveload|grub-bhyve" | grep -v -E "grep -E chy-|/bin/sh /usr/local/sbin/chyves list"
		else
			__get_pool_for_guest "$_guest_name"
			ps -aux | grep ${_guest_name} | grep -E -v "grep ${_guest_name}|/bin/sh /usr/local/sbin/chyves list"
		fi

	# List bridges
	elif [ "${output_type}" = "bridges" ]; then
		__get_bridge_list_on_chyves
		local _bridges="$_BRIDGE_list_on_chyves"

		for b in $_bridges
		do
			echo "Bridge: $b"

			# Get outside interface for this bridge
			local _phy=$( __multi_chyves_zfs_property "get" "${b}_phy_attach" "primary" ".config" )
			__verify_valid_iface_format $_phy
			if [ "$_IFACE_type" = "private" ]; then
				echo "       Private network, no outside connectivity."
			else
				echo "       $_IFACE_type interface: "
				echo "             $_phy"
			fi

			# Get taps for this bridge
			__get_tap_list_for_bridge_on_chyves $b
			echo "       taps: "
			for pat in $_TAP_list_for_bridge_on_chyves
			do
			echo "             $pat"
			done
		done
		exit

	# Lists a property for all active guests. See "chyves list properties" for options
	elif [ -n $( __get_property_list | grep "$output_type " ) ]; then

		# Displays active tap via /dev
		if [ "$output_type" = "tap" ] && [ "${_arg2}" = "active" ]; then
			echo "Listing active network taps..."
			ls /dev | grep tap
			exit
		fi

		# Displays singular property
		(
		printf 'Guest\t'$output_type'\n'
		local poollist=$( __get_pool_names -a )
		for pool in $poollist; do
			local guestlist=$( __get_guests_list - $pool )
			for guest in $guestlist; do
				local property="$( zfs get -H -o value chyves:${output_type} $pool/chyves/guests/$guest )"
				printf $guest'\t'$property'\n'
			done
		done
		) | column -t
	fi
}

# Display info about all guests.
__info() {
	local flags="$1"

	if [ "$flags" = "-h" ] || [ -n "$(echo "$flags" | grep 'g' | grep 'i')" ]; then
cat << 'EOT'

    chyves info

Displays information about chyves guests. Without the use of flags, each guest's
name, disks, size, CPU count, RAM allotment, and respective pool are displayed.
The following flags are used in combination to display more fields than the
default. These flags are used in combination meaning the correct syntax is
"-rvs" rather than "-r -v -s". See below for a description of what each flag
does:

 Flags to controls which fields are displayed:
  -r    [role] Display what role the dataset is set to.
  -v    [verbose] Display OS, loader, tap, and console port.
  -s    [status] Display VMM status, if bhyve instance running, and if the
        rcboot is set.
  -t    [template] Displays if guest is a template.
  -d    [description] Dispays description property.
	-n    [notes] Dispays notes property.
  -a    [all] Display all fields above.

 Flags to controls which guests are display or their disks:
  -k    [no-disks] Do not display guests' disks.
  -g    [all-guests] Display all guests (Even offline and templates).
  -i    [inactive] Display only templates and guests on pools with property
        dataset_role set to offline. Incompatiable with the -g flag.

 Miscellaneous flags:
  -h    [help] Display this message.
  -l    [less] Pipes the output to less.

EOT

	# These two flags options are competitive, exit with a warning.
	[ -n "$(echo "$flags" | grep 'g' | grep 'i')" ] && __fault_detected_exit "The -g and -i flags for 'chyves info' are incompatiable. All other flags combinations are fine."

		exit
	fi

	# Poll to see what pools have active guests
	# or the '-g' flag for all guests
	# or the '-i' flag for offline and templates
	if [ -n "$(echo "$flags" | grep 'i')" ]; then
		local pools=$( __get_pool_names -a | grep -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" )
	elif [ -n "$(echo "$flags" | grep -E 'g|a' )" ]; then
		local pools=$( __get_pool_names -a )
	else
		local pools=$( __get_pool_names )
	fi

	( # Begining of very large table of output.
	# Print common header
	printf "%s^%s^%s^%s^%s" "Guest" "Size" "CPU" "RAM" "Pool"

	# Print headers for -r flag
	[ -n "$(echo "$flags" | grep -E 'r|a')" ] && printf "^%s" "Dataset Role"

	# Print headers for -v flag
	[ -n "$(echo "$flags" | grep -E 'v|a')" ] && printf "^%s^%s^%s^%s" "OS" "Loader" "Tap" "Con"

	# Print headers for -s flag
	[ -n "$(echo "$flags" | grep -E 's|a')" ] && printf "^%s^%s^%s" "VMM" "Running" "rcboot"

	# Print headers for -t flag
	[ -n "$(echo "$flags" | grep -E 't|a')" ] && printf "^%s" "Template"

	# Print headers for -d flag
	[ -n "$(echo "$flags" | grep -E 'd|a')" ] && printf "^%s" "Description"

	# Print headers for -n flag
	[ -n "$(echo "$flags" | grep -E 'n|a')" ] && printf "^%s" "Notes"

	# Print new line for first guest.
	printf "\n"

	# Spider through pools
	for pool in $pools; do
		# Poll to see which guests are on $pool
		# This is required for showing inactive guests as __get_guests_list normally omits these guests
		[ -n "$(echo "$flags" | grep -E 'g|i')" ] && local _do_not_omit_inactive=a
		if [ -n "$(echo "$flags" | grep 'k')" ]; then
			local guests="$( __get_guests_list -${_do_not_omit_inactive} $pool )"
		else
			# Default is to display disks.
			local guests="$( __get_guests_list -d${_do_not_omit_inactive} $pool )"
		fi

		local dataset_role=$( zfs get -H -o value chyves:dataset_role $pool/chyves/.config )

		# Spider through guests
		for g in $guests; do

			# Poll variables for size. Use chyves property for guest and volsize for disks.
			if [ -z "$(echo "$g" | grep -E -v 'disk')" ]; then
				local size="$( zfs get -H -o value volsize $pool/chyves/guests/$g )"
			else
				local size="$( zfs get -H -o value usedbychildren $pool/chyves/guests/$g )"
			fi

			# Poll remaining variables for common section
			local cpu="$( __multi_chyves_zfs_property "get" "cpu" "$pool" "guests" "$g" )"
			local ram="$( __multi_chyves_zfs_property "get" "ram" "$pool" "guests" "$g" )"

			# Print common section (guest, size, cpu, raml)
			printf "%s^%s^%s^%s^%s" "$g" "$size" "$cpu" "$ram" "$pool"

			# Print dataset role section
			[ -n "$(echo "$flags" | grep -E 'r|a')" ] && printf "^%s" "$dataset_role"

			# Get variable and print for verbose section (os, loader, tap, con)
			if [ -n "$(echo "$flags" | grep -E 'v|a')" ]; then
				local os="$(zfs get -H -o value chyves:os $pool/chyves/guests/$g)"
				local loader="$(zfs get -H -o value chyves:loader $pool/chyves/guests/$g)"
				local tap="$(zfs get -H -o value chyves:tap $pool/chyves/guests/$g)"
				local con="$(zfs get -H -o value chyves:con $pool/chyves/guests/$g)"

				printf "^%s^%s^%s^%s" "$os" "$loader" "$tap" "$con"
			fi

			# Get information, set variables, and print for status section (VMM, Running, rcboot)
			if [ -n "$(echo "$flags" | grep -E 's|a')" ]; then
				local _vmm_status=$( __check_vmm_alocated $g -h  )
				local _bhyve_status=$( __check_bhyve_process_running $g -h )
				local _rcboot_priority=$( __display_rcboot_priority $pool $g )

				printf "^%s^%s^%s" "$_vmm_status" "$_bhyve_status" "$_rcboot_priority"
			fi

			# Get template information
			if [ -n "$(echo "$flags" | grep -E 't|a')" ]; then
				local template="$(zfs get -H -o value chyves:template $pool/chyves/guests/$g)"
				if [ $template = 'template' ]; then
					template="YES"
				else
					template="NO"
				fi

				printf "^%s" "$template"
			fi

			# Print description if flag set
			if [ -n "$(echo "$flags" | grep -E 'd|a')" ]; then
				local description="$(zfs get -H -o value chyves:description $pool/chyves/guests/$g)"
				printf "^%s" "$description"
			fi

			# Print notes property if flag set
			if [ -n "$(echo "$flags" | grep -E 'n|a')" ]; then
				local notes="$(zfs get -H -o value chyves:notes $pool/chyves/guests/$g)"
				printf "^%s" "$notes"
			fi

			# Print new line for next guest.
			printf "\n"
	  done
	done
	) | column -ts^ | \
	(
		if [ -n "$(echo "$flags" | grep 'l')" ]
		then
			less
		else
			cat
		fi
	)
}

# Handles import, rename, delete, list for Firmware, ISO, and some guests resources
__resource_functions() {
	local _function="$1"
	local _subfunction="$2"
	local _arg3="$3"			# URL|File-Path\File-Name|Firmware-Name
	local _arg4="$4"			# Rename-Name

	# Sets the variable to use to for the resource
	if [ "$_function" = "firmware" ]; then
		local _resource_name="Firmware"
	elif [ "$_function" = "iso" ]; then
		local _resource_name="ISO"
	elif [ "$_function" = "guest" ]; then
		local _resource_name="guests"
	elif [ "$_function" = "disk" ]; then
		local _resource_name="guests/$_arg4/disk$_arg5"
	fi

	# Import ISO and Firmware resources into chyves
	if [ "$_subfunction" = "import" ]; then
		local _URL=$_arg3
		local _file_name="$(basename $_URL)"

		# If file ends with .gz|.xz do not use the extension as the folder name.
		if [ -n "$( echo "$_URL" | grep -E "\.gz$" )" ]; then
			local _folder_name=$(basename $_file_name .gz)
		elif [ -n "$( echo "$_URL" | grep -E "\.xz$" )" ]; then
			local _folder_name=$(basename $_file_name .xz)
		else
			local _folder_name=$_file_name
		fi

		# Check to see if file is on a remote source
		if [ -n "$(echo "$_URL" | grep -E '^http|^ftp')" ]; then
			echo "Creating ZFS dataset: $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name"
			zfs create $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name

			# Remote ISOs are downloaded using fetch and hash checked.
			if [ "$_function" = "iso" ]; then
				echo "Please enter a supported hash checksum for '$_file_name':"
				read -p "Supported cryptographic hash function are (md5|sha1|sha256|sha512|null): " _user_supplied_hash </dev/tty

				echo "Downloading $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/..."
				fetch $_URL -o /chyves/$_resource_name/$_folder_name

				local _hash_length=$( echo $_user_supplied_hash | wc | awk '{ print $3 }' )
				case "$_hash_length" in
					33)     local _calcd_chksum=$( md5 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=MD5
					;;
					41)     local _calcd_chksum=$( sha1 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA1
					;;
					65)     local _calcd_chksum=$( sha256 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA256
					;;
					129)    local _calcd_chksum=$( sha512 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA512
					;;
					*)      local _calcd_chksum=""
					        local _hash_type="Unsupported hash string given. Please contact the chyves developers to have this hash function added."
				esac

				# Check if hash sums match
				if [ -z "$_user_supplied_hash" ]; then
					echo "All that is necessary for the triumph of evil is that good (wo)men do nothing..."
					echo "...like check their downloaded ISO images against a known hash checksum."
					echo "No hash checksum given, good luck with your potentially corrupt or manipulated ISO, you facilitator of evil."
				elif [ "$_calcd_chksum" = "$_user_supplied_hash" ]; then
					echo "$_hash_type hashes matched."
				else
					echo "Hashes did not match for '$_file_name':"
					echo "Supplied hash:            $_user_supplied_hash"
					echo "Reason for hash mismatch: $_hash_type"
					echo "It is recommended to delete '$_file_name', download it again, and supply a supported hash checksum."
					__resource_functions iso delete "$_folder_name"
				fi

			# Downloads remote firmware
			else
				echo "Downloading $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/..."
				fetch $_URL -o /chyves/$_resource_name/$_file_name
			fi

		# Local file copies only.
		else
			echo "Creating ZFS dataset: $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name"
			zfs create $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name
			echo "Copying $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/"
			cp $_URL /chyves/$_resource_name/$_folder_name
		fi

		# Decompress resource if ending in .gz|.xz
		# These programs delete the original files after decompression
		if [ -n "$( echo "$_file_name" | grep -E "\.gz$" )" ]; then
			echo "Decompressing .gz file."
			gunzip -d /chyves/ISO/$_folder_name/$_file_name
			local _file_name="$_folder_name"
		elif [ -n "$( echo "$_file_name" | grep -E "\.xz$" )" ]; then
			echo "Decompressing .xz file."
			xz -d /chyves/ISO/$_folder_name/$_file_name
			local _file_name="$_folder_name"
		fi

		# Checks to see if resource exists now.
		if [ -e /chyves/$_resource_name/$_folder_name/$_file_name ]; then
			echo "$_file_name sucessfully imported as a chyves $_resource_name resource."
		else
			echo "Operation unsucessful: delete the dataset and try again."
			__resource_functions $_function delete "$_folder_name"
		fi

	# Rename guest, ISO, and Firmware resources
	elif [ "$_subfunction" = "rename" ]; then
		# INSERT check to verify dataset is valid  __verify_valid_dataset "$pool" "$_resource_type" "$name"
		# INSERT check to verify target dataset does not exist __verify_valid_dataset "$pool" "$_resource_type" "$name" -n

		read -p "Do you want to rename $_function from '$_arg3' to '$_arg4' [y/N]? " _rename_or_no </dev/tty

		if [ "$_resource_name" = "guests" ]; then
			case "$_rename_or_no" in
				y|Y|yes)   __verify_valid_guest $_arg4
				           __get_pool_for_guest $_arg3
				           zfs rename $_GUEST_pool/chyves/guests/$_arg3 $_GUEST_pool/chyves/guests/$_arg4
				;;
				*)         echo "Guest: '$_arg3' not renamed."
			esac
		else
			local _pool="$_PRIMARY_POOL"
			case "$_rename_or_no" in
				y|Y|yes)   mv -f /chyves/$_resource_name/$_arg3/$_arg3 /chyves/$_resource_name/$_arg3/$_arg4
				           zfs rename $_pool/chyves/$_resource_name/$_arg3 $_pool/chyves/$_resource_name/$_arg4
				;;
				*)         echo "$_resource_name: '$_arg3' not renamed."
			esac
		fi

	# Delete guest, ISO, and Firmware resources
	elif [ "$_subfunction" = "delete" ]; then
		# <INSERT> check to verify dataset is valid  __verify_valid_dataset "$pool" "$_resource_type" "$name"
		read -p "[WARNING] Do you want to delete ${_resource_name}: '$_arg3' [y/N]? " _delete_or_no </dev/tty
		case "$_delete_or_no" in
			y|Y|yes)   zfs destroy -rR $_prim_pool/chyves/$_resource_name/$_arg3
			           exit
			;;
			*) echo "${_resource_name}: '$_arg3' not deleted."
		esac

	# List Firmware resources
	elif [ "$_subfunction" = "list" ] && [ "$_function" = "firmware" ]; then
		__list "firmwares"

	# List ISO resources
	elif [ "$_subfunction" = "list" ] && [ "$_function" = "iso" ]; then
		__list "iso"
	fi
}

# Create guest
__create() {
	local guests="$1"
	local size="$2"
	local pool="$3"
	__load_guest_default_parameters
	local creation_stamp="Created on $( date ) by chyves $_VERSION_LONG using __create()"
	local _disk_options="$( __create_zvol_disk_options_string )"

	# If size not declared in command line, use .default's
	[ -z $size ] && local size="$_GDP_size"

	# Check on pool
	if [ -z "${pool}" ]; then
		local pool="${_PRIMARY_POOL}"
	else
		__verify_valid_pool "$pool" -c
	fi

	# Multi-guest support.
	# Eg.: chyves create guest1,guest2,guest3 8G ssd-pool
	for name in `echo "$guests" | tr ',' ' '`
	do
		__get_next_tap
		__get_next_console
		__get_next_vnc_port
		__verify_valid_guest "$name"
		__set_new_uuid_guest_use

		echo "Creating $name..."
		echo "Creating dataset on $pool"
		zfs create $pool/chyves/guests/$name
		echo "Creating $size disk0 with options: $_disk_options"
		zfs create -V $size $_disk_options $pool/chyves/guests/$name/disk0
		echo "Creating properties:"
		__multi_chyves_zfs_property "set" "bargs"       "$pool" "guests" "$name" "$_GDP_bargs"
		__multi_chyves_zfs_property "set" "cpu"         "$pool" "guests" "$name" "$_GDP_cpu"
		__multi_chyves_zfs_property "set" "fw"          "$pool" "guests" "$name" "$_GDP_fw"
		__multi_chyves_zfs_property "set" "guest_role"  "$pool" "guests" "$name" "$_GDP_guest_role"
		__multi_chyves_zfs_property "set" "loader"      "$pool" "guests" "$name" "$_GDP_loader"
		__multi_chyves_zfs_property "set" "os"          "$pool" "guests" "$name" "$_GDP_os"
		__multi_chyves_zfs_property "set" "persist"     "$pool" "guests" "$name" "$_GDP_persist"
		__multi_chyves_zfs_property "set" "ram"         "$pool" "guests" "$name" "$_GDP_ram"
		__multi_chyves_zfs_property "set" "rcboot"      "$pool" "guests" "$name" "$_GDP_rcboot"

		__multi_chyves_zfs_property "set" "con"         "$pool" "guests" "$name" "$_NEXT_console"
		__multi_chyves_zfs_property "set" "creation"    "$pool" "guests" "$name" "$creation_stamp"
		__multi_chyves_zfs_property "set" "description" "$pool" "guests" "$name" "-"
		__multi_chyves_zfs_property "set" "notes"       "$pool" "guests" "$name" "-"
		__multi_chyves_zfs_property "set" "tap"         "$pool" "guests" "$name" "$_NEXT_tap"
		__multi_chyves_zfs_property "set" "uuid"        "$pool" "guests" "$name" "$_UUID_GUEST_USE"
		__multi_chyves_zfs_property "set" "uefi_console_output"                  "$pool" "guests" "$name" "$_GDP_uefi_console_output"
		__multi_chyves_zfs_property "set" "uefi_mouse_type"                      "$pool" "guests" "$name" "$_GDP_uefi_mouse_type"
		__multi_chyves_zfs_property "set" "uefi_vnc_port"                        "$pool" "guests" "$name" "$_NEXT_vnc_port"
		__multi_chyves_zfs_property "set" "uefi_vnc_ip"                          "$pool" "guests" "$name" "$_GDP_uefi_vnc_ip"
		__multi_chyves_zfs_property "set" "uefi_vnc_res"                         "$pool" "guests" "$name" "$_GDP_uefi_vnc_res"
		__multi_chyves_zfs_property "set" "uefi_pause_until_vnc_client_connect"  "$pool" "guests" "$name" "$_GDP_uefi_vnc_pause"

	done
}

# Install guest
__install() {
	local name="$1"
	local iso="$2"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters $name

	# Check to make sure guest isn't running
	if [ -z "$( __check_bhyve_process_running $name )" ]; then

		echo "Installing $name..."
		# Set install prop
		__multi_chyves_zfs_property "set" "install" "$_GUEST_pool" "guests" "$name" "yes"
		# Load from CD
		__load "$name" "/chyves/ISO/$iso/$iso"
		# Prepare and start guest
		__prepare_guest $name
		_BHYVE_pci="$_BHYVE_pci ahci-cd,/chyves/ISO/$iso/$iso"
		local pci_args=$(__get_bhyve_cmd "$_BHYVE_pci" )
		[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name"
		bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name &
	else
		echo "Guest is already running."
	fi
}

# Load guest
__load() {
	local name="$1"
	local media="$2"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters $name
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	local disk="${_GUEST_pool}/chyves/guests/${name}/disk0"
	local install="$(zfs get -H -o value chyves:install $dataset)"
	local autogrub="$(zfs get -H -o value chyves:autogrub $dataset)"
	# Testing if -S is in the bargs settings. If then pass -S to bhyveload.
	local test_for_wire_memory="-S"
	case $_GP_bargs in
		*${test_for_wire_memory}*) local wire_memory="-S" ;;
		*) local wire_memory="" ;;
	esac
	if [ $_GP_loader = "grub-bhyve" ]; then
		__verify_binary_available "grub-bhyve"
		if [ $install = "yes" ]; then
			if [ $_GP_os = "openbsd59" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 (cd0)/5.9/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "openbsd58" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 (cd0)/5.8/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "openbsd57" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 (cd0)/5.7/amd64/bsd.rd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "netbsd" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'knetbsd -h -r cd0a (cd0)/netbsd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "debian" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r cd0  -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "d8lvm" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "centos6" ] || [ $os = "centos7" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'linux (cd0)/isolinux/vmlinuz\ninitrd (cd0)/isolinux/initrd.img\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "arch" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'linux (cd0)/arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=ARCH_'$(date +%Y%m)' ro\ninitrd (cd0)/arch/boot/x86_64/archiso.img\nboot\n' > $_path/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "gentoo" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'linux (cd0)/isolinux/gentoo root=/dev/ram0 init=/linuxrc  dokeymap looptype=squashfs loop=/image.squashfs  cdroot \ninitrd (cd0)/isolinux/gentoo.igz\nboot\n' > $_path/grub.cfg
				grub-bhyve $wire_memory -m $_path/device.map -r host -d $_path -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "custom" ]; then
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			else
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r cd0 -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			fi
		elif [ $install = "no" ]; then
			if [ $_GP_os = "openbsd59" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "openbsd58" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "openbsd57" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "netbsd" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'knetbsd -h -r wd0a (hd0,msdos1)/netbsd\nboot\n' > ${_GP_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "debian" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "d8lvm" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "centos6" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "centos7" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -d /grub2 -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			elif [ $_GP_os = "custom" ]; then
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r host -d ${_GP_path} -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			else
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_GP_path}/device.map -r hd0,msdos1 -c /dev/${_GP_con}A -M $_GP_ram chy-$name
			fi
		fi
	else
		bhyveload $wire_memory -m $_GP_ram -d $media -c /dev/${_GP_con}A chy-$name
	fi
}

# Boot guest
__boot() {
	local name="$1"
	local runmode="$2"
	local pci="$3"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters $name
	local dataset="${_GUEST_pool}/chyves/guests/${name}"

	# Set install prop
	__multi_chyves_zfs_property "set" "install" "$_GUEST_pool" "guests" "$name" "no"

	# Generate list of bhyve -s commands for all devices
	local pci_args=$( __get_bhyve_cmd "$pci" )

	# Handle the starting of the guest inside a spawned subshell so the guest
	# can be restarted automatically if the guest reboots or crashes
	local runstate="1"
	(
		while [ $runstate = "1" ]
		do
			__load "$name" "/dev/zvol/$dataset/disk0"
			[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name"
			bhyve -c $_GP_cpu $_GP_bargs -U $_GP_uuid -m $_GP_ram $pci_args -lcom1,/dev/${_GP_con}A chy-$name &
			local vmpid=$!
			wait $vmpid
			vmrc=$?
			sleep 5
			if [ $runmode == "0" ]; then
				runstate="0"
			elif [ $vmrc == "1" ] && [ $runmode != 2 ]; then
				# VM has been powered off
				runstate="0"
			else
				if [ "$_GP_persist" != 1 ]; then
					runstate="0"
				fi
			fi
		done
		bhyvectl --destroy --vm=chy-$name
		# Resetting the flag so that a vm which we stopped by abusing zfs set/get
		# as as an IPC mechanism is persistent again next time we start it
		if [ ! -z $_GP_persist ]; then
			zfs set chyves:persist="$persist" $dataset
		fi
	) &
}

__prepare_guest() {
	local name="$1"
	__get_pool_for_guest "$name"

	__generate_bhyve_net_string $name
	_BHYVE_pci="$_BHYVE_net_string"

	# Add disk as second PCI device
	_BHYVE_pci="ahci-hd,/dev/zvol/${_GUEST_pool}/chyves/guests/${name}/disk0 $_BHYVE_pci"
	# Add Hostbridge and lpc as the first PCI devices
	_BHYVE_pci="hostbridge lpc $_BHYVE_pci"
}

# Generate bhyve string for network devices.
__generate_bhyve_net_string() {
	local name="$1"
	__get_pool_for_guest "$name"

	# Setup tap if needed
	local _taps="$( __multi_chyves_zfs_property "get" "tap" "$_GUEST_pool" "guests" "$name" )"
	for _tap in `echo $_taps | tr ',' '\n'`
	do
		[ "$_tap" = "-" ] && continue

		__get_parent_bridge_for_tap_chyves $_tap
		__verify_valid_system_iface $_tap -c
		__network_add_dev_to_bridge $_PARENT_bridge_for_tap_chyves $_tap
		__network_add_phy_to_bridge $_PARENT_bridge_for_tap_chyves

		# Add a virtio-net pci device for the tap
		local _mac="$( __multi_chyves_zfs_property "get" "${_tap}_mac" "$_GUEST_pool" "guests" "$name" )"
		if [ $_mac = "-" ] || [ -z "$_mac" ]; then
			_BHYVE_net_string="$_BHYVE_net_string virtio-net,$_tap"
		else
			_BHYVE_net_string="$_BHYVE_net_string virtio-net,${_tap},mac=${_mac}"
		fi
	done
}

# Start guest (combine load and boot)
__start() {
	local name="$1"
	local flag="$2"
	__get_pool_for_guest "$name"
	__verify_valid_guest "$name" "$_GUEST_pool" -s
	__verify_all_kernel_modules
	__load_guest_parameters $name
	local dataset="$_GUEST_pool/chyves/guests/$name"
	local pci=""
	local runmode="1"

	# Check for special handling.
	if [ "$_CPU_MISSING_UG" ] && [ "$_GP_loader" != "bhyveload" ]; then
	 __get_cpu_section_from_dmesg
	 __fault_detected_exit "Missing CPU feature UG, can only start guests with loader=bhyveload."
	elif [ $_GP_loader = "grub-bhyve" ]; then
		__verify_binary_available "grub-bhyve"
	elif [ $_GP_loader = "uefi" ]; then
		__uefi "$name"
		exit
	fi

	# Check to make sure guest isn't running
	if [ -z "$( __check_bhyve_process_running $name )" ]; then
		case "$flag" in
			-s)  runmode="0"    # single - start only once
			;;
			-a)  runmode="2"    # always - persist regardless what
			;;
			*)   runmode="1"    # persist - persists until guest is powering off
			;;
		esac
		echo "Starting $name..."
		# Prepare and boot guest
		__prepare_guest $name
		__boot "$name" "$runmode" "$_BHYVE_pci"
	fi
}

# Start a UEFI enabled bhyve instance.
# This is experimental, use with caution.
__uefi() {
	local name="$1"
	local media="${2-null.iso}"
	__get_pool_for_guest "$name"
	__verify_all_kernel_modules
	__load_guest_parameters
	[ "${_CPU_MISSING_UG}" ] && __get_cpu_section_from_dmesg && __fault_detected_exit "This CPU lacks the 'UG' feature of EPT. UEFI guests are disabled."
	local dataset="${_GUEST_pool}/chyves/guests/${name}"

	# Create tap if needed
	# check to see if tap is already created before attempting to create new tap interface
	local tapif="$(ifconfig -l | tr ' ' '\n' | grep -F -w $_GP_tap)"
	if [ -z $tapif ]; then
		# create tap interface
		ifconfig $_GP_tap create descr "chyves-$name"
		ifconfig bridge0 addm $_GP_tap
	fi

	# Check if firmware is set for guest
	[ $_GP_fw = '-' ] && __fault_detected_exit "You must set a firmware file property to use UEFI..."

	# Check to make sure guest isn't running
	[ -n "$( __check_bhyve_process_running $name )" ] && __fault_detected_exit "$name is already running."

	# Print the command to start the UEFI guest
	if [ "$_DEVELOPER_MODE" != "off" ]; then
	echo "bhyve -c $_GP_cpu $_GP_bargs -m $_GP_ram "
	echo "        -s 0,hostbridge "
	echo "        -s 3,ahci-cd,/chyves/ISO/$media/$media "
	echo "        -s 4,ahci-hd,/dev/zvol/$dataset/disk0,sectorsize=$_GP_disk0_blocksize "
	echo "        -s 10,virtio-net,$_GP_tap "
	echo "        -s 31,lpc "
	echo "        -l com1,/dev/${_GP_con}A "
	echo "        -l bootrom,/chyves/Firmware/$_GP_fw/$_GP_fw "
	echo "        -U $_GP_uuid "
	echo "        chy-$name"
	fi

	bhyve -c $_GP_cpu $_GP_bargs -m $_GP_ram \
	        -s 0,hostbridge \
	        -s 3,ahci-cd,/chyves/ISO/$media/$media \
	        -s 4,ahci-hd,/dev/zvol/$dataset/disk0,sectorsize=$_GP_disk0_blocksize \
	        -s 10,virtio-net,$_GP_tap \
	        -s 31,lpc \
	        -l com1,/dev/${_GP_con}A \
	        -l bootrom,/chyves/Firmware/$_GP_fw/$_GP_fw \
	        -U $_GP_uuid \
	        chy-$name &
}

# Gracefully stop a guest
__stop() {
	local name="$1"
	__get_pool_for_guest "$name"
	local pid=$(pgrep -fx "bhyve: chy-$name")
	echo "Stopping $name..."
	kill $pid
}

# Force kill -9 everyting matching $name and destroy
# THIS WILL KILL EVERYTHING MATCHING $NAME
__forcekill() {
	local name="$1"
	__get_pool_for_guest "$name"

	# Display current running processes for guest
	__list processes $name | grep -v "/bin/sh /usr/local/sbin/chyves forcekill"

	read -p "[WARNING] Are you sure you want to kill all processes above? [y/N]? " an </dev/tty
	case "$an" in
		y|Y|yes) 	local pids="$(pgrep -f $name)"
			for apid in "$pids"; do
				kill -9 $apid
			done
			bhyvectl --force-poweroff --vm=chy-$name
			bhyvectl --destroy --vm=chy-$name
		;;
		*) echo "No action taken."
	esac
}

# Gracefully shut down all guests via ACPI (Does not destroy)
__scram() {
	echo "Shutting down all guests..."
	local pids="$(pgrep -f chy-)"
	for apid in "$pids"; do
		kill $apid
	done
	wait_for_pids $pids
}

# Destroy guest
__destroy() {
	local name="$1"
	__get_pool_for_guest "$name"
	echo "Destroying $name..."
	bhyvectl --force-poweroff --vm=chy-$name
	bhyvectl --destroy --vm=chy-$name
}

# User interface to set chyves properties
__set() {
	local _config_prop="$2"   # This is script indexed. Only used with .config.
	local _name="$3"          # This is script indexed.
	local _config_pool="$4"   # This is script indexed. Only used with .config when multiple active pools are present.

	[ "$_config_pool" = "primary" ] && local _config_pool="$_PRIMARY_POOL"

	# If more than one active pool then only one .config paramenter can be set at a time.
	if [ "$_name" = ".config" ] && [ "$_NUMBER_OF_ACTIVE_POOLS" -gt 1 ]; then
		local prop="$(echo $_config_prop | cut -d '=' -f1)"
		local val="$(echo $_config_prop | cut -d '=' -f2)"

		# Needed because __verify_number_of_arguments does not catch this.
		if [ -z "$_config_pool" ]; then
			__fault_detected_exit "Need pool to set .config property when multiple active chyves pools are detected."
		else
			__verify_valid_pool "$_config_pool" -c
		fi

		echo "[WARNING] Only able to set one .config property at a time when more than one active pool is present."
		__multi_chyves_zfs_property "set" "$prop" "$_config_pool" ".config" "-" "$val"
		exit
	fi

	# Legacy command syntax support
	if [ -z "$( echo "$2" | grep '=' )" ] && [ -n "$( echo "$3" | grep '=' )" ]; then
		echo "[WARNING] The correct syntax is 'chyves set ${3} ${2}...', correcting syntax for temporary backwards compatibility. This will be deprecated at some point."
	elif [ -n "$( echo "$2" | grep '=' )" ] && [ -n "$( echo "$3" | grep '=' )" ]; then
		__help
		__fault_detected_exit "Incorrect syntax used. See above for correct syntax"
	else
		# Needed to seed first iteration.
		local guests="$_name"
		# Kind of amusing how the new syntax is a little more complicated
	fi

	shift 1   # Keep from setting "set" as a property or using as a guest name.
	for arg in "$@"; do

		# Guest name detector
		if [ -n "$( echo "$arg" | grep -v '=' )" ]; then
			local guests="$arg"

			# Skip remain loop as it is property specific.
			continue
		fi

		# Multi-guest support.
		# Eg.: chyves set cpu=8 guest1,guest2,guest3 ram=512M
		for name in `echo "$guests" | tr ',' ' '`
		do

			[ "$name" = ".config" ] && [ "$_NUMBER_OF_ACTIVE_POOLS" -gt 1 ] && __fault_detected_exit ".config parameters must be set individually when multiple active pool are present. Correct syntax is: 'chyves set param=value .config pool-name'"

			if [ "$name" != "$_lastguest" ]; then
				if [ "$name" = ".config" ]; then
					echo "Switching to setting properties for .config on: $_PRIMARY_POOL"
				else
					echo "Switching to setting properties for guest: $name"
					__get_pool_for_guest "$name"
				fi
			fi

			# Parse property name and desired value from $arg (aka positional parameter)
			local prop="$(echo $arg | cut -d '=' -f1)"
			local val="$(echo $arg | cut -d '=' -f2)"

			# Use function to set ZFS property
			if [ "$name" = ".config" ]; then
				[ "$_NUMBER_OF_ACTIVE_POOLS" -eq 1 ] && __multi_chyves_zfs_property "set" "$prop" "primary" ".config" "-" "$val"
			else
				__multi_chyves_zfs_property "set" "$prop" "$_GUEST_pool" "guests" "$name" "$val"
			fi

			# Used to save some cycles
			local _lastguest=$name
		done
	done
}

# User interface to get chyves properties
__get() {
	local prop="$1"
	local guests="$2"

	# Multi-guest support.
	# Eg.: chyves get cpu guest1,guest2,guest3
	for name in `echo "$guests" | tr ',' ' '`
	do
		__get_pool_for_guest "$name"

		if [ "$prop" = "all" ]; then
			echo "Getting all $name's chyves properties..."
			zfs get -o property,value all ${_GUEST_pool}/chyves/guests/${name} | grep chyves: | sort | sed -e 's/chyves://g'
		else
			echo "Getting $name's property \"$prop\"..."
			__multi_chyves_zfs_property "get" "$prop" "$_GUEST_pool" "guests" "$name"
		fi
	done
}

# Remove a PCIDEV property
__rmpci() {
	local flagone="$1"          # -f | name
	local flagtwo="$2"          # name | pcidev:N
	local flagthree="$3"        # pcidev:N | null
	if [ $flagone = "-f" ]; then
		echo "Removing $flagthree from $flagtwo"
		local pciprop="$(echo "$flagthree" | grep pcidev:)"
		__get_pool_for_guest "$name"
		local dataset="${_GUEST_pool}/chyves/guests/${name}"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r chyves:$flagthree $dataset
		fi
	else
		local pciprop="$(echo "$flagtwo" | grep pcidev:)"
		__get_pool_for_guest "$flagone"
		local dataset="${_GUEST_pool}/chyves/guests/${name}"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo [Y/N]? " an </dev/tty
			case "$an" in
				y|Y) zfs inherit  -r chyves:$flagtwo $dataset
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Add a new disk to guest
__add() {
	local name="$1"
	local size="$2"
	__get_pool_for_guest "$name"
	__load_guest_default_parameters
	local _disk_options=$( __create_zvol_disk_options_string )
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	# Find the last disk number and increment one
	local lastdisk="$(zfs list -H | grep chyves/guests/$name | grep disk | cut -d '/' -f4 | cut -f1 | sort -V | cut -c5- | tail -n1)"
	local newdisk="$(expr $lastdisk + 1)"

	echo "Creating new zvol for $name..."
	zfs create -V $size $_disk_options $_GUEST_pool/chyves/guests/$name/disk$newdisk

	# Find the last pcidev and increment by one
	local lastpci="$(zfs get -H all | grep chyves/guests/$name | grep pcidev | cut -f2 | cut -d ':' -f3 | sort -V | tail -n1)"
	if [ -z $lastpci ]; then
		local newpci='1'
	else
		local newpci="$(expr $lastpci + 1)"
	fi
	zfs set chyves:pcidev:$newpci=ahci-hd,/dev/zvol/$pool/chyves/guests/$name/disk$newdisk $dataset
}

# Remove disk from guest
__remove() {
	local flagone="$1"          # -f | name
	local flagtwo="$2"          # name | diskN
	local flagthree="$3"        # diskN | null
	if [ $flagone = "-f" ]; then
		echo "Removing $flagthree from $flagtwo"
		local pool="$(zfs list -H -o name | grep $flagtwo | grep $flagthree | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagtwo | grep pcidev | grep $flagthree | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r $pciprop $pool/chyves/guests/$flagtwo
			zfs destroy $pool/chyves/guests/$flagtwo/$flagthree
		fi
	else
		local pool="$(zfs list -H -o name | grep $flagone | grep $flagtwo | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagone | grep pcidev | grep $flagtwo | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo from $flagone [Y/N]? " an </dev/tty
			case "$an" in
				y|Y)	zfs inherit  -r $pciprop $pool/chyves/guests/$flagone
					zfs destroy $pool/chyves/guests/$flagone/$flagtwo
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Resize a disk
__resize(){
	local name="$1"
	local disk="$2"
	local size="$3"
	__get_pool_for_guest "$name"
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	# Check if guest exists
	echo "Resizing $disk to $size"
	if [ -d /chyves/$_GUEST_pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running $name )" ]; then
			zfs set volsize=$size $_GUEST_pool/chyves/guests/$name/$disk
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# List disks for a guest
__disks() {
	local name="$1"
	__get_pool_for_guest "$name"
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	(
	echo "Listing disks for $name..."
	printf "diskN\tSize\n"
	zfs list -H -o name,volsize | grep -E "chyves.*$name.*disk" | \
		cut -d '/' -f4
	) | column -t
}

# Snapshot a guest
__snapguest() {
	local fullsnap="$1"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	__get_pool_for_guest "$name"
	echo "Taking snapshot $fullsnap"
	zfs snap -r $_GUEST_pool/chyves/guests/$fullsnap
}

# Rollback guest
__rollguest() {
	local fullsnap="$1"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	__get_pool_for_guest "$name"
	local snap="$(echo $fullsnap | cut -d '@' -f2)"
	local disklist="$(zfs list -H | grep chyves/guests/$name | grep disk | \
				cut -f1 | cut -d '/' -f4-)"
	# Check if guest exists
	echo "Rolling back to $fullsnap"
	if [ -d /chyves/$_GUEST_pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running $name )" ]; then
			zfs rollback -rR $_GUEST_pool/chyves/guests/$fullsnap
			for disk in $disklist ; do
				zfs rollback -rR $_GUEST_pool/chyves/guests/$name/$disk@$snap
			done
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Clone a guest
__cloneguest() {
	local flag="$1"  # Only -r used to replicate, -c is arbitrary
	local name="$2"
	local clones="$3"
	local _dst_pool="$4"
	__get_pool_for_guest
	local _src_pool="$_GUEST_pool"

	# Verify -c or -f flag used.
	if [ "$flag" = "-c" ];then
		echo "Using the cloning method (-c) is not recommended as the UUID, tap interface, and console interface remain the same. Dragons be ahead."
		echo "It is recommended to use the replication method (-r) as these properties are regenerated."
		local _clone_type="(clone-only)"
	elif [ "$flag" = "-r" ]; then
		local _clone_type="(replication)"
	else
		__fault_detected_exit "Invalid flag used \"$flag\", valid flags are \"-c\" or \"-r\". See 'man chyves' for more information."
	fi

	# See if destination pool is declared.
	if [ -z "$_dst_pool" ]; then
		local _dst_pool=$_src_pool
	else
		__verify_valid_pool "$_dst_pool" "-c"
	fi

	echo "Taking $name snapshot on $_src_pool name @chyves-clone-process-$_UUID_GENERAL_USE"
	zfs snap -r $_src_pool/chyves/guests/$name@chyves-clone-process-$_UUID_GENERAL_USE

	# Multi-guest support.
	# Eg.: chyves clone goldenVM devteam1,devteam2,devteam3 dev-pool
	for cname in `echo "$clones" | tr ',' ' '`
	do
		echo "Cloning $name to $cname"
		echo "Verifing $cname is unused."
		__verify_valid_guest "$cname"    # Exits if name in use.

		echo "Using zfs send to send $name to $cname"
		zfs send -R $_src_pool/chyves/guests/$name@chyves-clone-process-$_UUID_GENERAL_USE | zfs recv $_dst_pool/chyves/guests/$cname

		echo "Setting creation stamp on $cname..."
		local creation_stamp="Cloned from $name on $( date ) by chyves $_VERSION_LONG using __cloneguest()"
		__multi_chyves_zfs_property "set" "creation" "$_dst_pool" "guests" "$cname" "$creation_stamp"

		# Future use
		#__multi_chyves_zfs_property "set" "clone"       "$pool" "guests" "$name" "-"
		#__multi_chyves_zfs_property "set" "clone_assc"  "$pool" "guests" "$name" "-"

		# Change con, tap, and UUID properties if -r is used
		if [ "$flag" = "-r" ]; then
			echo "Setting new properties as part of replication..."
			echo "Generating new UUID"
			__set_new_uuid_guest_use
			echo "Grabbing next unused tap interface"
			__get_next_tap
			echo "Grabbing next unused console interface"
			__get_next_console
			__multi_chyves_zfs_property "set" "tap" "$_dst_pool" "guests" "$cname" "$_NEXT_tap"
			__multi_chyves_zfs_property "set" "con" "$_dst_pool" "guests" "$cname" "$_NEXT_console"
			__multi_chyves_zfs_property "set" "uuid" "$_dst_pool" "guests" "$cname" "$_UUID_GUEST_USE"
		fi
		echo "Cloning $_clone_type from $name to $cname complete."
	done

	echo "Deleting snapshot on $_src_pool"
	if [ -z "$_src_pool" ]; then
		__fault_detected_exit "Something went wrong, \$_src_pool variable is empty. Aborting before running zfs destroy command. Please report to the chyves developers."
	else
		zfs destroy -rR $_src_pool/chyves/guests/$name@chyves-clone-process-$_UUID_GENERAL_USE
		if [ "$?" = 0 ]; then
			echo "Sucessfully deleted snapshot for clone."
		else
			echo "Unsuccessfully deleted snapshot on $_src_pool"
			echo "To delete, run this manually: zfs destroy -rR $_src_pool/chyves/guests/$name@chyves-clone-process-$_UUID_GENERAL_USE"
		fi
	fi
	echo "Sucessfully cloned $name to $clones."
}

# Export Guest
__exportguest() {
	local name="$1"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1 | head -n1)"
	local disklist="$(zfs list -H | grep "chyves/guests/$name/disk" | cut -f1 | cut -d '/' -f4-)"
	# Check if guest exists
	echo "Exporting $name. Note this may take some time depending on the size."
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running $name )" ]; then
			# Create /tmp/chyves/guests/$name
			echo "Creating temp directory..."
			mkdir -p /tmp/chyves/guests/$name
			# Export Properties to file
			echo "Exporting properties..."
			zfs get -H -o property,value all $pool/chyves/guests/$name | grep chyves: | sort | \
				sed -e 's/chyves://g' | sed -e 's/	/=/g' > /tmp/chyves/guests/$name/properties.ucl
			# Write disks to file
			echo "Exporting disks..."
			for disk in $disklist ; do
				dd if=/dev/zvol/$pool/chyves/guests/$name/$disk of=/tmp/chyves/guests/$name/${disk}.img bs=1M
			done
			# Compress and add to archive
			echo "Compressing to archive..."
			tar -czf /chyves/guests/$name/$name.tar.gz -C /tmp/chyves/guests/$name/ .
			# Remove /tmp/chyves/
			echo "Removing temp directory..."
			rm -fr /tmp/chyves
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Run console
__console() {
	local name="$1"
	local _flag="$2"
	__get_pool_for_guest "$name"
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	echo "Starting console on $name..."
	echo "~~. to escape console [uses cu(1) for console]"
	cu -l /dev/${con}B -s 9600

}

# Reset all consoles. This kills the cu(1)
__conreset() {
	__list con
	echo "Processes to kill:"
	ps -aux | grep cu
	read -p "[WARNING] Are you sure you want to kill all processes cu console processes above? [y/N]? " an </dev/tty
	case "$an" in
	  y|Y|yes) killall cu
	  ;;
	  *) echo "No action taken."
	esac
}

# Print help page
__help() {
__version
cat << 'EOT'

chyves
  version
  setup <pool>
  list [iso|firmwares|snapshots|.config|.defaults|pools|processes|<property-name>]
  list tap active
  list .config [<pool>|primary]
  list processes [<name>]
  info [-rvstdnakgil|-h]
  iso {list|import|rename|delete} [field1] [field2]
  iso list
  iso import {http-URL|ftp-URL|local-path}
  iso rename <name> <newname>
  iso delete <name>
  firmware {list|import|rename|delete}
  firmware list
  firmware import {http-URL|ftp-URL|local-path}
  firmware rename <name> <newname>
  firmware delete <name>
  create <name> [size] [pool]
  install <name> <iso-file>
  start <name> [-s | -a]
  stop <name>
  forcekill <name>
  scram
  destroy <name>
  rename <name> <newname>
  delete <name>
  set <property1>=<value> {<name>|.defaults|.config} [<property2>=<value>]...
  set <property1>=<value> {<name1>,<name2>,<name3>} [<property2>=<value>]...
  get {<property>|all} <name>
  rmpci [-f] [name] [pcidev:N]
  add [name] [size]
  remove [-f] [name] [diskN]
  resize [name] [diskN] [size]
  disks [name]
  snap <name>[@<snapshotname>]
  roll <name>[@<snapshotname>]
  clone {-c|-r} <name> <clonename> [dest-pool]
  clone {-c|-r} <name> {<clonename1>,<clonename2>,<clonename3>} [dest-pool]
  export <name>
  console <name> [-t]
  conreset
  help

Syntax nomenclature:
 subcommand       - Text without brackets are assumed to be required.
 [optional]       - An optional field
 [optional|list]  - An optional list, valid if not used
 {require|list}   - A require list where one option must be used
 <user-input>     - User supplied input field. Required when not contain in [ ]
 [-abcdefg]       - An optional flag field but must start with a "-" and
                    followed by any combination, in any order. (Eg: "-gca" is
                    valid.)
 name             - chyves guest name

EOT
}

__preflight_check "$1"

__parse_cmd "$@"
