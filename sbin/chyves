#!/bin/sh

_VERSION=0.0.0
_VERSION_LONG="v0.0.0 2016/04/00"
_VERSION_INT="000"
_OLD_VERSION_DATASETS="$(zfs list -H -o chyves:pool_version | grep chyves/.config | grep -v "${_VERSION}" )"
PATH=${PATH}:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin

# See whether given command is readonly
# and therefore doesn't need root credentials
__readonly_cmd () {
    case "$1" in
        help|-h|get|getall|info|list|version) echo "0"
            ;;
        *) echo "1"
            ;;
    esac
}

# Process command line
__parse_cmd () {
  while [ $# -gt 0 ] ; do
    case "$1" in
      version)  __version
                exit
      ;;
      setup)    __setup "$@"
                exit
      ;;
      list)     __list "$2" "$3"
                exit
      ;;
      info)	__info "$2"
            		exit
      ;;
      fetchiso|fetch)    __fetchiso "$@"
                exit
      ;;
      cpiso)	__cpiso "$@"
            		exit
      ;;
      renameiso) __renameiso "$@"
                exit
      ;;
      rmiso) 	__deleteiso "$@"
                exit
      ;;
      fetchfw)	__fetchfw "$@"
                exit
      ;;
      cpfw)	__cpfw "$@"
                exit
      ;;
      renamefw) __renamefw "$@"
                exit
      ;;
      rmfw)	__deletefw "$@"
                exit
      ;;
      create)   __create "$@"
                exit
      ;;
      install)  __install "$@"
                exit
      ;;
      load)     __load "$2" "$3"
                exit
      ;;
      boot)     __boot "$2" "$3" "$4"
                exit
      ;;
      start)    __start "$@"
                exit
      ;;
      uefi)	__uefi "$@"
            		exit
      ;;
      stop)     __stop "$@"
                exit
      ;;
      forcekill) __forcekill "$@"
                exit
      ;;
      scram)    __scram
                exit
      ;;
      destroy)  __destroy "$@"
                exit
      ;;
      rename)   __rename "$@"
                exit
      ;;
      delete)   __delete "$@"
                exit
      ;;
      set)      __set "$@"
                exit
      ;;
      get)      __get "$2" "$3"
                exit
      ;;
      rmpci)	__rmpci "$@"
            		exit
      ;;
      add)	__add "$@"
            		exit
      ;;
      remove)	__remove "$@"
            		exit
      ;;
      resize)   __resize "$@"
                exit
      ;;
      disks)	__disks "$@"
            		exit
      ;;
      snap)	__snapguest "$@"
            		exit
      ;;
      roll)	__rollguest "$@"
            		exit
      ;;
      clone)	__cloneguest "$@"
            		exit
      ;;
      export)	__exportguest "$@"
            		exit
      ;;
      console)  __console "$@"
                exit
      ;;
      conreset) __conreset
                exit
      ;;
      help|-h)  __help
                exit
      ;;
    esac
    shift
  done
}

# Show version
__version() {
	echo "chyves ${_VERSION_LONG}"
}

# Setup chyves
__setup() {
	local args="$@"
	for arg in $args; do
		if [ "${arg}" != "setup" ]; then
			local prop="$(echo $arg | cut -d '=' -f1)"
			local val="$(echo $arg | cut -d '=' -f2)"
			if [ "${prop}" = "pool" ]; then
				local pool="$val"
				local poolexist="$(zfs list -H | grep ${pool}/chyves | head -n1 | cut -c1)"
				if [ -z "${poolexist}" ]; then
					echo "Setting up chyves pool..."
					zfs create $pool/chyves
					zfs create $pool/chyves/guests
					zfs create $pool/chyves/.config
					zfs set chyves:pool_version=${_VERSION} $pool/chyves/.config
					# a chyves pool is already setup, setup secondary pool.
					if [ -d /chyves/ISO ]; then
						echo "Secondary pool set up..."
						zfs set mountpoint="/chyves/$pool" $pool/chyves
						zfs set chyves:dataset_role=secondary $pool/chyves/.config
					# chyves is not set up yet, setup primary pool.
					else
						zfs set mountpoint="/chyves" $pool/chyves
						zfs create $pool/chyves/ISO
						zfs create $pool/chyves/Firmware
						echo "Setting up .defaults dataset and properties on primary pool..."
						zfs create $pool/chyves/guests/.defaults
						zfs set chyves:size=8G $pool/chyves/guests/.defaults
						zfs set chyves:cpu=1 $pool/chyves/guests/.defaults
						zfs set chyves:ram=256M $pool/chyves/guests/.defaults
						zfs set chyves:persist=1 $pool/chyves/guests/.defaults
						zfs set chyves:boot=0 $pool/chyves/guests/.defaults
						zfs set chyves:loader=bhyveload $pool/chyves/guests/.defaults
						zfs set chyves:os=default $pool/chyves/guests/.defaults
						zfs set chyves:bargs=-A_-H_-P $pool/chyves/guests/.defaults
						echo "Setting up .config properties on primary pool..."
						zfs set chyves:dataset_role=primary $pool/chyves/.config
					fi
				else
					echo "chyves already exists on $pool"
				fi
				# Checks to see if on FreeNAS
				# The web UI references this file to display the version
				if [ -e /etc/version ]; then
					local OS=$( cat /etc/version | cut -d - -f1 )
					if [ "$OS" = "FreeNAS" ]; then
						echo "On FreeNAS installation."
						echo "Checking for symbolic link to /chyves from /mnt/chyves..."
						if [ -d /mnt/chyves ]; then
							if [ ! -e /chyves ]; then
								ln -s /mnt/chyves /chyves
								if [ -L /chyves ]; then
									echo "Symbolic link to /chyves from /mnt/chyves successfully created."
								else
									echo "Failed to create symbolic link."
									echo "Please manually do so by running the following as root:"
									echo "# ln -s /mnt/chyves /chyves"
								fi
							elif [ -L /chyves ]; then
								echo "Symbolic link to /chyves already exists."
							fi
						elif [ "$val" = "freenas-boot" ] && [ -d /chyves ]; then
							echo "Symbolic link not needed. /chyves exists."
							echo "chyves is installed on the freenas-boot pool."
							echo "This is not recommended configuration."
						else
							echo "chyves does not seem to be setup."
						fi
					fi
				fi
			elif [ "${prop}" = "kmod" ]; then
				if [ "${val}" = "1" ]; then
					echo "Loading kernel modules..."
					kldload vmm
					kldload nmdm
					kldload if_tap
					kldload bridgestp
					kldload if_bridge
				elif [ "${val}" = "0" ]; then
					echo "Unloading kernel modules..."
					kldunload vmm
					kldunload nmdm
				else
					echo "Improper syntax"
					echo "kmod=1 to load modules"
					echo "kmod=0 to unload modules"
				fi
			elif [ "${prop}" = "net" ]; then
				local bridgeif="$('ifconfig' -l | grep -F "bridge0 " | cut -c1)"
				if [ -z "${bridgeif}" ]; then
					echo "Seting up bridge0 on $val..."
					sysctl net.link.tap.up_on_open=1
					ifconfig bridge0 create descr "chyves-bridge"
					ifconfig bridge0 addm $val
					ifconfig bridge0 up
				else
					echo "bridge0 is already enabled on this machine..."
					local sysctlexist="$(sysctl net.link.tap.up_on_open | grep 1 | cut -c1)"
					if [ -z "${sysctlexist}" ]; then
						echo "Setting up correct sysctl value..."
						sysctl net.link.tap.up_on_open=1
					else
						echo "sysctl already setup properly as well..."
					fi
				fi
			fi
		fi
	done
}

__get_bhyve_cmd() {
	local devices="$1"
	local pci_slot_count=0
	for device in $devices ; do
		echo "-s $pci_slot_count,$device"
		pci_slot_count=$(( pci_slot_count + 1 ))
	done
}

# Get PCI device config from zfs
__get_zfs_pcidev_conf() {
	local pool="$1"
	local oldifs=$IFS
	#local pci
	IFS=$'\n'
	for pcidev in $(zfs get -H -o property,value all $pool | grep chyves:pcidev: | sort )
	do
		echo $pcidev | cut -f2-
	done
	IFS=$oldifs
}

# List Guests
__list() {
  local output_type="$1"
  local active_taps="$2" # Only used for tap

  if [ -z $1 ]; then
    # Traditional `chyves list` true when null
    local output_type="trad"
  fi

 # Traditional output of list
  __ls_trad() {
    local pools="$(zfs list -H | grep chyves | cut -d '/' -f 1 | uniq )"
    (
    printf "%s^%s^%s^%s^%s^%s\n" "Guest" "VMM" "Running" "rcboot" "Pool" "Description"
    for pool in $pools; do
      local guests="$(zfs list -H -o name | grep -i ^$pool/chyves/guests | grep -v .defaults | cut -d'/' -f4 | sed 1d | uniq)"
      for g in $guests; do
        local vmm="/dev/vmm/chy-$g"
        if [ -e $vmm ]; then
          vmm="YES"
        else
          vmm="NO"
        fi
        local running=$(pgrep -fx "bhyve: chy-$g")
        if [ -z $running ]; then
          running="NO"
        else
          running="YES"
        fi
        local boot="$(zfs get -H -o value chyves:boot $pool/chyves/guests/$g)"
        if [ $boot = '1' ]; then
          boot="YES"
        else
          boot="NO"
        fi
        local description="$(zfs get -H -o value chyves:description $pool/chyves/guests/$g)"
        printf "%s^%s^%s^%s^%s^%s\n" "$g" "$vmm" "$running" "$boot" "$pool" "$description"
      done
    done
    ) | column -ts^
  }

  # List iso
  __ls_iso() {
  	echo "Listing ISOs..."
  	zfs list -H | grep chyves/ISO | cut -f 1 | cut -d '/' -f 5 | sed 1d
  }

  # List Firmware
  __ls_firmware() {
    echo "Listing Firmware..."
    zfs list -H | grep chyves/Firmware | cut -f1 | cut -d '/' -f 5 | sed 1d
  }

  # List all the snapshots
  __ls_snapshots() {
    zfs list -H -t snapshot | grep chyves | grep -v disk | cut -f1 | cut -d '/' -f4
  }

  # List taps in use
  __ls_tap() {
    local active_taps="$1"
    if [ -z "${active_taps}" ]; then
      local guestlist="$(zfs list -H -o name -t volume | grep chyves | cut -d'/' -f1-4)"
      echo "Listing all network taps:"
      for i in $guestlist ; do
        conprop="$(zfs get -H -o value chyves:tap $i)"
        printf $i'......'$conprop'\n'
      done
    elif [ "${active_taps}" = "active" ]; then
      echo "Listing active network taps..."
      ls /dev | grep tap
    else
      echo "$active_taps is an unknown argument."
    fi
  }

  # List consoles in use
  __ls_con() {
    local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
    local guestlist="$(zfs list -H | grep chyves/guests | sed 1d | cut -f1 | cut -d '/' -f4 | uniq)"
    (
    printf 'Guest\tConsole\n'
    for guest in $guestlist; do
      local con="$(zfs get -H -o value chyves:con $pool/chyves/guests/$guest)"
      printf $guest'\t'$con'\n'
    done
    ) | column -t
  }

  case "$output_type" in
    trad)     __ls_trad
              exit
    ;;
    iso)      __ls_iso
              exit
    ;;
    firm|firmware|fw)    __ls_firmware
              exit
    ;;
    snap|snapshots)    __ls_snapshots
              exit
    ;;
    tap)      __ls_tap "$2"
              exit
    ;;
    con)      __ls_con
              exit
    ;;
  esac

}

# Display info about all guests.
__info() {
  local flags="$1"

	# Poll to see what pools have active guests
	local pools="$(zfs list -H -o name | grep chyves | cut -d '/' -f 1 | uniq )"

	( # Begining of very large table of output.
	# Print common header
	printf "%s^%s^%s^%s^%s" "Guest" "Size" "CPU" "RAM" "Pool"

	# Print headers for -v flag
	if [ -n "$(echo "$flags" | grep 'v')" ]; then
		printf "^%s^%s^%s^%s" "OS" "Loader" "Tap" "Con"
	fi

	# Print headers for -s flag
	if [ -n "$(echo "$flags" | grep 's')" ]; then
		printf "^%s^%s^%s" "VMM?" "Running" "rcboot?"
	fi

	# Print headers for -d flag
	if [ -n "$(echo "$flags" | grep 'd')" ]; then
		printf "^%s" "Description"
	fi

	# Print new line for first guest.
	printf "\n"

	# Spider through pools
	for pool in $pools; do
	    # Poll to see which guests are on $pool
	    local guests="$(zfs list -H -o name | grep -i ^$pool/chyves/guests | grep -v .defaults | cut -d'/' -f4- | sed 1d | uniq)"         
 	    # Spider through guests
            for g in $guests; do

		# Poll variables for common section
		local size="$(zfs get -H -o value volsize $pool/chyves/guests/$g)"
		local cpu="$(zfs get -H -o value chyves:cpu $pool/chyves/guests/$g)"
		local ram="$(zfs get -H -o value chyves:ram $pool/chyves/guests/$g)"

		# Print common section (guest, size, cpu, raml)
		printf "%s^%s^%s^%s^%s" "$g" "$size" "$cpu" "$ram" "$pool"

		# Get variable and print for verbose section (os, loader, tap, con)
		if [ -n "$(echo "$flags" | grep 'v')" ]; then
			local os="$(zfs get -H -o value chyves:os $pool/chyves/guests/$g)"
			local loader="$(zfs get -H -o value chyves:loader $pool/chyves/guests/$g)"
			local tap="$(zfs get -H -o value chyves:tap $pool/chyves/guests/$g)"
			local con="$(zfs get -H -o value chyves:con $pool/chyves/guests/$g)"

			printf "^%s^%s^%s^%s" "$os" "$loader" "$tap" "$con"
		fi

		# Get info, set variables, and print for status section (VMM, Running, rcboot)
		if [ -n "$(echo "$flags" | grep 's')" ] && [ -z "$(echo "$g" | grep 'disk')" ]; then
			local vmm="/dev/vmm/chy-$g"
			if [ -e $vmm ]; then
				vmm="YES"
			else
				vmm="NO"
			fi
			local running=$(pgrep -fx "bhyve: chy-$g")
			if [ -z $running ]; then
				running="NO"
			else
				running="YES"
			fi
			local boot="$(zfs get -H -o value chyves:boot $pool/chyves/guests/$g)"
			if [ $boot = '1' ]; then
				boot="YES"
			else
				boot="NO"
			fi

			printf "^%s^%s^%s" "$vmm" "$running" "$boot"
		# Checks to see if disk portion of guest and uses "-"s if so for this section.
		elif [ -n "$(echo "$flags" | grep 's')" ] && [ -n "$(echo "$g" | grep 'disk')" ]; then
			printf "^-^-^-"
		fi

		# Print description if flag set
		if [ -n "$(echo "$flags" | grep 'd')" ]; then
			local description="$(zfs get -H -o value chyves:description $pool/chyves/guests/$g)"
			printf "^%s" "$description"
		fi

		# Print new line for next guest.
		printf "\n"
            done
	done
	) | column -ts^ | \
	(
		if [ -n "$(echo "$flags" | grep 'l')" ]
		then
			less
		else
			cat
		fi
	)
}

# Fetch ISO
__fetchiso() {
	local url="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	local name="$(basename $2)"
	echo "Fetching $url..."
	zfs create $pool/chyves/ISO/$name
	fetch $url -o /chyves/ISO/$name
}

# Copy ISO from local machine
__cpiso() {
	local loc="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	local name="$(basename $loc)"
	echo "Copying $name from $loc..."
	zfs create $pool/chyves/ISO/$name
	cp $loc /chyves/ISO/$name
}

# Rename an ISO
__renameiso() {
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	local iso="$2"
	local name="$3"
	echo "Renaming ISO $2 to $3..."
	mv /chyves/ISO/$iso/$iso /chyves/ISO/$iso/$name
	zfs rename $pool/chyves/ISO/$iso $pool/chyves/ISO/$name
}

# Delete ISO
__deleteiso() {
	local name="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	echo "Deleting $name..."
	zfs destroy -rR $pool/chyves/ISO/$name
}

# Fetch Firmware
__fetchfw() {
	local url="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	local name="$(basename $2)"
	echo "Fetching $url..."
	zfs create $pool/chyves/Firmware/$name
	fetch $url -o /chyves/Firmware/$name
}

# Copy Firmware from local machine
__cpfw() {
	local loc="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	local name="$(basename $loc)"
	echo "Copying $name from $loc..."
	zfs create $pool/chyves/Firmware/$name
	cp $loc /chyves/Firmware/$name
}

# Rename Firmware
__renamefw() {
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	local fw="$2"
	local name="$3"
	echo "Renaming Firmware $2 to $3..."
	mv /chyves/Firmware/$fw/$fw /chyves/Firmware/$fw/$name
	zfs rename $pool/chyves/Firmware/$fw $pool/chyves/Firmware/$name
}

# Delete Firmware
__deletefw() {
	local name="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	echo "Deleting $name..."
	zfs destroy -rR $pool/chyves/Firmware/$name
}

# Create guest
__create() {
	local name="$2"
	local size="$3"
	local pool="$4"
	local uuid="$(/bin/uuidgen)"
	local description="$(date)"
	# Gets primary pool
	local prim_pool="$(zfs get -r chyves:dataset_role | grep "primary" | cut -d'/' -f1)"

	# If [pool] not set use primary pool
	if [ -z "${pool}" ]; then
		local pool="${prim_pool}"
	fi

	# Get default values as set by .defaults on primary pool
	local def_size="$(zfs get -H -o value chyves:size $prim_pool/chyves/guests/.defaults)"
	local def_cpu="$(zfs get -H -o value chyves:cpu $prim_pool/chyves/guests/.defaults)"
	local def_ram="$(zfs get -H -o value chyves:ram $prim_pool/chyves/guests/.defaults)"
	local def_persist="$(zfs get -H -o value chyves:persist $prim_pool/chyves/guests/.defaults)"
	local def_boot="$(zfs get -H -o value chyves:boot $prim_pool/chyves/guests/.defaults)"
	local def_loader="$(zfs get -H -o value chyves:loader $prim_pool/chyves/guests/.defaults)"
	local def_os="$(zfs get -H -o value chyves:os $prim_pool/chyves/guests/.defaults)"
	local def_bargs="$(zfs get -H -o value chyves:bargs $prim_pool/chyves/guests/.defaults)"
	# If size not declared in command line, use .default's
	if [ -z $size ]; then
	  local size="$def_size"
	fi
	# Get list of guests to help set con and tap number

# Set chyves specific parameters
  # Get list of guests to help set con and tap number
  local taplast="$(zfs get -H -o value chyves:tap | grep -v - | sort -V | tail -n1 | cut -c 4-)"
  if [ -z $taplast ]; then
    local tap='0'
  else
    local tap="$(expr $taplast + 1)"
  fi
  local conlast="$(zfs get -H -o value chyves:con | grep -v - | sort -V | tail -n1 | cut -c 5-)"
  if [ -z $conlast ]; then
    local con='0'
  else
    local con="$(expr $conlast + 1)"
  fi

	echo "Creating $name..."
	zfs create $pool/chyves/guests/$name
	zfs create -V $size -o volmode=dev $pool/chyves/guests/$name/disk0
	zfs set chyves:name=$name $pool/chyves/guests/$name
	zfs set chyves:size=$size $pool/chyves/guests/$name
	zfs set chyves:ram=$def_ram $pool/chyves/guests/$name
	zfs set chyves:cpu=$def_cpu $pool/chyves/guests/$name
	zfs set chyves:tap=tap$tap $pool/chyves/guests/$name
	zfs set chyves:con=nmdm$con $pool/chyves/guests/$name
	zfs set chyves:persist=$def_persist $pool/chyves/guests/$name
	zfs set chyves:boot=$def_boot $pool/chyves/guests/$name
	zfs set chyves:loader=$def_loader $pool/chyves/guests/$name
	zfs set chyves:os=$def_os $pool/chyves/guests/$name
	zfs set chyves:description="$description" $pool/chyves/guests/$name
	zfs set chyves:bargs=$def_bargs $pool/chyves/guests/$name
	zfs set chyves:uuid=$uuid $pool/chyves/guests/$name
}

# Install guest
__install() {
	local name="$2"
	local iso="$3"
	local pool="$(zfs list -H -t volume -o name | grep chyves/guests/$name | grep disk0 | cut -d '/' -f1)"
	local dataset="$(zfs list -H -t volume | grep chyves/guests/$name | cut -d '/' -f 1-3 | head -n1)"
	# Check if guest exists
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: chy-$name")
		if [ -z $running ]; then
			local ram="$(zfs get -H -o value chyves:ram $dataset)"
			local con="$(zfs get -H -o value chyves:con $dataset)"
			local cpu="$(zfs get -H -o value chyves:cpu $dataset)"
      local uuid="$(zfs get -H -o value chyves:uuid $dataset)"
			local bargexist="$(zfs get -H -o value chyves:bargs $dataset)"
			local bargs="$(echo $bargexist | sed -e 's/_/ /g')"
			echo "Installing $name..."
			# Set install prop
			zfs set chyves:install=yes $pool/chyves/guests/$name
			# Load from CD
			__load "$name" "/chyves/ISO/$iso/$iso"
			# Prepare and start guest
			pci="$(__prepare_guest $name) ahci-cd,/chyves/ISO/$iso/$iso"
			local pci_args=$(__get_bhyve_cmd "$pci" )
			bhyve -c $cpu $bargs -U $uuid -m $ram $pci_args -lcom1,/dev/${con}A chy-$name &
		else
			echo "Guest is already running."
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Load guest
__load() {
	local name="$1"
	local media="$2"
	local disk="${3-$(zfs list -H -t volume -o name | grep chyves/guests/$name | grep disk0 | head -n1)}"
	local dataset="$(zfs list -H -t volume -o name | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1-3 | head -n1)"
	local ram="$(zfs get -H -o value chyves:ram $dataset)"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	local loader="$(zfs get -H -o value chyves:loader $dataset)"
	local install="$(zfs get -H -o value chyves:install $dataset)"
	local os="$(zfs get -H -o value chyves:os $dataset)"
	local autogrub="$(zfs get -H -o value chyves:autogrub $dataset)"
	local bargexist="$(zfs get -H -o value chyves:bargs $dataset)"
	local bargs="$(echo $bargexist | sed -e 's/_/ /g')"
	#Testing if -S is in the bargs settings. If then pass -S to bhyveload.
	local test_for_wire_memory="-S"
	case $bargs in
		*${test_for_wire_memory}*) local wire_memory="-S" ;;
		*) local wire_memory="" ;;
	esac
	if [ $loader = "grub-bhyve" ]; then
		if [ $install = "yes" ]; then
			if [ $os = "openbsd59" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'kopenbsd -h com0 (cd0)/5.9/amd64/bsd.rd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd58" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'kopenbsd -h com0 (cd0)/5.8/amd64/bsd.rd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd57" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'kopenbsd -h com0 (cd0)/5.7/amd64/bsd.rd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "netbsd" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'knetbsd -h -r cd0a (cd0)/netbsd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "debian" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r cd0  -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "d8lvm" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r cd0 -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "centos6" ] || [ $os = "centos7" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'linux (cd0)/isolinux/vmlinuz\ninitrd (cd0)/isolinux/initrd.img\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "arch" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'linux (cd0)/arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=ARCH_'$(date +%Y%m)' ro\ninitrd (cd0)/arch/boot/x86_64/archiso.img\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "custom" ]; then
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			else
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r cd0 -c /dev/${con}A -M $ram chy-$name
			fi
		elif [ $install = "no" ]; then
			if [ $os = "openbsd59" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd58" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd57" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "netbsd" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				printf 'knetbsd -h -r wd0a (hd0,msdos1)/netbsd\nboot\n' > /chyves/guests/$name/grub.cfg
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "debian" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r hd0,msdos1 -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "d8lvm" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r hd0,msdos1 -d /grub -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "centos6" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r hd0,msdos1 -d /grub -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "centos7" ]; then
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r hd0,msdos1 -d /grub2 -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "custom" ]; then
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r host -d /chyves/guests/$name -c /dev/${con}A -M $ram chy-$name
			else
				printf '\(hd0\)\ /dev/zvol/'$disk'\n' > /chyves/guests/$name/device.map
				printf '\(cd0\)\ '$media'\n' >> /chyves/guests/$name/device.map
				grub-bhyve $wire_memory -m /chyves/guests/$name/device.map -r hd0,msdos1 -c /dev/${con}A -M $ram chy-$name
			fi
		fi
	else
		bhyveload $wire_memory -m $ram -d $media -c /dev/${con}A chy-$name
	fi
}

# Boot guest
__boot() {
	local name="$1"
	# runmode (runonce/persist)
	#   0 = once
	#   1 = persist regular (stop if guest is powering off)
	#   2 = always persist (start again even if guest is powering off)
	local runmode="$2"
	local pci="$3"
	local dataset="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1-3 | head -n1)"
	local ram="$(zfs get -H -o value chyves:ram $dataset)"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	local cpu="$(zfs get -H -o value chyves:cpu $dataset)"
  local uuid="$(zfs get -H -o value chyves:uuid $dataset)"
	local persist="$(zfs get -H -o value chyves:persist $dataset)"
	local bargexist="$(zfs get -H -o value chyves:bargs $dataset)"
	local bargs="$(echo $bargexist | sed -e 's/_/ /g')"
	# Set install prop
	zfs set chyves:install=no $dataset
	# Generate list of bhyve -s commands for all devices
	local pci_args=$(__get_bhyve_cmd "$pci" )
	# Handle the starting of the guest inside a spawned subshell so the guest
	# can be restarted automatically if the guest reboots or crashes
	local runstate="1"
	(
		while [ $runstate = "1" ]
		do
			__load "$name" "/dev/zvol/$dataset/disk0"
			bhyve -c $cpu $bargs -U $uuid -m $ram $pci_args -lcom1,/dev/${con}A chy-$name &
			local vmpid=$!
			wait $vmpid
			vmrc=$?
			sleep 5
			if [ $runmode == "0" ]; then
				runstate="0"
			elif [ $vmrc == "1" ] && [ $runmode != 2 ]; then
				# VM has been powered off
				runstate="0"
			else
				if [ $(zfs get -H -o value chyves:persist $dataset) != 1 ]; then
					runstate="0"
				fi
			fi
		done
		bhyvectl --destroy --vm=chy-$name
		# Resetting the flag so that a vm which we stopped by abusing zfs set/get
		# as as an IPC mechanism is persistent again next time we start it
		if [ ! -z $persist ]; then
			zfs set chyves:persist="$persist" $dataset
		fi
	) &
}

__prepare_guest() {
	local name="$1"
	local dataset="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1-3 | head -n1)"
	local pci="$(__get_zfs_pcidev_conf $dataset)"
	# Setup tap if needed
	local listtap="$(zfs get -H -o value chyves:tap $dataset)"
	for tap in $(echo $listtap | sed -n 1'p' | tr ',' '\n'); do
		if [ $tap ] && [ $tap != "-" ]; then
			local tapif="$(ifconfig -l | tr ' ' '\n' | grep -F -w $tap)"
			if [ -z $tapif ]; then
				# create tap interface
				ifconfig $tap create descr "chyves-$name"
				ifconfig bridge0 addm $tap
			fi
			# Add a virtio-net pci device for the tap
			local mac="$(zfs get -H -o value chyves:mac_$tap $dataset)"
			if [ $mac = "-" ]; then
				pci="$pci virtio-net,$tap"
			else
				pci="$pci virtio-net,${tap},mac=${mac}"
			fi
		fi
        done
	#Add disk as second PCI device
	pci="ahci-hd,/dev/zvol/$dataset/disk0 $pci"
	#Add Hostbridge and lpc as the first PCI devices
	pci="hostbridge lpc $pci"
	# return the list of pci devices
	echo $pci
}

# Start guest (combine load and boot)
__start() {
	local name="$2"
	local flag="$3"
	local pci=""
	local runmode="1"
	local pool="$(zfs list -H -t volume -o name | grep chyves/guests/$name| grep disk0 | cut -d '/' -f1)"
	local dataset="$(zfs list -H -t volume -o name | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1-3 | head -n1)"
	local loader="$(zfs get -H -o value chyves:loader $dataset)"
	# Check if loader is UEFI
	if [ $loader = "uefi" ]; then
		__uefi "$name" "null.iso"
	fi
	# Check if guest exists
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: chy-$name")
		if [ -z $running ]; then
			case "$flag" in
				-s)	runmode="0"	# single - start only once
					;;
				-a) 	runmode="2"	# always - persist regardless what
					;;
				*)	runmode="1"	# persist - persists until guest is powering off
					;;
			esac
			echo "Starting $name... (Takes 15 seconds for FreeBSD guests)"
			# Prepare and boot guest
			pci="$(__prepare_guest $name)"
			__boot "$name" "$runmode" "$pci"
		else
			echo "Guest is already running."
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Start a UEFI enabled bhyve instance.
# This is experimental, use with caution.
__uefi() {
	local name="$2"
	local media="$3"
	local dataset="$(zfs list -H -t volume | grep chyves/guests/$name | cut -d '/' -f 1-3 | head -n1)"
	local ram="$(zfs get -H -o value chyves:ram $dataset)"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	local cpu="$(zfs get -H -o value chyves:cpu $dataset)"
	local fw="$(zfs get -H -o value chyves:fw $dataset)"
	local tap="$(zfs get -H -o value chyves:tap $dataset)"
  local uuid="$(zfs get -H -o value chyves:uuid $dataset)"
	local bargs="$(zfs get -H -o value chyves:bargs $dataset | sed -e 's/_/ /g')"
	local pool="$(zfs list -H -t volume -o name | grep chyves/guests/$name | cut -d '/' -f1)"
	# Create tap if needed
	# check to see if tap is already created before attempting to create new tap interface
	local tapif="$(ifconfig -l | tr ' ' '\n' | grep -F -w $tap)"
	if [ -z $tapif ]; then
		# create tap interface
		ifconfig $tap create descr "chyves-$name"
		ifconfig bridge0 addm $tap
	fi
	# Make sure everything is in order...
	if [ $fw = '-' ]; then
		echo "You must set a firmware file property to use UEFI..."
	fi
	if [ -z $media ]; then
		echo "You must enter at least a zero byte ISO for some OSs..."
		echo "EX: chyves uefi winguest null.iso"
	fi
	# Check if guest exists
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: chy-$name")
		if [ -z $running ]; then
			# The good stuff...
			bhyve -c $cpu $bargs -m $ram \
			        -s 0,hostbridge \
			        -s 3,ahci-cd,/chyves/ISO/$media/$media \
			        -s 4,ahci-hd,/dev/zvol/$dataset/disk0,sectorsize=512 \
			        -s 10,virtio-net,$tap \
			        -s 31,lpc \
			        -l com1,/dev/${con}A \
			        -l bootrom,/chyves/Firmware/$fw/$fw \
              -U $uuid \
			        chy-$name &
		else
			echo "Guest is already running."
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Gracefully stop a guest
__stop() {
	local name="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	local pid=$(pgrep -fx "bhyve: chy-$name")
	echo "Stopping $name..."
#	zfs set chyves:persist=0 $pool/chyves/guests/$name
	kill $pid
#	sleep 20
#	bhyvectl --destroy --vm=chy-$name
}

# Force kill -9 everyting matching $name and destroy
# THIS WILL KILL EVERYTHING MATCHING $NAME
__forcekill() {
	local name="$2"
	local pids="$(pgrep -f $name)"
	for apid in "$pids"; do
		kill -9 $apid
	done
	bhyvectl --destroy --vm=chy-$name
}

# Gracefully shut down all guests via ACPI (Does not destroy)
__scram() {
	echo "Shutting down all guests..."
	local pids="$(pgrep -f chy-)"
	for apid in "$pids"; do
		kill $apid
	done
	wait_for_pids $pids
}

# Destroy guest
__destroy() {
	local name="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	echo "Destroying $name..."
#	zfs set chyves:persist=0 $pool/chyves/guests/$name
	bhyvectl --force-poweroff --vm=chy-$name
	bhyvectl --destroy --vm=chy-$name
}

# Rename the guest
__rename() {
	local name="$2"
	local newname="$3"
	if [ "$name" = "$newname" ]; then
		echo "Can not rename guest to itself ($name). Exitting."
		exit
	fi
	local pool="$(zfs list -H -t volume | grep "chyves/guests/$name" | cut -d '/' -f 1 | head -n1)"
	echo "Renaming $name to $newname..."
	zfs rename -f $pool/chyves/guests/$name $pool/chyves/guests/$newname
	zfs set chyves:name=$newname $pool/chyves/guests/$newname
}

# Delete guest
__delete() {
	local flagone="$2"
	local flagtwo="$3"
	if [ $flagone = "-f" ]; then
		local target_dataset="$(zfs list -H -t filesystem -o name | grep chyves | grep $flagtwo | head -n1)"
		echo ""
		echo "[WARNING] Forcing permanent deletion of $flagtwo"
		echo "Location: $target_dataset including children and clones"
		echo ""
		echo "Hit Ctrl+C in the next 10 seconds to cancel..."
		sleep 10
		echo "Deleting $flagtwo at $target_dataset..."
		zfs destroy -rR $target_dataset
	else
		local target_dataset="$(zfs list -H -t filesystem -o name | grep chyves | grep $flagone | head -n1)"
		echo ""
		echo "[WARNING] Are you sure you want to permanently delete $flagone and all child datasets?"
		read -p "Location: $target_dataset [Y/N]? " an </dev/tty
		case "$an" in
			y|Y) echo "Deleting $flagone at $target_dataset..."; zfs destroy -r $target_dataset
 			;;
			*) echo "$flagone not deleted..."
		esac
	fi
}

# Set ZFS properties
__set() {
	local name="$2"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | cut -d '/' -f 1 | head -n1)"
	shift 2
	for arg in "$@"; do
		local prop="$(echo $arg | cut -d '=' -f1)"
		local val="$(echo $arg | cut -d '=' -f2)"
		if [ $prop = "bargs" ]; then
			local sval="$(echo $val | cut -d '"' -f2 | sed -e 's/ /_/g')"
			echo "Setting $name $prop=$val..."
			zfs set chyves:$prop=$sval $pool/chyves/guests/$name
		elif [ $prop = "description" ]; then
			local sval="$(echo $val | cut -d '"' -f2)"
			echo "Setting $name $prop=$val..."
			zfs set "chyves:$prop=$sval" $pool/chyves/guests/$name
		else
			echo "Setting $name $prop=$val..."
			zfs set chyves:$prop=$val $pool/chyves/guests/$name
		fi
	done
}

# Get ZFS props
__get() {
	local prop="$1"
	local name="$2"
	local pool="$(zfs list -H | grep chyves/guests/$name | cut -d '/' -f 1 | head -n1)"
	
	if [ "$prop" = "all" ]; then
		echo "Getting all $name chyves properties..."
		zfs get -o property,value all $pool/chyves/guests/$name | grep chyves: | sort | sed -e 's/chyves://g'
	else
		echo "Getting $name property \"$prop\"..."
		zfs get -H -o value chyves:$prop $pool/chyves/guests/$name
	fi
}

# Remove a PCIDEV property
__rmpci() {
	local flagone="$2"
	local flagtwo="$3"
	local flagthree="$4"
	if [ $flagone = "-f" ]; then
		echo "Removing $flagthree from $flagtwo"
		local pciprop="$(echo "$flagthree" | grep pcidev:)"
		local pool="$(zfs list -H -t volume | grep $flagtwo | cut -d '/' -f 1 | head -n1)"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r chyves:$flagthree $pool/chyves/guests/$flagtwo
		fi
	else
		local pciprop="$(echo "$flagtwo" | grep pcidev:)"
		local pool="$(zfs list -H -t volume | grep $flagone | cut -d '/' -f 1 | head -n1)"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo [Y/N]? " an </dev/tty
			case "$an" in
				y|Y) zfs inherit  -r chyves:$flagtwo $pool/chyves/guests/$flagone
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Add a new disk to guest
__add() {
	local name="$2"
	local size="$3"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | cut -d '/' -f 1 | head -n1)"
	# optionally allow the pool for the new disk to be specified. If not set, its set to $pool
	local newpool="${4-$pool}"
	# Find the last disk number and increment one
	local lastdisk="$(zfs list -H | grep chyves/guests/$name | grep disk | cut -d '/' -f4 | cut -f1 | \
		sort -V | cut -c5- | tail -n1)"
	local newdisk="$(expr $lastdisk + 1)"
	echo "Creating new zvol for $name..."
	zfs create $newpool/chyves/guests/$name 2> /dev/null
	zfs create -V $size -o volmode=dev $newpool/chyves/guests/$name/disk$newdisk
	# Find the last pcidev and increment by one
	local lastpci="$(zfs get -H all | grep chyves/guests/$name | grep pcidev | cut -f2 | \
		cut -d ':' -f3 | sort -V | tail -n1)"
	if [ -z $lastpci ]; then
		local newpci='1'
	else
		local newpci="$(expr $lastpci + 1)"
	fi
	zfs set chyves:pcidev:$newpci=ahci-hd,/dev/zvol/$newpool/chyves/guests/$name/disk$newdisk $pool/chyves/guests/$name
}

# Remove disk from guest
__remove() {
	local flagone="$2"
	local flagtwo="$3"
	local flagthree="$4"
	if [ $flagone = "-f" ]; then
		echo "Removing $flagthree from $flagtwo"
		local pool="$(zfs list -H -o name | grep $flagtwo | grep $flagthree | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagtwo | grep pcidev | grep $flagthree | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r $pciprop $pool/chyves/guests/$flagtwo
			zfs destroy $pool/chyves/guests/$flagtwo/$flagthree
		fi
	else
		local pool="$(zfs list -H -o name | grep $flagone | grep $flagtwo | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagone | grep pcidev | grep $flagtwo | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo from $flagone [Y/N]? " an </dev/tty
			case "$an" in
				y|Y)	zfs inherit  -r $pciprop $pool/chyves/guests/$flagone
					zfs destroy $pool/chyves/guests/$flagone/$flagtwo
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Resize a disk
__resize(){
	local name="$2"
	local disk="$3"
	local size="$4"
	local pool="$(zfs list -H -o name | grep chyves/guests/$name | grep $disk | cut -d '/' -f 1)"
	# Check if guest exists
	echo "Resizing $disk to $size"
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: chy-$name")
		if [ -z $running ]; then
			zfs set volsize=$size $pool/chyves/guests/$name/$disk
			zfs set chyves:size=$size $pool/chyves/guests/$name
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# List disks for a guest
__disks() {
	local name="$2"
	local pool="$(zfs list -H | grep chyves | cut -d '/' -f 1 | head -n1)"
	if [ -z $name ]; then
		echo "You must enter a guest name."
	elif [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		(
		echo "Listing disks for $name..."
		printf "diskN\tSize\n"
		zfs list -H -o name,volsize | grep -E "chyves.*$name.*disk" | \
			cut -d '/' -f4
		) | column -t
	else
		echo "Not a valid guest name"
	fi
}

# Snapshot a guest
__snapguest() {
	local fullsnap="$2"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1 | head -n1)"
	echo "Taking snapshot $fullsnap"
	# Check if guest exists
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		zfs snap -r $pool/chyves/guests/$fullsnap
	else
		echo "Not a valid guest name"
	fi
}

# Rollback guest
__rollguest() {
	local fullsnap="$2"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1 | head -n1)"
	local snap="$(echo $fullsnap | cut -d '@' -f2)"
	local disklist="$(zfs list -H | grep chyves/guests/$name | grep disk | \
				cut -f1 | cut -d '/' -f4-)"
	# Check if guest exists
	echo "Rolling back to $fullsnap"
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: chy-$name")
		if [ -z $running ]; then
			zfs rollback -rR $pool/chyves/guests/$fullsnap
			for disk in $disklist ; do
				zfs rollback -rR $pool/chyves/guests/$name/$disk@$snap
			done
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Clone a guest
__cloneguest() {
	local flag="$2"
	local name="$2"
	local cname="$3"
	local description="$(date | sed -e 's/ /_/g')"
	local pool="$(zfs list -H -t volume | grep "chyves/guests/$name/disk0" | cut -d '/' -f 1 | head -n1)"
	# Check if guest exists
	echo "Cloning $name to $cname"
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
			# Take snapshot
			zfs snap -r $pool/chyves/guests/$name@$cname
			# zfs send that snap and desendants then receive to cname
			zfs send -R $pool/chyves/guests/$name@$cname | \
			zfs recv $pool/chyves/guests/$cname
			# clean up
			zfs destroy -rR $pool/chyves/guests/$name@$cname
			zfs destroy -rR $pool/chyves/guests/$cname@$cname
			# rename the guest
			zfs set chyves:name=$cname $pool/chyves/guests/$cname
			zfs set chyves:description=$description $pool/chyves/guests/$cname
			# change con and tap properties to next available if -r is specified
			if [ "$flag" == "-r" ]; then
				local guestlist="$(zfs list -H -o name -t volume | grep chyves | cut -d'/' -f1-3)"
					listtaps(){
						for i in $guestlist ; do
							local tapprop="$(zfs get -H -o value chyves:tap $i)"
							printf $tapprop'\n'
						done
					}
				local taplast="$(listtaps | sort -V | cut -c4- | tail -n1)"
				if [ -z $taplast ]; then
					local tap='0'
				else
					local tap="$(expr $taplast + 1)"
				fi
				listcons(){
					for i in $guestlist ; do
						local conprop="$(zfs get -H -o value chyves:con $i)"
						printf $conprop'\n'
					done
				}
				local conlast="$(listcons | sort -V | cut -c5- | tail -n1)"
				if [ -z $conlast ]; then
					local con='0'
				else
					local con="$(expr $conlast + 1)"
				fi

				zfs set chyves:tap=tap$tap $pool/chyves/guests/$cname
				zfs set chyves:con=nmdm$con $pool/chyves/guests/$cname
			fi

	else
		echo "Not a valid guest name"
	fi
}

# Export Guest
__exportguest() {
	local name="$2"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1 | head -n1)"
	local disklist="$(zfs list -H | grep "chyves/guests/$name/disk" | \
				cut -f1 | cut -d '/' -f4-)"
	# Check if guest exists
	echo "Exporting $name. Note this may take some time depending on the size."
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		local running=$(pgrep -fx "bhyve: chy-$name")
		if [ -z $running ]; then
			# Create /tmp/chyves/guests/$name
			echo "Creating temp directory..."
			mkdir -p /tmp/chyves/guests/$name
			# Export Properties to file
			echo "Exporting properties..."
			zfs get -H -o property,value all $pool/chyves/guests/$name | grep chyves: | sort | \
				sed -e 's/chyves://g' | sed -e 's/	/=/g' > /tmp/chyves/guests/$name/properties.ucl
			# Write disks to file
			echo "Exporting disks..."
			for disk in $disklist ; do
				dd if=/dev/zvol/$pool/chyves/guests/$name/$disk of=/tmp/chyves/guests/$name/${disk}.img bs=1M
			done
			# Compress and add to archive
			echo "Compressing to archive..."
			tar -czf /chyves/guests/$name/$name.tar.gz -C /tmp/chyves/guests/$name/ .
			# Remove /tmp/chyves/
			echo "Removing temp directory..."
			rm -fr /tmp/chyves
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Run console
__console() {
	local name="$2"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1-3 | head -n1)"
	local con="$(zfs get -H -o value chyves:con $pool)"
	echo "Starting console on $name..."
	echo "~~. to escape console [uses cu(1) for console]"
	cu -l /dev/${con}B -s 9600
}

# Reset all consoles. This kills the cu(1)
__conreset() {
	killall cu
}

# Print help page
__help() {
__version
cat << 'EOT'
chyves  version
	setup pool=[poolname] kmod=[0/1] net=[interface]
	list [$null|trad|iso|firmware|snapshots|tap|con] [active]
	info [-vsdl]
	fetchiso [URL]
	cpiso [path]
	renameiso [ISO] [newname]
	rmiso [ISO]
	fetchfw [URL]
	cpfw [path]
	renamefw [firmware] [newname]
	rmfw [firmware]
	create [name] [size]
	install [name] [ISO]
	load [name] [path/to/bootdisk]
	boot [name] [runmode] [pcidevices]
	start [name] [-s | -a]
	stop [name]
	forcekill [name]
	scram
	destroy [name]
	rename [name] [newname]
	delete [-f] [name]
	set [name|.defaults] [prop1=value] [prop2=value]...
	get [[property]|all] [name]
	rmpci [-f] [name] [pcidev:N]
	add [name] [size] [[pool]]
	remove [-f] [name] [diskN]
	resize [name] [diskN] [size]
	disks [name]
	snap [name]@[snapshotname]
	roll [name]@[snapshotname]
	clone [-c | -r] [name] [clonename]
	export [name]
	console [name]
	conreset
	help
EOT
}

# Check for out of date datasets when not running setup.
if [ ! -z ${_OLD_VERSION_DATASETS} ] && [ "$1" != "setup" ]; then
  echo "Out of date chyves\' dataset(s) version found."
  echo "Please install sysutils/chyves-utils and then run:"
  echo "chyves-upgrade"
  exit 1
fi

if [ "$(zfs get -r chyves:dataset_role | grep -v @ | grep "primary" | wc -l )" -gt "1" ]; then
	echo "More than one primary pool set, fix it!"
	exit
fi

if [ -z "$1" ] ; then
	__help
	exit 0
fi

if [ $(__readonly_cmd "$1") != "0" -a "$(whoami)" != "root" ] ; then
	echo "The $1 command needs root credentials!"
	exit 1
fi

__parse_cmd "$@"
