#!/bin/sh

# Copyright (c) 2015, pr1ntf (Trent Thompson) All rights reserved.
# Copyright (c) 2016, Justin D Holcomb All rights reserved.
# Copyright (c) 2016, chyves All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

_VERSION=0.0.0                        # Example: v11.6.25 - XXX.YY.ZZZ
_VERSION_LONG="v0.0.0 2016/04/00"     # Example: v11.6.25 2021/12/31
_VERSION_INT="00000000"               # Example: 01106025 XXXYYZZZ
_UUID_GENERAL_USE="$(/bin/uuidgen)"
_OLD_VERSION_DATASETS="$(zfs get -H -o name,value -t filesystem -r chyves:pool_version | grep chyves/.config | grep -v "${_VERSION}" )"
_OFFLINE_POOLS_GREP_STRING=$(zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "offline" | cut -d'/' -f1 | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g')
_TEMPLATE_GUESTS_GREP_STRING=$(zfs get -H -o name,value -t filesystem -r chyves:guest_role | grep "chyves/guests" | grep "template" | cut -d'/' -f1 | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g')
_KERNEL_MODULES=$(printf "%s\n%s\n%s\n%s\n%s" "vmm" "nmdm" "if_tap" "bridgestp" "if_bridge")
_FORBIDDEN_GUEST_NAMES=".defaults|reorder"

##### More global variables set in __preflight_check #####
PATH=${PATH}:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin

# This function gets ran before any other.
__preflight_check() {

	# Checks to see variable is empty as grep needs an arguement and a UUID stastically should not have a collision if there are no pools in an offline role
	if [ -z "${_OFFLINE_POOLS_GREP_STRING}" ]; then
	  _OFFLINE_POOLS_GREP_STRING=${_UUID_GENERAL_USE}
	fi

	# Appends ".defaults" to $_TEMPLATE_GUESTS_GREP_STRING
	if [ -z "${_TEMPLATE_GUESTS_GREP_STRING}" ]; then
	  _TEMPLATE_GUESTS_GREP_STRING=".defaults"
	else
	  _TEMPLATE_GUESTS_GREP_STRING=$( echo "${_TEMPLATE_GUESTS_GREP_STRING}|.defaults" )
	fi

	# Check for out of date datasets when not running setup.
	if [ ! -z ${_OLD_VERSION_DATASETS} ] && [ "$1" != "setup" ]; then
	  __fault_detected_exit "Out of date chyves\' dataset(s) version found. \nPlease install sysutils/chyves-utils and then run: \nchyves-upgrade"
	fi

	# Check to see if more than one pool has the primary role set.
	if [ "$(zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "primary" | wc -l )" -gt "1" ]; then
		__fault_detected_exit "More than one primary pool set, fix it!"
	fi

	# Check for out of date datasets when not running setup.
	if [ ! -z ${_OLD_VERSION_DATASETS} ] && [ "$1" != "setup" ]; then
		echo "Out of date chyves\' dataset(s) version found."
		echo "Please install sysutils/chyves-utils and then run:"
		echo "chyves-upgrade"
		exit 1
	fi

	# If no sub-command is used, run the help function
	if [ -z "$1" ] ; then
		__help
		exit 0
	fi

	# Check to see if running with elevated credentials
	if [ $(__readonly_cmd "$1") != "0" -a "$(whoami)" != "root" ] ; then
		echo "The $1 command needs root credentials!"
		exit 1
	fi

	# CPU feature check
	# First check to see if EPT/RVI is available then complain if "unrestricted guests" is not found on an Intel CPU.
	if [ -n "$( __get_cpu_section_from_dmesg | grep 'Features2=' | grep 'POPCNT' )" ]; then
		if [ -n "$( __get_cpu_section_from_dmesg | grep 'CPU:' | grep 'Intel' )" ] && [ -z "$( __get_cpu_section_from_dmesg | grep 'VT-x:' | grep 'UG' )" ]; then
			echo "This CPU lacks the 'UG' feature of EPT. This is required by bhyve to run to the full extent."
			echo "Due to this missing CPU feature: a guest is limited to one virtual CPU and starting UEFI guests is disabled."
			echo "See CPU feature flags below:"
			__get_cpu_section_from_dmesg
			# Insert way to disable this warning later on.
			_CPU_MISSING_UG=1
		fi
	else
		__fault_detected_exit "Your CPU lacks the basic feature to run bhyve. For AMD CPUs this means RVI. For Intel CPUs this means EPT."
	fi

	# Variables that need functions loaded:
	_PRIMARY_POOL=$( __get_primary_pool_name )
	_DEVELOPER_MODE="$(zfs get -H -o value chyves:dev_mode $_PRIMARY_POOL/chyves/.config )"

}

# Function used to exit with a message.
__fault_detected_exit() {
  local message="$1"
  echo "Critical error detected. Exiting for following reason:"
  echo -e "${message}"
  exit 1
}

# See whether given command is readonly
# and therefore doesn't need root credentials
__readonly_cmd () {
    case "$1" in
        help|-h|get|getall|info|list|version) echo "0"
            ;;
        *) echo "1"
            ;;
    esac
}

# Validates if a given pool name exists.
__verify_valid_pool() {
	local _name_to_check="$1"
	local _flags="$2"
	# Valid _flags are:
	# $null   [no flag used] Validates the supplied pool is in fact a ZFS pool
	# -p      [primary] Validates the supplied pool has the primary role set
	# -c      [chyves] Validates the supplied pool is setup for chyves
	# -e      [escape] Escape from a normal fatal exit. Good for __setup.

	# Check to see if pool exists
	zfs list -H $_name_to_check > /dev/null 2>&1
	if [ $? ]; then
		# When a bad pool name is used the ZFS error message: "cannot open 'zroot': dataset does not exist" is displayed. However it is not "seen" by the evaluating if statement.

		# Check to see if the pool is in the primary dataset_role
		if [ -n "$(echo $_flags | grep 'p')" ]; then
			if [ "$( zfs get -H -o value chyves:dataset_role $_name_to_check/chyves/.config )" != "primary" ]; then
				if [ -n "$(echo $_flags | grep 'e')" ]; then
				else
					__fault_detected_exit "${_name_to_check} is not a primary pool."
				fi
			fi
		# Check to see if the pool has been setup for chyves
		zfs list -H $_name_to_check/chyves > /dev/null 2>&1
		elif [ $? ] && [ -n "$(echo $_flags | grep 'c')" ]; then
			if [ -n "$(echo $_flags | grep 'e')" ]; then
				__fault_detected_exit "${_name_to_check} has been setup with chyves."
			fi
		else
			__fault_detected_exit "${_name_to_check} has not been setup with chyves."
		fi
	else
		if [ -n "$(echo $_flags | grep 'e')" ]; then
		else
			__fault_detected_exit "Invalid pool name supplied."
		fi
	fi
}

# Validates if a given guest name on a given pool exists.
__verify_valid_guest() {
	local _guest_to_check="$1"
	local _pool="$2"
	local _flags="$3"
	# Valid _flags are:
	# $null   [no flag used] Validates the supplied pool is in fact on the supplied ZFS pool
	# -s      [start] Exits if guest is a template or on an offline pool

	# Check to see if pool has chyves setup on it.
	__verify_valid_pool $_pool -c

	# Check to see if guest name used more than once
	if [ "$(zfs list -r -H -t filesystem -o name | grep "chyves/guests/$_guest_to_check" | grep -E -v "$_OFFLINE_POOLS_GREP_STRING" | wc -l )" -gt "1" ]; then
		__fault_detected_exit "More than one $_guest_to_check exists on system within active pools and guests, fix it!"
	fi

	if [ ! -n "$(zfs list -H $_pool/chyves/guests/$_guest_to_check | grep -v "dataset does not exist" | grep -v "No such file or directory" )" ]; then
		__fault_detected_exit "Invalid guest name (${_guest_to_check}) supplied."
	fi

	# Exits if guest is a template or on an offline pool.
	if [ -n "$(echo $_flags | grep 's')" ] && [ -z "$(zfs list -r -H -t filesystem -o name | grep "$_pool/chyves/guests/$_guest_to_check" | grep -E -v "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" )" ]; then
		__fault_detected_exit "$_guest_to_check is either a template or contained within a chyves dataset where the dataset_role is set to 'offline'."
	fi
}

# Verify kernel module loaded
__verify_kernel_module_loaded() {
	local _module="$1"
	local _flags="$2"
	local _status=$(kldstat -v | grep $_module )
	# Valid _flags are:
	# $null   [no flag used] check only
	# -l      [load] Load module if not loaded
	# -u      [unload] Unload module

	# When erroring out the following message is displayed:
	# kldload: can't load $_module: No such file or directory
	if [ -z "$_status" ]; then
		if [ "$_flags" = "-l" ]; then
			kldload $_module
			sleep 5
			__verify_kernel_module_loaded "$_module"
		else
			__fault_detected_exit "Kernel module '$_module' not loaded. Run 'chyves setup kmod=1'"
		fi
	elif [ "$_flags" = "-u" ]; then
		kldunload -v $_module
		echo "Kernel module '$_module' loaded."
	else
		# echo "Kernel module '$_module' already loaded."
	fi
}

# Verify all modules in $_KERNEL_MODULES
__verify_all_kernel_modules(){
	local _flag="$1"
	# Valid _flag are:
	# $null   [no flag used] check only
	# -l      [load] Load module if not loaded
	# -u      [unload] Unload module

	if [ -z "$_flag" ] || [ "$_flag" = "-l" ] || [ "$_flag" = "-u" ]; then
		for _module in $_KERNEL_MODULES ; do
			echo "Checking module: $_module"
			__verify_kernel_module_loaded "$_module" "$_flag"
		done
	fi
}

# Verify that a binary is available
__verify_binary_available() {
	local _binary_to_check_for="$1"
	local _path_to_binary=$( which ${_binary_to_check_for} )

	if [ ! -x "${_path_to_binary}" ]; then
		__fault_detected_exit "Failed to find executable binary: '$_binary_to_check_for'"
	fi
}

# Verifies the number of parameters and exits if met or exceeded
__verify_number_of_arguments() {
	local _number_of_minimum_parameters=$1        # Minimum number of parameters
	local _number_of_supplied_parameters=$2       # As counted by "$#"
	local _number_of_maximum_parameters=$3        # (Optional) Maximum number of parameters

	# While $3 is optional, it does need a value if not set.
	[ -z "${_number_of_maximum_parameters}" ] && local _number_of_maximum_parameters=$_number_of_supplied_parameters

	if [ "${_number_of_supplied_parameters}" -lt "${_number_of_minimum_parameters}" ] || [ "${_number_of_supplied_parameters}" -gt "${_number_of_maximum_parameters}" ]; then
		__help
		__fault_detected_exit "Incorrect number of arguments used. Please see above for correct syntax."
	fi
}

# Checks to see if on FreeNAS
# The web UI references this file to display the version
__check_if_freenas() {
	if [ -e /etc/version ]; then
		local OS=$( cat /etc/version | cut -d - -f1 )
		if [ "$OS" = "FreeNAS" ]; then
			echo 1
		fi
	fi
}

# Gets pool names from ZFS with flag options for active/inactive
__get_pool_names() {
	local _flags="$1"
	# Valid flags are:
	# -a [all] for  primary|secondary|offline pools
	# -i [inactive] only display offline pools

	if [ -n "$(echo "$_flags" | grep 'a')" ]; then
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq )"
	elif [ -n "$(echo "$_flags" | grep 'i')" ]; then
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq | grep -E "$_OFFLINE_POOLS_GREP_STRING" )"
	else
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq | grep -E -v "$_OFFLINE_POOLS_GREP_STRING" )"
	fi
}

# Get pool name for guest
__get_pool_for_guest() {
	local _guest_name="$1"
	local _pool="$(zfs list -d 3 -r -H -t filesystem -o name | grep chyves/guests/$_guest_name | cut -d '/' -f 1 )"
	__verify_valid_pool "$_pool"
	__verify_valid_guest "$_guest_name" "$_pool"
	echo "$_pool"
}

# Get primary pool name
__get_primary_pool_name() {
	local _var="$(zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "primary" | cut -d'/' -f1 )"
	__verify_valid_pool "$_var" "-p"
	echo "${_var}"
}

#  Get all chyves properties that are set on the system
__get_property_list() {
	echo "$( zfs get -r -H -t filesystem -o name,property all | grep /guests/ | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq )"
}

# Return the value of the next console to use
__get_next_console() {
	local conlast="$(zfs get -H -o value chyves:con | grep -v - | sort -V | tail -n1 | cut -c 5-)"
	if [ -z $conlast ]; then
		zfs get -H  -t filesystem -o value chyves:console_start_offset $_PRIMARY_POOL/chyves/.config
	else
		echo "$(expr $conlast + 1)"
	fi
}

# Return the value of the next tap interface to use
__get_next_tap() {
	local taplast="$(zfs get -H -o value chyves:tap | grep -v - | sort -V | tail -n1 | cut -c 4-)"
	if [ -z $taplast ]; then
		zfs get -H  -t filesystem -o value chyves:tap_start_offset $_PRIMARY_POOL/chyves/.config
	else
		echo "$(expr $taplast + 1)"
	fi
}

# Get a list of guests on system
__get_guests_list() {
	local _flags="$1"
	local _pool="$2"   # Optional
	# $null   Get a list of active guests
	# -d      [disks] Get a list of guests and their disks.
	# -a      [all] Get a list of all guests regardless if dataset_role is offline or if guest_roll is set to template
	# -f      [full] List as a full dataset name.

	if [ -n "$(echo "$_flags" | grep 'd')" ]; then
		local _zfs_command='zfs list -d 4 -r -H -t filesystem,volume -o name'

		if [ -n "$(echo "$_flags" | grep 'f')" ]; then
			local _PIPE_what_type_of_cutter='cut -f1'
		else
			local _PIPE_what_type_of_cutter='cut -d/ -f4-'
		fi
	else
		local _zfs_command='zfs list -d 3 -r -H -t filesystem -o name'
		local _PIPE_what_type_of_cutter='cut -d/ -f4'
	fi

	[ -n "${_pool}" ] && local _pool="$_pool/chyves/guests"

	if [ -n "$(echo "$_flags" | grep 'a')" ]; then
		$_zfs_command $_pool | grep chyves/guests | grep -v .defaults | $_PIPE_what_type_of_cutter | sed '/^$/d'
	else
		$_zfs_command $_pool | grep -E -v "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" | grep chyves/guests | grep -v .defaults | $_PIPE_what_type_of_cutter | sed '/^$/d'
	fi
}

# Get path for dataset
__get_path_for_guest_dataset() {
	local _guest_name="$1"
	local _pool="$2"
	local _path="$( zfs list -r -H -t filesystem -o mountpoint $_pool/chyves/guests/$_guest_name )"
	echo "$_path"
}

# Get CPU count but lie if the "UG" CPU feature is missing.
__get_liar_cpu_value() {
	local $dataset=$1

	 # If CPU feature "UG" is missing limit to one CPU
	 if [ "${_CPU_MISSING_UG}" ]; then
		 echo "1"
	 else
		 zfs get -H -o value chyves:cpu $dataset
	 fi
 }

 # Pulls CPU section from boot dmesg
 __get_cpu_section_from_dmesg() {
	 cat /var/run/dmesg.boot | grep -B 100 "real memory" | grep -v "real memory" | grep -A 20 "CPU:"
 }

# Builds the device map file
__create_device_map() {
	local _path="$1"
	local _disk="$2"
	local _iso="$3"
	printf '\(hd0\)\ /dev/zvol/'$_disk'\n' > $_path/device.map
	printf '\(cd0\)\ '$_iso'\n' >> $_path/device.map
}

# Creates string used to create ZFS volume for disks
__create_zvol_disk_options_string() {

	# Get values from .defaults
	local def_disk_volmode="$(zfs get -H -o value chyves:disk_volmode $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_disk_volblocksize="$(zfs get -H -o value chyves:disk_volblocksize $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_disk_dedup="$(zfs get -H -o value chyves:disk_dedup $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_disk_compression="$(zfs get -H -o value chyves:disk_compression $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_disk_primarycache="$(zfs get -H -o value chyves:disk_primarycache $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_disk_secondarycache="$(zfs get -H -o value chyves:disk_secondarycache $_PRIMARY_POOL/chyves/guests/.defaults)"
	local _disk_options

	# Compile a variable string to be used in the ZFS volume creation
	[ "${def_disk_volmode}" != "inherit" ] && local _disk_options="-o volmode=$def_disk_volmode"
	[ "${def_disk_volblocksize}" != "inherit" ] && local _disk_options="$_disk_options -o volblocksize=$def_disk_volblocksize"
	[ "${def_disk_dedup}" != "inherit" ] && local _disk_options="$_disk_options -o dedup=$def_disk_dedup"
	[ "${def_disk_compression}" != "inherit" ] && local _disk_options="$_disk_options -o compression=$def_disk_compression"
	[ "${def_disk_primarycache}" != "inherit" ] && local _disk_options="$_disk_options -o primarycache=$def_disk_primarycache"
	[ "${def_disk_secondarycache}" != "inherit" ] && local _disk_options="$_disk_options -o secondarycache=$def_disk_secondarycache"

	echo "$_disk_options"
}

#  get|set chyves: properties
__multi_chyves_zfs_property() {
	local _action=$1        # get|set
	local _property=$2      # <property name>
	local _pool=$3          # primary|<pool name>
	local _resource=$4      # .config|guests
	local _guest="$5"       # <guest name>
	local _value="$6"       # <property value>

	# Null out value when "-" used
	[ "${_guest}" = "-" ] && local _guest=""

	# If the guest value is populated, prepend a "/" - This is for .config compatibility
	[ -n "${_guest}" ] && local _guest="/$_guest"

	# Set _pool to the primary pool name when "primary" is used in the _pool name variable.
	[ "${_pool}" = "primary" ] && local _pool=$_PRIMARY_POOL

	if [ "${_action}" = "set" ]; then
		zfs set chyves:${_property}="${_value}" $_pool/chyves/${_resource}${_guest}
	elif [ "${_action}" = "get" ]; then
		zfs get -H -o value chyves:$_property $_pool/chyves/${_resource}${_guest}
	else
		__fault_detected_exit "Unrecoginized action: '$_action'"
	fi
}

# Check VMM resource allocation status
__check_vmm_alocated() {
	local _guest=$1
	local _flags=$2
	local _vmm_dev="/dev/vmm/chy-$_guest"
	# Valid flags are:
	# null    Return nothing or a 1
	# -h      [human] for a "YES" or "NO" indicator

	if [ "$_flags" = "-h" ]; then
		if [ -e "$_vmm_dev" ]; then
			echo "YES"
		else
			echo "NO"
		fi
	elif [ -e "$_vmm_dev" ]; then
		echo "1"
	fi
}

# Check bhyve process running status
__check_bhyve_process_running() {
	local _guest=$1
	local _flags=$2
	local _bhyve_process_running=$( pgrep -fx "bhyve: chy-$_guest" )
	# Valid flags are:
	# null    Return nothing or a 1
	# -h      [human] for a "YES (pid)" or "NO" indicator

	if [ "$_flags" = "-h" ]; then
		if [ -n "$_bhyve_process_running" ]; then
			echo "YES ($_bhyve_process_running)"
		else
			echo "NO"
		fi
	elif [ -e "$_bhyve_process_running" ]; then
		echo "$_bhyve_process_running"
	fi
}

# Displays the boot priority of a guest "YES (xxx)" where number is the priority
__display_rcboot_priority() {
	local _pool=$1
	local _guest=$2
	local _rcboot_property="$( __multi_chyves_zfs_property "get" "rcboot" "$_pool" "guests" "$_guest" )"

	if [ "$_rcboot_property" -gt '0' ]; then
		echo "YES ($_rcboot_property)"
	else
		echo "NO"
	fi
}

# Process command line
__parse_cmd () {
  case "$1" in
    version)  __verify_number_of_arguments "1" "$#"
              __version
              exit
    ;;
    setup)    __verify_number_of_arguments "2" "$#" "4"       # Needs to be switched over to function index rather than script index
              __setup "$@"
              exit
    ;;
    list)     __verify_number_of_arguments "1" "$#" "3"
              __list "$2" "$3"
              exit
    ;;
    info)     __verify_number_of_arguments "1" "$#" "2"
              __info "$2"
              exit
    ;;
    firmware) __verify_number_of_arguments "2" "$#" "5"
              __resource_functions "firmware" "$2" "$3" "$4"
              exit
    ;;
    iso)      __verify_number_of_arguments "2" "$#" "5"
              __resource_functions "iso" "$2" "$3" "$4"
              exit
    ;;
    create)   __verify_number_of_arguments "2" "$#" "4"
              __create "$2" "$3" "$4"
              exit
    ;;
    install)  __verify_number_of_arguments "3" "$#" "3"
              __install "$2" "$3"
              exit
    ;;
    start)    __verify_number_of_arguments "2" "$#" "3"
              __start "$2" "$3"
              exit
    ;;
    uefi)     __verify_number_of_arguments "2" "$#" "3"
              __uefi "$2" "$3"
              exit
    ;;
    stop)     __verify_number_of_arguments "2" "$#" "2"
              __stop "$2"
              exit
    ;;
    forcekill) __verify_number_of_arguments "2" "$#" "2"
               __forcekill "$2"
               exit
    ;;
    scram)    __verify_number_of_arguments "1" "$#" "1"
              __scram
              exit
    ;;
    destroy)  __verify_number_of_arguments "2" "$#" "2"
              __destroy "$2"
              exit
    ;;
    rename)   __verify_number_of_arguments "4" "$#" "4"
              __resource_functions "guest" "rename" "$3" "$4"
              exit
    ;;
    delete)   __verify_number_of_arguments "3" "$#" "3"
              __resource_functions "guest" "delete" "$3"
              exit
    ;;
    set)      __verify_number_of_arguments "3" "$#"           # Technically unlimited number of properties can be set.
              __set "$@"
              exit
    ;;
    get)      __verify_number_of_arguments "2" "$#" "3"
              __get "$2" "$3"
              exit
    ;;
    rmpci)    __verify_number_of_arguments "3" "$#" "4"       # Soon to be consolidated
              __rmpci "$2" "$3" "$4"
              exit
    ;;
    add)      __verify_number_of_arguments "3" "$#" "3"
              __add "$2" "$3"
              exit
    ;;
    remove)   __verify_number_of_arguments "3" "$#" "4"
              __remove "$2" "$3" "$4"
              exit
    ;;
    resize)   __verify_number_of_arguments "4" "$#" "4"
              __resize "$2" "$3" "$4"
              exit
    ;;
    disks)    __verify_number_of_arguments "2" "$#" "2"       # Can be consolidated to __list()
              __disks "$2"
              exit
    ;;
    snap)     __verify_number_of_arguments "2" "$#" "2"       # Needs a rework
              __snapguest "$2"
              exit
    ;;
    roll)     __verify_number_of_arguments "2" "$#" "2"       # Needs a rework
              __rollguest "$2"
              exit
    ;;
    clone)    __verify_number_of_arguments "3" "$#" "4"       # Needs a rework
              __cloneguest "$2" "$3" "$4"
              exit
    ;;
    export)   __verify_number_of_arguments "2" "$#" "2"       # Going to be moved to chyves-utils
              __exportguest "$2"
              exit
    ;;
    console)  __verify_number_of_arguments "2" "$#" "3"       # Tmux support soon
              __console "$2" "$3"
              exit
    ;;
    conreset) __verify_number_of_arguments "1" "$#" "1"       # Can be built to reset just one console
              __conreset
              exit
    ;;
    help|-h)  __help
              exit
    ;;
    dev)      [ "$_DEVELOPER_MODE" == "off" ] && __fault_detected_exit "Developer mode is set to "off", if desired turn on by running 'chyves set .config primary dev_mode=on'"
              [ "$_DEVELOPER_MODE" != "on" ] && set "$_DEVELOPER_MODE"
              $2 "$3" "$4" "$5" "$6" "$7" "$8" "$9"           # Used for developer to test a function directly
              [ "$_DEVELOPER_MODE" != "on" ] && set "$( echo $_DEVELOPER_MODE | sed 's/-/+/g' )"
              exit
    ;;
  esac
}

# Show version
__version() {
	echo "chyves ${_VERSION_LONG}"
}

# Setup chyves
__setup() {
	local args="$@"
	for arg in $args; do
		if [ "${arg}" != "setup" ]; then
			local prop="$(echo $arg | cut -d '=' -f1)"
			local val="$(echo $arg | cut -d '=' -f2)"
			if [ "${prop}" = "pool" ]; then
				local pool="$val"
				__verify_valid_pool "$val" -ce
				echo "Setting up chyves pool..."
				zfs create $pool/chyves
				zfs create $pool/chyves/guests
				zfs create $pool/chyves/.config
				zfs set chyves:pool_version=${_VERSION} $pool/chyves/.config
				# a chyves pool is already setup, setup secondary pool.
				if [ -d /chyves/ISO ]; then
					echo "Secondary pool set up..."
					zfs set mountpoint="/chyves/$pool" $pool/chyves
					zfs set chyves:dataset_role=secondary $pool/chyves/.config
				# chyves is not set up yet, setup primary pool.
				else
					zfs set mountpoint="/chyves" $pool/chyves
					zfs create $pool/chyves/ISO
					zfs create $pool/chyves/Firmware
					echo "Setting up .defaults dataset and properties on primary pool..."
					zfs create $pool/chyves/guests/.defaults
					zfs set chyves:size=8G $pool/chyves/guests/.defaults
					zfs set chyves:cpu=1 $pool/chyves/guests/.defaults
					zfs set chyves:ram=256M $pool/chyves/guests/.defaults
					zfs set chyves:persist=1 $pool/chyves/guests/.defaults
					zfs set chyves:rcboot=0 $pool/chyves/guests/.defaults
					zfs set chyves:loader=bhyveload $pool/chyves/guests/.defaults
					zfs set chyves:os=freebsd $pool/chyves/guests/.defaults
					zfs set chyves:bargs=-A_-H_-P $pool/chyves/guests/.defaults
					zfs set chyves:disk_volmode=dev $pool/chyves/guests/.defaults
					zfs set chyves:disk_volblocksize=512 $pool/chyves/guests/.defaults
					zfs set chyves:disk_dedup=inherit $pool/chyves/guests/.defaults
					zfs set chyves:disk_compression=inherit $pool/chyves/guests/.defaults
					zfs set chyves:disk_primarycache=inherit $pool/chyves/guests/.defaults
					zfs set chyves:disk_secondarycache=inherit $pool/chyves/guests/.defaults

					echo "Setting up .config properties on primary pool..."
					zfs set chyves:dataset_role=primary $pool/chyves/.config
					zfs set chyves:dev_mode=off $pool/chyves/.config
					zfs set chyves:console_start_offset=50 $pool/chyves/.config
				fi

				# If on FreeNAS do a couple of needed changes.
				if [ "$( __check_if_freenas )" ]; then
					echo "On FreeNAS installation."
					echo "Checking for symbolic link to /chyves from /mnt/chyves..."
					if [ -d /mnt/chyves ]; then
						if [ ! -e /chyves ]; then
							ln -s /mnt/chyves /chyves
							if [ -L /chyves ]; then
								echo "Symbolic link to /chyves from /mnt/chyves successfully created."
							else
								echo "Failed to create symbolic link."
								echo "Please manually do so by running the following as root:"
								echo "# ln -s /mnt/chyves /chyves"
							fi
						elif [ -L /chyves ]; then
							echo "Symbolic link to /chyves already exists."
						fi
					elif [ "$val" = "freenas-boot" ] && [ -d /chyves ]; then
						echo "Symbolic link not needed. /chyves exists."
						echo "chyves is installed on the freenas-boot pool."
						echo "This is not recommended configuration."
					else
						echo "chyves does not seem to be setup."
					fi
				fi
          elif [ "${prop}" = "kmod" ]; then
				if [ "${val}" = "1" ]; then
					echo "Loading kernel modules..."
					__verify_all_kernel_modules -l
				elif [ "${val}" = "2" ]; then
					echo "Attempting to unloading kernel modules..."
					__verify_all_kernel_modules -u
				else
					echo "Improper syntax"
					echo "kmod=0 do nothing"
					echo "kmod=1 to load modules"
					echo "kmod=2 to unload modules"
				fi
			elif [ "${prop}" = "net" ]; then
				local bridgeif="$('ifconfig' -l | grep -F "bridge0 " | cut -c1)"
				if [ -z "${bridgeif}" ]; then
					echo "Seting up bridge0 on $val..."
					sysctl net.link.tap.up_on_open=1
					ifconfig bridge0 create descr "chyves-bridge"
					ifconfig bridge0 addm $val
					ifconfig bridge0 up
				else
					echo "bridge0 is already enabled on this machine..."
					local sysctlexist="$(sysctl net.link.tap.up_on_open | grep 1 | cut -c1)"
					if [ -z "${sysctlexist}" ]; then
						echo "Setting up correct sysctl value..."
						sysctl net.link.tap.up_on_open=1
					else
						echo "sysctl already setup properly as well..."
					fi
				fi
			fi
		fi
	done
}

# Outputs PCI device string for bhyve command
__get_bhyve_cmd() {
	local devices="$1"
	local pci_slot_count=0
	for device in $devices ; do
		echo "-s $pci_slot_count,$device"
		pci_slot_count=$(( pci_slot_count + 1 ))
	done
}

# Get PCI device config from zfs
__get_zfs_pcidev_conf() {
	local pool="$1"
	local oldifs=$IFS
	#local pci
	IFS=$'\n'
	for pcidev in $(zfs get -H -o property,value all $pool | grep chyves:pcidev: | sort )
	do
		echo $pcidev | cut -f2-
	done
	IFS=$oldifs
}

# List Guests
__list() {
	local output_type="$1"
	local _arg2="$2"         # Used for tap and processes

	# Lists the traditional output
	if [ -z "${output_type}" ]; then

		local pools=$( __get_pool_names )
		(
		printf "%s^%s^%s^%s^%s^%s\n" "Guest" "VMM" "Running" "rcboot" "Pool" "Description"
		for pool in $pools; do
			local guests="$( __get_guests_list - $pool )"
			for g in $guests; do
				local _vmm_status=$( __check_vmm_alocated $g -h  )
				local _bhyve_status=$( __check_bhyve_process_running $g -h )
				local _rcboot_priority=$( __display_rcboot_priority $pool $g )
				local description="$( __multi_chyves_zfs_property "get" "description" "$pool" "guests" "$g" )"
				printf "%s^%s^%s^%s^%s^%s\n" "$g" "$_vmm_status" "$_bhyve_status" "$_rcboot_priority" "$pool" "$description"
			done
		done
		) | column -ts^

	# Dynamically lists the guest chyves properties
	elif [ "${output_type}" = "properties" ]; then
		echo "Use the following syntax to display of list of the guests on the system and a property."
		echo "These are the available properties: "
		__get_property_list
		echo "Run 'chyves list <property>' to see what that property is for each guest."

	# List ISO firmware resources.
	elif [ "${output_type}" = "iso" ]; then
		local pool=$_PRIMARY_POOL
		echo "Listing ISOs..."
		zfs list -H -r $pool/chyves/ISO | cut -f 1 | cut -d '/' -f 4 | sed 1d

	# List Firmware resources. Using "firmware" lists the property firmware rather than the resource
	elif [ "${output_type}" = "firmwares" ]; then
		echo "Listing Firmware..."
		zfs list -H -r $pool/chyves/Firmware | cut -f1 | cut -d '/' -f 4 | sed 1d

	# List snapshots
	elif [ "${output_type}" = "snapshots" ]; then
		echo "Listing snapshots..."
		zfs list -H -t snapshot | grep chyves/guests | grep -v ".defaults" | cut -f1 | cut -d '/' -f4- | sed '/^$/d'

	# List properties set in .config
	elif [ "${output_type}" = ".config" ]; then
		local _pool=$arg2

		echo "Listing properties set in .config"
		[ "$_arg2" = "primary" ] && _pool=$_PRIMARY_POOL

		if [ -n "${_pool}" ]; then
			(
			echo -e "Property\t Value"
			zfs get -r -t filesystem -o property,value all $_pool/chyves/.config | grep chyves: | sed -e 's/chyves://g'
			) | column -t
		else
			(
			echo -e "Dataset\t Property\t Value"
			zfs get -r -t filesystem -o name,property,value all | grep chyves/.config | grep chyves: | sed -e 's/chyves://g' | sed -e 's/\/chyves\/\.config//g'
			) | column -t
		fi

		# List properties set in .defaults
	elif [ "${output_type}" = ".defaults" ]; then
			__get all .defaults

	# List processes
	elif [ "${output_type}" = "processes" ]; then
		local _guest_name=$_arg2

		echo "Listing processes..."
		if [ -z "$_guest_name" ]; then
			ps -aux | grep -E "chy-|chyves|bhyveload|grub-bhyve" | grep -v -E "grep -E chy-|/bin/sh /usr/local/sbin/chyves list"
		else
			local pool="$( __get_pool_for_guest "${_guest_name}" )"
			__verify_valid_guest "${_guest_name}" "$pool"
			ps -aux | grep ${_guest_name} | grep -E -v "grep ${_guest_name}|/bin/sh /usr/local/sbin/chyves list"
		fi

	# Lists a property for all active guests. See "chyves list properties" for options
	elif [ -n $( __get_property_list | grep "$output_type " ) ]; then

		# Displays active tap via /dev
		if [ "$output_type" = "tap" ] && [ "${_arg2}" = "active" ]; then
			echo "Listing active network taps..."
			ls /dev | grep tap
			exit
		fi

		# Displays singular property
		(
		printf 'Guest\t'$output_type'\n'
		local poollist=$( __get_pool_names -a )
		for pool in $poollist; do
			local guestlist=$( __get_guests_list - $pool )
			for guest in $guestlist; do
				local property="$( zfs get -H -o value chyves:${output_type} $pool/chyves/guests/$guest )"
				printf $guest'\t'$property'\n'
			done
		done
		) | column -t
	fi
}

# Display info about all guests.
__info() {
	local flags="$1"

	if [ "$flags" = "-h" ] || [ -n "$(echo "$flags" | grep 'g' | grep 'i')" ]; then
cat << 'EOT'

    chyves info

Displays information about chyves guests. Without the use of flags, each guest's
name, disks, size, CPU count, RAM allotment, and respective pool are displayed.
The following flags are used in combination to display more fields than the
default. These flags are used in combination meaning the correct syntax is
"-rvs" rather than "-r -v -s". See below for a description of what each flag
does:

 Flags to controls which fields are displayed:
  -r    [role] Display what role the dataset is set to.
  -v    [verbose] Display OS, loader, tap, and console port.
  -s    [status] Display VMM status, if bhyve instance running, and if the
        rcboot is set.
  -t    [template] Displays if guest is a template.
  -d    [description] Dispays description property.
	-n    [notes] Dispays notes property.
  -a    [all] Display all fields above.

 Flags to controls which guests are display or their disks:
  -k    [no-disks] Do not display guests' disks.
  -g    [all-guests] Display all guests (Even offline and templates).
  -i    [inactive] Display only templates and guests on pools with property
        dataset_role set to offline. Incompatiable with the -g flag.

 Miscellaneous flags:
  -h    [help] Display this message.
  -l    [less] Pipes the output to less.

EOT

	# These two flags options are competitive, exit with a warning.
	[ -n "$(echo "$flags" | grep 'g' | grep 'i')" ] && __fault_detected_exit "The -g and -i flags for 'chyves info' are incompatiable. All other flags combinations are fine."

		exit
	fi

	# Poll to see what pools have active guests
	# or the '-g' flag for all guests
	# or the '-i' flag for offline and templates
	if [ -n "$(echo "$flags" | grep 'i')" ]; then
		local pools=$( __get_pool_names -a | grep -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" )
	elif [ -n "$(echo "$flags" | grep -E 'g|a' )" ]; then
		local pools=$( __get_pool_names -a )
	else
		local pools=$( __get_pool_names )
	fi

	( # Begining of very large table of output.
	# Print common header
	printf "%s^%s^%s^%s^%s" "Guest" "Size" "CPU" "RAM" "Pool"

	# Print headers for -r flag
	[ -n "$(echo "$flags" | grep -E 'r|a')" ] && printf "^%s" "Dataset Role"

	# Print headers for -v flag
	[ -n "$(echo "$flags" | grep -E 'v|a')" ] && printf "^%s^%s^%s^%s" "OS" "Loader" "Tap" "Con"

	# Print headers for -s flag
	[ -n "$(echo "$flags" | grep -E 's|a')" ] && printf "^%s^%s^%s" "VMM" "Running" "rcboot"

	# Print headers for -t flag
	[ -n "$(echo "$flags" | grep -E 't|a')" ] && printf "^%s" "Template"

	# Print headers for -d flag
	[ -n "$(echo "$flags" | grep -E 'd|a')" ] && printf "^%s" "Description"

	# Print headers for -n flag
	[ -n "$(echo "$flags" | grep -E 'n|a')" ] && printf "^%s" "Notes"

	# Print new line for first guest.
	printf "\n"

	# Spider through pools
	for pool in $pools; do
		# Poll to see which guests are on $pool
		# This is required for showing inactive guests as __get_guests_list normally omits these guests
		[ -n "$(echo "$flags" | grep -E 'g|i')" ] && local _do_not_omit_inactive=a
		if [ -n "$(echo "$flags" | grep 'k')" ]; then
			local guests="$( __get_guests_list -${_do_not_omit_inactive} $pool )"
		else
			# Default is to display disks.
			local guests="$( __get_guests_list -d${_do_not_omit_inactive} $pool )"
		fi

		local dataset_role=$( zfs get -H -o value chyves:dataset_role $pool/chyves/.config )

		# Spider through guests
		for g in $guests; do

			# Poll variables for size. Use chyves property for guest and volsize for disks.
			if [ -z "$(echo "$g" | grep -E -v 'disk')" ]; then
				local size="$( zfs get -H -o value volsize $pool/chyves/guests/$g )"
			else
				local size="$( zfs get -H -o value usedbychildren $pool/chyves/guests/$g )"
			fi

			# Poll remaining variables for common section
			local cpu="$( zfs get -H -o value chyves:cpu $pool/chyves/guests/$g )"
			local ram="$( zfs get -H -o value chyves:ram $pool/chyves/guests/$g )"

			# Print common section (guest, size, cpu, raml)
			printf "%s^%s^%s^%s^%s" "$g" "$size" "$cpu" "$ram" "$pool"

			# Print dataset role section
			[ -n "$(echo "$flags" | grep -E 'r|a')" ] && printf "^%s" "$dataset_role"

			# Get variable and print for verbose section (os, loader, tap, con)
			if [ -n "$(echo "$flags" | grep -E 'v|a')" ]; then
				local os="$(zfs get -H -o value chyves:os $pool/chyves/guests/$g)"
				local loader="$(zfs get -H -o value chyves:loader $pool/chyves/guests/$g)"
				local tap="$(zfs get -H -o value chyves:tap $pool/chyves/guests/$g)"
				local con="$(zfs get -H -o value chyves:con $pool/chyves/guests/$g)"

				printf "^%s^%s^%s^%s" "$os" "$loader" "$tap" "$con"
			fi

			# Get information, set variables, and print for status section (VMM, Running, rcboot)
			if [ -n "$(echo "$flags" | grep -E 's|a')" ]; then
				local _vmm_status=$( __check_vmm_alocated $g -h  )
				local _bhyve_status=$( __check_bhyve_process_running $g -h )
				local _rcboot_priority=$( __display_rcboot_priority $pool $g )

				printf "^%s^%s^%s" "$_vmm_status" "$_bhyve_status" "$_rcboot_priority"
			fi

			# Get template information
			if [ -n "$(echo "$flags" | grep -E 't|a')" ]; then
				local template="$(zfs get -H -o value chyves:template $pool/chyves/guests/$g)"
				if [ $template = 'template' ]; then
					template="YES"
				else
					template="NO"
				fi

				printf "^%s" "$template"
			fi

			# Print description if flag set
			if [ -n "$(echo "$flags" | grep -E 'd|a')" ]; then
				local description="$(zfs get -H -o value chyves:description $pool/chyves/guests/$g)"
				printf "^%s" "$description"
			fi

			# Print notes property if flag set
			if [ -n "$(echo "$flags" | grep -E 'n|a')" ]; then
				local notes="$(zfs get -H -o value chyves:notes $pool/chyves/guests/$g)"
				printf "^%s" "$notes"
			fi

			# Print new line for next guest.
			printf "\n"
	  done
	done
	) | column -ts^ | \
	(
		if [ -n "$(echo "$flags" | grep 'l')" ]
		then
			less
		else
			cat
		fi
	)
}

# Handles fetch, rename, delete, list for Firmware, ISO, and some guests resources
__resource_functions() {
	local _function="$1"
	local _subfunction="$2"
	local _arg3="$3"			# URL|File-Path\File-Name|Firmware-Name
	local _arg4="$4"			# Rename-Name
	local _prim_pool=$_PRIMARY_POOL

	# Sets the variable to use to for the resource
	if [ "$_function" = "firmware" ]; then
		local _resource_name="Firmware"
	elif [ "$_function" = "iso" ]; then
		local _resource_name="ISO"
	elif [ "$_function" = "guest" ]; then
		local _resource_name="guests"
	elif [ "$_function" = "disk" ]; then
		local _resource_name="guests/$_arg4/disk$_arg5"
	fi

	if [ "$_subfunction" = "fetch" ]; then
		local _URL=$_arg3
		local _file_name="$(basename $_URL)"

		# If file ends with .gz|.xz do not use the extension as the folder name.
		if [ -n "$( echo "$_URL" | grep -E "\.gz$" )" ]; then
			local _folder_name=$(basename $_file_name .gz)
		elif [ -n "$( echo "$_URL" | grep -E "\.xz$" )" ]; then
			local _folder_name=$(basename $_file_name .xz)
		else
			local _folder_name=$_file_name
		fi

		# Check to see if file is on a remote source
		if [ -n "$(echo "$_URL" | grep -E '^http|^ftp')" ]; then
			echo "Creating ZFS dataset: $_prim_pool/chyves/$_resource_name/$_folder_name"
			zfs create $_prim_pool/chyves/$_resource_name/$_folder_name

			# Remote ISOs are downloaded using fetch and hash checked.
			if [ "$_function" = "iso" ]; then
				echo "Please enter a supported hash checksum for '$_file_name':"
				read -p "Supported cryptographic hash function are (md5|sha1|sha256|sha512|null): " _user_supplied_hash </dev/tty

				echo "Downloading $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/..."
				fetch $_URL -o /chyves/$_resource_name/$_folder_name

				local _hash_length=$( echo $_user_supplied_hash | wc | awk '{ print $3 }' )
				case "$_hash_length" in
					33)     local _calcd_chksum=$( md5 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=MD5
					;;
					41)     local _calcd_chksum=$( sha1 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA1
					;;
					65)     local _calcd_chksum=$( sha256 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA256
					;;
					129)    local _calcd_chksum=$( sha512 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA512
					;;
					*)      local _calcd_chksum=""
					        local _hash_type="Unsupported hash string given. Please contact the chyves developers to have this hash function added."
				esac

				# Check if hash sums match
				if [ -z "$_user_supplied_hash" ]; then
					echo "All that is necessary for the triumph of evil is that good (wo)men do nothing..."
					echo "...like check their downloaded ISO images against a known hash checksum."
					echo "No hash checksum given, good luck with your potentially corrupt or manipulated ISO, you facilitator of evil."
				elif [ "$_calcd_chksum" = "$_user_supplied_hash" ]; then
					echo "$_hash_type hashes matched."
				else
					echo "Hashes did not match for '$_file_name':"
					echo "Supplied hash:            $_user_supplied_hash"
					echo "Reason for hash mismatch: $_hash_type"
					echo "It is recommended to delete '$_file_name', download it again, and supply a supported hash checksum."
					__resource_functions iso delete "$_folder_name"
				fi

			# Downloads remote firmware
			else
				echo "Downloading $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/..."
				fetch $_URL -o /chyves/$_resource_name/$_file_name
			fi

		# Local file copies only.
		else
			echo "Creating ZFS dataset: $_prim_pool/chyves/$_resource_name/$_folder_name"
			zfs create $_prim_pool/chyves/$_resource_name/$_folder_name
			echo "Copying $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/"
			cp $_URL /chyves/$_resource_name/$_folder_name
		fi

		# Decompress resource if ending in .gz|.xz
		# These programs delete the original files after decompression
		if [ -n "$( echo "$_file_name" | grep -E "\.gz$" )" ]; then
			echo "Decompressing .gz file."
			gunzip -d /chyves/ISO/$_folder_name/$_file_name
		elif [ -n "$( echo "$_file_name" | grep -E "\.xz$" )" ]; then
			echo "Decompressing .xz file."
			xz -d /chyves/ISO/$_folder_name/$_file_name
		else
		fi

		# Checks to see if resource exists now.
		if [ -e /chyves/ISO/$_folder_name/$_folder_name ]; then
			echo "$_folder_name sucessfully imported as a chyves $_resource_name resource."
		else
			echo "Operation unsucessful: delete the dataset and try again."
			__resource_functions $_function delete "$_folder_name"
		fi
	elif [ "$_subfunction" = "rename" ]; then
		# <INSERT> check to verify dataset is valid  __verify_valid_dataset "$pool" "$_resource_type" "$name"
		# <INSERT> check to verify target dataset does not exist __verify_valid_dataset "$pool" "$_resource_type" "$name" -n
		[ "$_arg3" = "$_arg4" ] && __fault_detected_exit "Can not rename $_resource_name from $_arg3 to $_arg4"
		read -p "Do you want to rename firmware from '$_arg3' to '$_arg4' [y/N]? " _rename_or_no </dev/tty
		case "$_rename_or_no" in
			y|Y|yes)   mv -f /chyves/$_resource_name/$_arg3/$_arg3 /chyves/$_resource_name/$_arg3/$_arg4
			           zfs rename $_prim_pool/chyves/$_resource_name/$_arg3 $_prim_pool/chyves/$_resource_name/$_arg4
			;;
			*) echo "${_resource_name}: '$_arg3' not renamed."
		esac
	elif [ "$_subfunction" = "delete" ]; then
		# <INSERT> check to verify dataset is valid  __verify_valid_dataset "$pool" "$_resource_type" "$name"
		read -p "[WARNING] Do you want to delete ${_resource_name}: '$_arg3' [y/N]? " _delete_or_no </dev/tty
		case "$_delete_or_no" in
			y|Y|yes)   zfs destroy -rR $_prim_pool/chyves/$_resource_name/$_arg3
			           exit
			;;
			*) echo "${_resource_name}: '$_arg3' not deleted."
		esac
	elif [ "$_subfunction" = "list" ] && [ "$_function" = "firmware" ]; then
		__list "firmwares"
	elif [ "$_subfunction" = "list" ] && [ "$_function" = "iso" ]; then
		__list "iso"
	fi
}

# Create guest
__create() {
	local name="$1"
	local size="$2"
	local pool="$3"
	__verify_valid_pool "$pool" -c
	local description=$( echo "Created on $(date | sed -e 's/ /_/g')" )

	# Get default values as set by .defaults on primary pool
	local def_size="$(zfs get -H -o value chyves:size $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_cpu="$(zfs get -H -o value chyves:cpu $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_ram="$(zfs get -H -o value chyves:ram $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_persist="$(zfs get -H -o value chyves:persist $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_rcboot="$(zfs get -H -o value chyves:rcboot $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_loader="$(zfs get -H -o value chyves:loader $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_os="$(zfs get -H -o value chyves:os $_PRIMARY_POOL/chyves/guests/.defaults)"
	local def_bargs="$(zfs get -H -o value chyves:bargs $_PRIMARY_POOL/chyves/guests/.defaults)"
	local _disk_options="$( __create_zvol_disk_options_string )"
	local _next_tap="$( __get_next_tap )"
	local _next_con="$( __get_next_console )"

	# If size not declared in command line, use .default's
	if [ -z $size ]; then
		local size="$def_size"
	fi

	# If [pool] not set use primary pool
	if [ -z "${pool}" ]; then
		local pool="${_PRIMARY_POOL}"
	fi

	echo "Creating $name..."
	zfs create $pool/chyves/guests/$name
	zfs create -V $size $_disk_options $pool/chyves/guests/$name/disk0
	zfs set chyves:ram=$def_ram $pool/chyves/guests/$name
	zfs set chyves:cpu=$def_cpu $pool/chyves/guests/$name
	zfs set chyves:tap=tap$_next_tap $pool/chyves/guests/$name
	zfs set chyves:con=nmdm$_next_con $pool/chyves/guests/$name
	zfs set chyves:persist=$def_persist $pool/chyves/guests/$name
	zfs set chyves:rcboot=$def_rcboot $pool/chyves/guests/$name
	zfs set chyves:loader=$def_loader $pool/chyves/guests/$name
	zfs set chyves:os=$def_os $pool/chyves/guests/$name
	zfs set chyves:description="$description" $pool/chyves/guests/$name
	zfs set chyves:bargs=$def_bargs $pool/chyves/guests/$name
	zfs set chyves:uuid=$_UUID_GENERAL_USE $pool/chyves/guests/$name
}

# Install guest
__install() {
	local name="$1"
	local iso="$2"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	__verify_all_kernel_modules
	local dataset="$pool/chyves/guests/$name"
	# Check if guest exists
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running )" ]; then
			local ram="$(zfs get -H -o value chyves:ram $dataset)"
			local con="$(zfs get -H -o value chyves:con $dataset)"
			local cpu="$( __get_liar_cpu_value $dataset )"
			local uuid="$(zfs get -H -o value chyves:uuid $dataset)"
			local bargexist="$(zfs get -H -o value chyves:bargs $dataset)"
			local bargs="$(echo $bargexist | sed -e 's/_/ /g')"

			echo "Installing $name..."
			# Set install prop
			zfs set chyves:install=yes $pool/chyves/guests/$name
			# Load from CD
			__load "$name" "/chyves/ISO/$iso/$iso"
			# Prepare and start guest
			pci="$(__prepare_guest $name) ahci-cd,/chyves/ISO/$iso/$iso"
			local pci_args=$(__get_bhyve_cmd "$pci" )
			[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $cpu $bargs -U $uuid -m $ram $pci_args -lcom1,/dev/${con}A chy-$name"
			bhyve -c $cpu $bargs -U $uuid -m $ram $pci_args -lcom1,/dev/${con}A chy-$name &
		else
			echo "Guest is already running."
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Load guest
__load() {
	local name="$1"
	local media="$2"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	__verify_all_kernel_modules
	local _path="$( __get_path_for_guest_dataset "$name" "$pool" )"
	local dataset="${pool}/chyves/guests/${name}"
	local disk="${pool}/chyves/guests/${name}/disk0"
	local ram="$(zfs get -H -o value chyves:ram $dataset)"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	local loader="$(zfs get -H -o value chyves:loader $dataset)"
	local install="$(zfs get -H -o value chyves:install $dataset)"
	local os="$(zfs get -H -o value chyves:os $dataset)"
	local autogrub="$(zfs get -H -o value chyves:autogrub $dataset)"
	local bargexist="$(zfs get -H -o value chyves:bargs $dataset)"
	local bargs="$(echo $bargexist | sed -e 's/_/ /g')"
	#Testing if -S is in the bargs settings. If then pass -S to bhyveload.
	local test_for_wire_memory="-S"
	case $bargs in
		*${test_for_wire_memory}*) local wire_memory="-S" ;;
		*) local wire_memory="" ;;
	esac
	if [ $loader = "grub-bhyve" ]; then
		__verify_binary_available "grub-bhyve"
		if [ $install = "yes" ]; then
			if [ $os = "openbsd59" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 (cd0)/5.9/amd64/bsd.rd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd58" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 (cd0)/5.8/amd64/bsd.rd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd57" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 (cd0)/5.7/amd64/bsd.rd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "netbsd" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'knetbsd -h -r cd0a (cd0)/netbsd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "debian" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r cd0  -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "d8lvm" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r cd0 -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "centos6" ] || [ $os = "centos7" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'linux (cd0)/isolinux/vmlinuz\ninitrd (cd0)/isolinux/initrd.img\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "arch" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'linux (cd0)/arch/boot/x86_64/vmlinuz archisobasedir=arch archisolabel=ARCH_'$(date +%Y%m)' ro\ninitrd (cd0)/arch/boot/x86_64/archiso.img\nboot\n' > $_path/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "gentoo" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'linux (cd0)/isolinux/gentoo root=/dev/ram0 init=/linuxrc  dokeymap looptype=squashfs loop=/image.squashfs  cdroot \ninitrd (cd0)/isolinux/gentoo.igz\nboot\n' > $_path/grub.cfg
				grub-bhyve $wire_memory -m $_path/device.map -r host -d $_path -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "custom" ]; then
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			else
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r cd0 -c /dev/${con}A -M $ram chy-$name
			fi
		elif [ $install = "no" ]; then
			if [ $os = "openbsd59" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd58" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "openbsd57" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'kopenbsd -h com0 -r sd0a (hd0,openbsd1)/bsd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "netbsd" ]; then
				__create_device_map "$_path" "$disk" "$media"
				printf 'knetbsd -h -r wd0a (hd0,msdos1)/netbsd\nboot\n' > ${_path}/grub.cfg
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "debian" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r hd0,msdos1 -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "d8lvm" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "centos6" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r hd0,msdos1 -d /grub -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "centos7" ]; then
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r hd0,msdos1 -d /grub2 -c /dev/${con}A -M $ram chy-$name
			elif [ $os = "custom" ]; then
				grub-bhyve $wire_memory -m ${_path}/device.map -r host -d ${_path} -c /dev/${con}A -M $ram chy-$name
			else
				__create_device_map "$_path" "$disk" "$media"
				grub-bhyve $wire_memory -m ${_path}/device.map -r hd0,msdos1 -c /dev/${con}A -M $ram chy-$name
			fi
		fi
	else
		bhyveload $wire_memory -m $ram -d $media -c /dev/${con}A chy-$name
	fi
}

# Boot guest
__boot() {
	local name="$1"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"
	__verify_all_kernel_modules
	# runmode (runonce/persist)
	#   0 = once
	#   1 = persist regular (stop if guest is powering off)
	#   2 = always persist (start again even if guest is powering off)
	local runmode="$2"
	local pci="$3"
	local ram="$(zfs get -H -o value chyves:ram $dataset)"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	local cpu="$( __get_liar_cpu_value $dataset )"
	local uuid="$(zfs get -H -o value chyves:uuid $dataset)"
	local persist="$(zfs get -H -o value chyves:persist $dataset)"
	local bargexist="$(zfs get -H -o value chyves:bargs $dataset)"
	local bargs="$(echo $bargexist | sed -e 's/_/ /g')"
	# Set install prop
	zfs set chyves:install=no $dataset
	# Generate list of bhyve -s commands for all devices
	local pci_args=$(__get_bhyve_cmd "$pci" )
	# Handle the starting of the guest inside a spawned subshell so the guest
	# can be restarted automatically if the guest reboots or crashes
	local runstate="1"
	(
		while [ $runstate = "1" ]
		do
			__load "$name" "/dev/zvol/$dataset/disk0"
			[ "$_DEVELOPER_MODE" != "off" ] && echo "bhyve -c $cpu $bargs -U $uuid -m $ram $pci_args -lcom1,/dev/${con}A chy-$name"
			bhyve -c $cpu $bargs -U $uuid -m $ram $pci_args -lcom1,/dev/${con}A chy-$name &
			local vmpid=$!
			wait $vmpid
			vmrc=$?
			sleep 5
			if [ $runmode == "0" ]; then
				runstate="0"
			elif [ $vmrc == "1" ] && [ $runmode != 2 ]; then
				# VM has been powered off
				runstate="0"
			else
				if [ $(zfs get -H -o value chyves:persist $dataset) != 1 ]; then
					runstate="0"
				fi
			fi
		done
		bhyvectl --destroy --vm=chy-$name
		# Resetting the flag so that a vm which we stopped by abusing zfs set/get
		# as as an IPC mechanism is persistent again next time we start it
		if [ ! -z $persist ]; then
			zfs set chyves:persist="$persist" $dataset
		fi
	) &
}

__prepare_guest() {
	local name="$1"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"
	local pci="$(__get_zfs_pcidev_conf $dataset)"
	# Setup tap if needed
	local listtap="$(zfs get -H -o value chyves:tap $dataset)"
	for tap in $(echo $listtap | sed -n 1'p' | tr ',' '\n'); do
		if [ $tap ] && [ $tap != "-" ]; then
			local tapif="$(ifconfig -l | tr ' ' '\n' | grep -F -w $tap)"
			if [ -z $tapif ]; then
				# create tap interface
				ifconfig $tap create descr "chyves-$name"
				ifconfig bridge0 addm $tap
			fi
			# Add a virtio-net pci device for the tap
			local mac="$(zfs get -H -o value chyves:mac_$tap $dataset)"
			if [ $mac = "-" ]; then
				pci="$pci virtio-net,$tap"
			else
				pci="$pci virtio-net,${tap},mac=${mac}"
			fi
		fi
        done
	#Add disk as second PCI device
	pci="ahci-hd,/dev/zvol/$dataset/disk0 $pci"
	#Add Hostbridge and lpc as the first PCI devices
	pci="hostbridge lpc $pci"
	# return the list of pci devices
	echo $pci
}

# Start guest (combine load and boot)
__start() {
	local name="$1"
	local flag="$2"
	local pool=$( __get_pool_for_guest "$name" )
	__verify_valid_pool "$pool"
	__verify_valid_guest "$name" "$pool" -s
	__verify_all_kernel_modules
	local dataset="$pool/chyves/guests/$name"
	local pci=""
	local runmode="1"
	local loader="$(zfs get -H -o value chyves:loader $dataset)"
	local _os="$(zfs get -H -o value chyves:os $dataset)"

	# Check for special handling.
	if [ "${_CPU_MISSING_UG}" ] && [ "${_os}" != "freebsd" ]; then
	 __get_cpu_section_from_dmesg
	 __fault_detected_exit "Missing CPU feature UG, can only start guests with os=freebsd."
	elif [ $loader = "uefi" ]; then
		__uefi "$name" "null.iso"
		exit
	elif [ $loader = "grub-bhyve" ]; then
		__verify_binary_available "grub-bhyve"
	fi

	# Check to make sure guest isn't running
	if [ -z "$( __check_bhyve_process_running )" ]; then
		case "$flag" in
			-s)  runmode="0"    # single - start only once
			;;
			-a)  runmode="2"    # always - persist regardless what
			;;
			*)   runmode="1"    # persist - persists until guest is powering off
			;;
		esac
		echo "Starting $name... (Takes 15 seconds for FreeBSD guests)"
		# Prepare and boot guest
		pci="$(__prepare_guest $name)"
		__boot "$name" "$runmode" "$pci"
	fi
}

# Start a UEFI enabled bhyve instance.
# This is experimental, use with caution.
__uefi() {
	local name="$1"
	local media="$2"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	__verify_all_kernel_modules
	[ "${_CPU_MISSING_UG}" ] && __get_cpu_section_from_dmesg && __fault_detected_exit "This CPU lacks the 'UG' feature of EPT. UEFI guests are disabled."
	local dataset="${pool}/chyves/guests/${name}"
	local ram="$(zfs get -H -o value chyves:ram $dataset)"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	local cpu="$(zfs get -H -o value chyves:cpu $dataset)"
	local fw="$(zfs get -H -o value chyves:fw $dataset)"
	local tap="$(zfs get -H -o value chyves:tap $dataset)"
	local uuid="$(zfs get -H -o value chyves:uuid $dataset)"
	local bargs="$(zfs get -H -o value chyves:bargs $dataset | sed -e 's/_/ /g')"
	local pool="$(zfs list -H -t volume -o name | grep chyves/guests/$name | cut -d '/' -f1)"
	# Create tap if needed
	# check to see if tap is already created before attempting to create new tap interface
	local tapif="$(ifconfig -l | tr ' ' '\n' | grep -F -w $tap)"
	if [ -z $tapif ]; then
		# create tap interface
		ifconfig $tap create descr "chyves-$name"
		ifconfig bridge0 addm $tap
	fi
	# Make sure everything is in order...
	if [ $fw = '-' ]; then
		echo "You must set a firmware file property to use UEFI..."
	fi
	if [ -z $media ]; then
		echo "You must enter at least a zero byte ISO for some OSs..."
		echo "EX: chyves uefi winguest null.iso"
	fi
	# Check if guest exists
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running )" ]; then
			# The good stuff...
			if [ "$_DEVELOPER_MODE" != "off" ]; then
			echo "bhyve -c $cpu $bargs -m $ram "
			echo "        -s 0,hostbridge "
			echo "        -s 3,ahci-cd,/chyves/ISO/$media/$media "
			echo "        -s 4,ahci-hd,/dev/zvol/$dataset/disk0,sectorsize=512 "
			echo "        -s 10,virtio-net,$tap "
			echo "        -s 31,lpc "
			echo "        -l com1,/dev/${con}A "
			echo "        -l bootrom,/chyves/Firmware/$fw/$fw "
			echo "        -U $uuid "
			echo "        chy-$name"
			fi
			bhyve -c $cpu $bargs -m $ram \
			        -s 0,hostbridge \
			        -s 3,ahci-cd,/chyves/ISO/$media/$media \
			        -s 4,ahci-hd,/dev/zvol/$dataset/disk0,sectorsize=512 \
			        -s 10,virtio-net,$tap \
			        -s 31,lpc \
			        -l com1,/dev/${con}A \
			        -l bootrom,/chyves/Firmware/$fw/$fw \
			        -U $uuid \
			        chy-$name &
		else
			echo "Guest is already running."
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Gracefully stop a guest
__stop() {
	local name="$1"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local pid=$(pgrep -fx "bhyve: chy-$name")
	echo "Stopping $name..."
	kill $pid
}

# Force kill -9 everyting matching $name and destroy
# THIS WILL KILL EVERYTHING MATCHING $NAME
__forcekill() {
	local name="$1"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"

	# Display current running processes for guest
	__list processes $name | grep -v "/bin/sh /usr/local/sbin/chyves forcekill"

	read -p "[WARNING] Are you sure you want to kill all processes above? [y/N]? " an </dev/tty
	case "$an" in
		y|Y|yes) 	local pids="$(pgrep -f $name)"
			for apid in "$pids"; do
				kill -9 $apid
			done
			bhyvectl --force-poweroff --vm=chy-$name
			bhyvectl --destroy --vm=chy-$name
		;;
		*) echo "No action taken."
	esac
}

# Gracefully shut down all guests via ACPI (Does not destroy)
__scram() {
	echo "Shutting down all guests..."
	local pids="$(pgrep -f chy-)"
	for apid in "$pids"; do
		kill $apid
	done
	wait_for_pids $pids
}

# Destroy guest
__destroy() {
	local name="$1"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	echo "Destroying $name..."
	bhyvectl --force-poweroff --vm=chy-$name
	bhyvectl --destroy --vm=chy-$name
}

# Set ZFS properties
__set() {
	local name="$3"
	local _count=1 # Counter needed for setting multiple guests in one go.
	[ -n "$( echo "$name" | grep '=' )" ] && local name="$2" && echo "The correct syntax is 'chyves set $3 $2', correcting syntax for temporary backwards compatibility."
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"
	shift 1
	for arg in "$@"; do

		# Allows for setting multiple guests properties in one command.
		# As soon as the third parameter the next guest could be specified.
		# Eg: chyves set ram=1G guest1
		if [ -n "$( echo "$arg" | grep -v '=' )" ] && [ "$_count" -gt "2" ]; then
			local name="$arg"
		fi

		# Need to skip guest name iteration
		[ "${arg}" = "${name}" ] && continue

		local prop="$(echo $arg | cut -d '=' -f1)"
		local val="$(echo $arg | cut -d '=' -f2)"
		if [ $prop = "bargs" ]; then
			local sval="$(echo $val | cut -d '"' -f2 | sed -e 's/ /_/g')"
			echo "Setting $name $prop=$val..."
			zfs set chyves:$prop=$sval $dataset
		elif [ $prop = "description" ]; then
			local sval="$(echo $val | cut -d '"' -f2)"
			echo "Setting $name $prop=$val..."
			zfs set "chyves:$prop=$sval" $dataset
		else
			echo "Setting $name $prop=$val..."
			zfs set chyves:$prop=$val $dataset
		fi

		# Needed for multi-guest set support
		local _count=$( expr $_count + 1 )
	done
}

# Get ZFS props
__get() {
	local prop="$1"
	local name="$2"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"

	if [ "$prop" = "all" ]; then
		echo "Getting all $name's chyves properties..."
		zfs get -o property,value all $dataset | grep chyves: | sort | sed -e 's/chyves://g'
	else
		echo "Getting $name's property \"$prop\"..."
		zfs get -H -o value chyves:$prop $dataset
	fi
}

# Remove a PCIDEV property
__rmpci() {
	local flagone="$1"          # -f | name
	local flagtwo="$2"          # name | pcidev:N
	local flagthree="$3"        # pcidev:N | null
	if [ $flagone = "-f" ]; then
		echo "Removing $flagthree from $flagtwo"
		local pciprop="$(echo "$flagthree" | grep pcidev:)"
		local pool="$( __get_pool_for_guest "$name" )"
		__verify_valid_guest "$flagtwo" "$pool"
		local dataset="${pool}/chyves/guests/${name}"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r chyves:$flagthree $dataset
		fi
	else
		local pciprop="$(echo "$flagtwo" | grep pcidev:)"
		local pool="$( __get_pool_for_guest "$flagone" )"
		__verify_valid_guest "$flagone" "$pool"
		local dataset="${pool}/chyves/guests/${name}"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo [Y/N]? " an </dev/tty
			case "$an" in
				y|Y) zfs inherit  -r chyves:$flagtwo $dataset
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Add a new disk to guest
__add() {
	local name="$1"
	local size="$2"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"
	# Find the last disk number and increment one
	local lastdisk="$(zfs list -H | grep chyves/guests/$name | grep disk | cut -d '/' -f4 | cut -f1 | \
		sort -V | cut -c5- | tail -n1)"
	local newdisk="$(expr $lastdisk + 1)"
	echo "Creating new zvol for $name..."
	zfs create $newpool/chyves/guests/$name 2> /dev/null
	zfs create -V $size -o volmode=dev $newpool/chyves/guests/$name/disk$newdisk
	# Find the last pcidev and increment by one
	local lastpci="$(zfs get -H all | grep chyves/guests/$name | grep pcidev | cut -f2 | \
		cut -d ':' -f3 | sort -V | tail -n1)"
	if [ -z $lastpci ]; then
		local newpci='1'
	else
		local newpci="$(expr $lastpci + 1)"
	fi
	zfs set chyves:pcidev:$newpci=ahci-hd,/dev/zvol/$newpool/chyves/guests/$name/disk$newdisk $dataset
}

# Remove disk from guest
__remove() {
	local flagone="$1"          # -f | name
	local flagtwo="$2"          # name | diskN
	local flagthree="$3"        # diskN | null
	if [ $flagone = "-f" ]; then
		echo "Removing $flagthree from $flagtwo"
		local pool="$(zfs list -H -o name | grep $flagtwo | grep $flagthree | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagtwo | grep pcidev | grep $flagthree | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r $pciprop $pool/chyves/guests/$flagtwo
			zfs destroy $pool/chyves/guests/$flagtwo/$flagthree
		fi
	else
		local pool="$(zfs list -H -o name | grep $flagone | grep $flagtwo | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagone | grep pcidev | grep $flagtwo | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo from $flagone [Y/N]? " an </dev/tty
			case "$an" in
				y|Y)	zfs inherit  -r $pciprop $pool/chyves/guests/$flagone
					zfs destroy $pool/chyves/guests/$flagone/$flagtwo
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Resize a disk
__resize(){
	local name="$1"
	local disk="$2"
	local size="$3"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"
	# Check if guest exists
	echo "Resizing $disk to $size"
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running )" ]; then
			zfs set volsize=$size $pool/chyves/guests/$name/$disk
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# List disks for a guest
__disks() {
	local name="$1"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"
	(
	echo "Listing disks for $name..."
	printf "diskN\tSize\n"
	zfs list -H -o name,volsize | grep -E "chyves.*$name.*disk" | \
		cut -d '/' -f4
	) | column -t
}

# Snapshot a guest
__snapguest() {
	local fullsnap="$1"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	echo "Taking snapshot $fullsnap"
	zfs snap -r $pool/chyves/guests/$fullsnap
}

# Rollback guest
__rollguest() {
	local fullsnap="$1"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local snap="$(echo $fullsnap | cut -d '@' -f2)"
	local disklist="$(zfs list -H | grep chyves/guests/$name | grep disk | \
				cut -f1 | cut -d '/' -f4-)"
	# Check if guest exists
	echo "Rolling back to $fullsnap"
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running )" ]; then
			zfs rollback -rR $pool/chyves/guests/$fullsnap
			for disk in $disklist ; do
				zfs rollback -rR $pool/chyves/guests/$name/$disk@$snap
			done
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Clone a guest
__cloneguest() {
	local flag="$1"
	local name="$2"
	local cname="$3"
	local description=$( echo "Cloned on $(date | sed -e 's/ /_/g')" )
	local pool="$(zfs list -H -t volume | grep "chyves/guests/$name/disk0" | cut -d '/' -f 1 | head -n1)"
	# Check if guest exists
	echo "Cloning $name to $cname"
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
			# Take snapshot
			zfs snap -r $pool/chyves/guests/$name@$cname
			# zfs send that snap and desendants then receive to cname
			zfs send -R $pool/chyves/guests/$name@$cname | \
			zfs recv $pool/chyves/guests/$cname
			# clean up
			zfs destroy -rR $pool/chyves/guests/$name@$cname
			zfs destroy -rR $pool/chyves/guests/$cname@$cname
			zfs set chyves:description=$description $pool/chyves/guests/$cname
			# change con and tap properties to next available if -r is specified
			if [ "$flag" == "-r" ]; then
        local tap="$( __get_next_tap )"
        local con="$( __get_next_console )"
				zfs set chyves:tap=tap$tap $pool/chyves/guests/$cname
				zfs set chyves:con=nmdm$con $pool/chyves/guests/$cname
			fi

	else
		echo "Not a valid guest name"
	fi
}

# Export Guest
__exportguest() {
	local name="$1"
	local pool="$(zfs list -H -t volume | grep chyves/guests/$name | grep disk0 | cut -d '/' -f 1 | head -n1)"
	local disklist="$(zfs list -H | grep "chyves/guests/$name/disk" | cut -f1 | cut -d '/' -f4-)"
	# Check if guest exists
	echo "Exporting $name. Note this may take some time depending on the size."
	if [ -d /chyves/$pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running )" ]; then
			# Create /tmp/chyves/guests/$name
			echo "Creating temp directory..."
			mkdir -p /tmp/chyves/guests/$name
			# Export Properties to file
			echo "Exporting properties..."
			zfs get -H -o property,value all $pool/chyves/guests/$name | grep chyves: | sort | \
				sed -e 's/chyves://g' | sed -e 's/	/=/g' > /tmp/chyves/guests/$name/properties.ucl
			# Write disks to file
			echo "Exporting disks..."
			for disk in $disklist ; do
				dd if=/dev/zvol/$pool/chyves/guests/$name/$disk of=/tmp/chyves/guests/$name/${disk}.img bs=1M
			done
			# Compress and add to archive
			echo "Compressing to archive..."
			tar -czf /chyves/guests/$name/$name.tar.gz -C /tmp/chyves/guests/$name/ .
			# Remove /tmp/chyves/
			echo "Removing temp directory..."
			rm -fr /tmp/chyves
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Run console
__console() {
	local name="$1"
	local _flag="$2"
	local pool="$( __get_pool_for_guest "$name" )"
	__verify_valid_guest "$name" "$pool"
	local dataset="${pool}/chyves/guests/${name}"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	echo "Starting console on $name..."
	echo "~~. to escape console [uses cu(1) for console]"
	cu -l /dev/${con}B -s 9600

}

# Reset all consoles. This kills the cu(1)
__conreset() {
	__list con
	echo "Processes to kill:"
	ps -aux | grep cu
	read -p "[WARNING] Are you sure you want to kill all processes cu console processes above? [y/N]? " an </dev/tty
	case "$an" in
	  y|Y|yes) killall cu
	  ;;
	  *) echo "No action taken."
	esac
}

# Print help page
__help() {
__version
cat << 'EOT'

chyves
  version
  setup pool=<pool> kmod=<0|1> net=<interface-name>
  list [iso|firmwares|snapshots|.config|.defaults|processes|<property-name>]
  list tap active
  list .config [<pool>|primary]
  list processes [<name>]
  info [-rvstdnakgil|-h]
  iso {list|fetch|rename|delete}
  iso list
  iso fetch {http-URL|ftp-URL|local-path}
  iso rename <oldname> <newname>
  iso delete <name>
  firmware {list|fetch|rename|delete}
  firmware list
  firmware fetch {http-URL|ftp-URL|local-path}
  firmware rename <oldname> <newname>
  firmware delete <name>
  create <name> [size] [pool]
  install <name> <iso-file>
  start <name> [-s | -a]
  stop <name>
  forcekill <name>
  scram
  destroy <name>
  rename <name> <newname>
  delete <name>
  set <property1>=<value> {<name>|.defaults} [<property2>=<value>]...
  get {<property>|all} <name>
  rmpci [-f] [name] [pcidev:N]
  add [name] [size]
  remove [-f] [name] [diskN]
  resize [name] [diskN] [size]
  disks [name]
  snap <name>[@<snapshotname>]
  roll <name>[@<snapshotname>]
  clone [-c | -r] <name> <clonename>
  export <name>
  console <name> -t
  conreset
  help

Syntax nomenclature:
 subcommand       - Text without brackets are assumed to be required, "list" in
                    this case.
 [optional]       - An optional field
 [optional|list]  - An optional list, valid if not used
 {require|list}   - A require list where one option much be used
 <user-input>     - User supplied input field. Required when not contain in [ ]
 [-abcdefg]       - An optional field but must start with a "-" and followed by
                    any combination, in any order. Eg. "-gca" is valid.
 name             - chyves guest name

EOT
}

__preflight_check "$1"

__parse_cmd "$@"
