#!/bin/sh

# Copyright (c) 2015, pr1ntf (Trent Thompson) All rights reserved.
# Copyright (c) 2016, Justin D Holcomb All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#### Library
# The chyves project split the main binary (this file) into library files with
# the blame and history maintained in May of 2016. Each library file contains
# functions that only handle one aspect of chyves. This was done for the
# developers' sanity. Below is a table of contents for the functions in each
# library file. This TOC is most helpful for casual, curious users but it should
# also be helpful for developers as well.
#
### Table of Contents:
#
## ../lib/chyves-basics                    ## Functions that are basic to chyves functionality
# __help()                                  # Print help page
# __readonly_cmd()                          # Check to see if supplied command is read-only.
# __parse_cmd_ingress()                     # First stage to process command line parameters for chyves
# __version()                               # Show version
#
## ..lib/chyves-creation                   ## Functions used to create guests in some port or another
# __cloneguest()                            # Clone a guest
# __create()                                # Create guest(s)
# __get_next_console()                      # Return the next console to use
# __get_next_tap()                          # Return the next tap interface to use
# __get_next_vnc_port()                     # Return the next vnc port to use
# __generate_zvol_disk_options_string()     # Creates string used to create ZFS volume for disks
# __set_new_uuid_guest_use()                # Set new UUID in _UUID_GUEST_USE
#
## ../lib/chyves-informational             ## Functions to display information about chyves to the user
# __disks()                                 # List disks for a guest
# __info()                                  # List various aspects of chyves guests, properties, and other resources
# __list()                                  # Display info about all guests.
#
## ../lib/chyves-network                   ## Functions for network related tasks
# __exit_if_tap_locked()                    # Exits if tap is locked by a process/guest
# __get_bridge_members_on_system()          # Get bridge members on system
# __get_bridge_phy_iface_chyves()           # Get outside interface for bridge
# __get_bridge_list_on_chyves()             # Get a list of bridges on chyves
# __get_parent_bridge_for_tap_chyves()      # Get a tap's bridge membership as set in .config as a chyves properties
# __get_iface_list_on_system()              # Get a list of interfaces on system
# __get_parent_guest_for_tap_chyves()       # Get a tap's guest membership
# __get_pid_locking_tap()                   # Get PID on tap
# __get_tap_list_for_bridge_on_chyves()     # Get a list of taps on a bridge in chyves properties
# __network()                               # Network sub-command
# __network_add_dev_to_bridge()             # Adds network device to bridge
# __network_add_phy_to_bridge()             # Adds outside interface to bridge with error handling
# __network_remove_dev_to_bridge()          # Removes network device from bridge
# __verify_tap_not_in_use()                 # Verifies tap is not in use on system
# __verify_vale_system_compat()             # Check if VALE might be possible on system
# __verify_valid_iface_format()             # Verifies interface is in valid format for type.
# __verify_valid_system_iface()             # Verifies interface exists on system
#
## ../lib/chyves-properties                ## Functions that deal with chyves properties
# __get()                                   # Frontend interface to get chyves properties
# __get_corrected_byte_nomenclature()       # Corrects user input when setting RAM properties and size for .defaults
# __load_guest_parameters()                 # Load guest parameters to global variables
# __load_guest_default_parameters()         # Loads .defaults parameters to global variables
# __multi_chyves_zfs_property()             # Backend interface to set and get chyves properties with ZFS
# __set()                                   # Frontend interface to set chyves properties
#
## ../lib/chyves-start-guest               ## Functions for starting guests
# __generate_bhyve_slot_string()            # Generates a bhyve PCI slot string from $1
# __generate_bhyve_custom_pci_string()      # Generates a bhyve slot string for custom PCI devices
# __generate_bhyve_disk_string()            # Generates a bhyve slot string for disks
# __generate_bhyve_net_string()             # Generate bhyve slot string for network devices.
# __generate_bhyve_vnc_string()             # Generates bhyve slot string for UEFI GOP code
# __generate_generic_device_map()           # Creates device.map for guest and places in /chyves/guests/$_guest/device.map
# __generate_grub_bhyve_command()           # Generates grub-bhyve command used to start guest.
# __start()                                 # All inclusive start function
# __verify_iommu_capable()                  # Verify I/O MMU (iommu) for guests using PCI passthrough
#
## ../lib/chyves-updates                   ## Function for checking for updates.
# __check_for_chyves_update                 # Check for chyves updated
#

# Stage 1 global variables (Not dependent on functions or primary pool)
_VERSION=0.0.0                        # Example: v11.6.25 - XXX.YY.ZZZ
_VERSION_LONG="v0.0.0 2016/04/00"     # Example: v11.6.25 2021/12/31
_VERSION_INT="00000000"               # Example: 01106025 XXXYYZZZ
_VERSION_DATASET="0001"
_VERSION_BRANCH=master
_OS=$( sysctl -n kern.ostype )
_OS_VERSION_DATE=$( sysctl -n kern.osreldate )
_OS_VERSION_FREENAS=$( [ -e "/etc/version" ] && cat /etc/version )
_OS_VERSION_REL=$( sysctl -n kern.osrelease )
_OS_VERSION_REV=$( sysctl -n kern.osrevision )
_PROJECT_URL=http://chyves.org
_PROJECT_URL_GIT="https://github.com/chyves/chyves"
_DATE_YMD=$( date +"%Y%m%d" )
_UUID_GENERAL_USE="$(/bin/uuidgen)"
_UUID_GUEST_USE="$(/bin/uuidgen)"
_OLD_VERSION_DATASETS="$(zfs get -H -o name,value -t filesystem -r chyves:dataset_version | grep chyves/.config | grep -v "${_VERSION_DATASET}" )"
_OFFLINE_POOLS_GREP_STRING=$(zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "offline" | cut -d'/' -f1 | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g')
_TEMPLATE_GUESTS_GREP_STRING=$(zfs get -H -o name,value -t filesystem -r chyves:guest_role | grep "chyves/guests" | grep "template" | cut -d'/' -f1 | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g')
_FREEBSD_NET_DRIVERS_GREP_STRING='^bxe[0-9]?[0-9]?$|^de[0-9]?[0-9]?$|^em[0-9]?[0-9]?$|^igb[0-9]?[0-9]?$|^ix[0-9]?[0-9]?$|^ixv[0-9]?[0-9]?$|^ixl[0-9]?[0-9]?$|^ixlv[0-9]?[0-9]?$|^le[0-9]?[0-9]?$|^ti[0-9]?[0-9]?$|^txp[0-9]?[0-9]?$|^vx[0-9]?[0-9]?$|^miibus[0-9]?[0-9]?$|^ae[0-9]?[0-9]?$|^age[0-9]?[0-9]?$|^alc[0-9]?[0-9]?$|^ale[0-9]?[0-9]?$|^bce[0-9]?[0-9]?$|^bfe[0-9]?[0-9]?$|^bge[0-9]?[0-9]?$|^cas[0-9]?[0-9]?$|^dc[0-9]?[0-9]?$|^et[0-9]?[0-9]?$|^fxp[0-9]?[0-9]?$|^gem[0-9]?[0-9]?$|^hme[0-9]?[0-9]?$|^jme[0-9]?[0-9]?$|^lge[0-9]?[0-9]?$|^msk[0-9]?[0-9]?$|^nfe[0-9]?[0-9]?$|^nge[0-9]?[0-9]?$|^nve[0-9]?[0-9]?$|^pcn[0-9]?[0-9]?$|^re[0-9]?[0-9]?$|^rl[0-9]?[0-9]?$|^sf[0-9]?[0-9]?$|^sge[0-9]?[0-9]?$|^sis[0-9]?[0-9]?$|^sk[0-9]?[0-9]?$|^ste[0-9]?[0-9]?$|^stge[0-9]?[0-9]?$|^tl[0-9]?[0-9]?$|^tx[0-9]?[0-9]?$|^vge[0-9]?[0-9]?$|^vr[0-9]?[0-9]?$|^wb[0-9]?[0-9]?$|^xl[0-9]?[0-9]?$|^cs[0-9]?[0-9]?$|^ed[0-9]?[0-9]?$|^ex[0-9]?[0-9]?$|^ep[0-9]?[0-9]?$|^fe[0-9]?[0-9]?$|^sn[0-9]?[0-9]?$|^xe[0-9]?[0-9]?$|^an[0-9]?[0-9]?$|^ath[0-9]?[0-9]?$|^ath_pci[0-9]?[0-9]?$|^ath_hal[0-9]?[0-9]?$|^bwi[0-9]?[0-9]?$|^bwn[0-9]?[0-9]?$|^ipw[0-9]?[0-9]?$|^iwi[0-9]?[0-9]?$|^iwn[0-9]?[0-9]?$|^malo[0-9]?[0-9]?$|^mwl[0-9]?[0-9]?$|^ral[0-9]?[0-9]?$|^wi[0-9]?[0-9]?$|^wpi[0-9]?[0-9]?$'
_KERNEL_MODULES=$(printf "%s\n%s\n%s\n%s\n%s" "vmm" "nmdm" "if_tap" "bridgestp" "if_bridge")
_NUMBER_OF_ALL_GUESTS=$( zfs list -d 3 -r -o name | grep chyves/guests/ | grep -v .defaults | wc -l )
_FORBIDDEN_GUEST_NAMES=".defaults|all|clone|console|create|dataset|delete|destroy|disk|firmware|get|info|iso|list|network|rename|reorder|reset|set|snapshot|start|stop|stop"
_PCI_SLOT_START=4
_OFFLIMIT_PCI_SLOT_NUMS_GREP_STRING='0|3|31'
_LIBRARY_PATH=/usr/local/lib/chyves

##### More global variables set in __preflight_check #####
PATH=${PATH}:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin

# This function gets ran before any other.
__preflight_check() {

	# Load library files
	__load_library_files

	# Checks to see variable is empty as grep needs an arguement and a UUID stastically should not have a collision if there are no pools in an offline role
	if [ -z "$_OFFLINE_POOLS_GREP_STRING" ]; then
	  _OFFLINE_POOLS_GREP_STRING=${_UUID_GENERAL_USE}
	fi

	# Appends ".defaults" to $_TEMPLATE_GUESTS_GREP_STRING
	if [ -z "$_TEMPLATE_GUESTS_GREP_STRING" ]; then
	  _TEMPLATE_GUESTS_GREP_STRING=".defaults"
	else
	  _TEMPLATE_GUESTS_GREP_STRING=$( echo "${_TEMPLATE_GUESTS_GREP_STRING}|.defaults" )
	fi

	# Check for out of date datasets when not running setup.
	if [ ! -z "$_OLD_VERSION_DATASETS" ] && [ "$1" != "setup" ]; then
	  __fault_detected_exit "Out of date chyves\' dataset(s) version found. \nPlease install sysutils/chyves-utils and then run: \nchyves-upgrade"
	fi

	# Check to see if more than one pool has the primary role set.
	if [ "$(zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "primary" | wc -l )" -gt "1" ]; then
		__fault_detected_exit "More than one primary pool set, fix it!"
	fi

	# Check for out of date datasets when not running setup.
	if [ ! -z "$_OLD_VERSION_DATASETS" ] && [ "$1" != "setup" ]; then
		echo "Out of date chyves\' dataset(s) version found."
		echo "Please install sysutils/chyves-utils and then run:"
		echo "chyves-upgrade"
		exit 1
	fi

	# If no sub-command is used, run the help function
	if [ -z "$1" ] ; then
		__help
		exit 0
	fi

	# Check to see if running with elevated credentials
	if [ $(__readonly_cmd "$1") != "0" -a "$(whoami)" != "root" ] ; then
		echo "The $1 command needs root credentials!"
		exit 1
	fi

	# CPU feature check
	# First check to see if EPT/RVI is available then complain if "unrestricted guests" is not found on an Intel CPU.
	if [ -n "$( __get_cpu_section_from_dmesg | grep 'Features2=' | grep 'POPCNT' )" ]; then
		if [ -n "$( __get_cpu_section_from_dmesg | grep 'CPU:' | grep 'Intel' )" ] && [ -z "$( __get_cpu_section_from_dmesg | grep 'VT-x:' | grep 'UG' )" ]; then
			echo "This CPU lacks the 'UG' feature of EPT. This is required by bhyve to run to the full extent."
			echo "Due to this missing CPU feature: a guest is limited to one virtual CPU and starting UEFI guests is disabled."
			echo "See CPU feature flags below:"
			__get_cpu_section_from_dmesg
			# Insert way to disable this warning later on.
			_CPU_MISSING_UG=1
		fi
	else
		__fault_detected_exit "Your CPU lacks the basic feature to run bhyve. For AMD CPUs this means RVI. For Intel CPUs this means EPT."
	fi

	# Stage 2 global variables (Dependent on functions or primary pool)
	__get_primary_pool_name   # Sets $_PRIMARY_POOL
	if [ -z "$_PRIMARY_POOL" ]; then
		echo "Run setup to install chyves dataset on a pool."
		[ "$1" != "setup" ] && __fault_detected_exit "No seriously, run \"chyves setup <ZFS-pool-name>\""
	else
		_DEVELOPER_MODE=$( __multi_chyves_zfs_property                       "get" "dev_mode"                             "primary" ".config" )
		_RESTRICT_NEW_PROPERTY_NAMES=$( __multi_chyves_zfs_property          "get" "restrict_new_property_names"          "primary" ".config" )
		_VLAN_IFACE_BASE_NAME=$( __multi_chyves_zfs_property                 "get" "vlan_iface_base_name"                 "primary" ".config" )
		_TAP_UP_BY_DEFAULT=$( __multi_chyves_zfs_property                    "get" "tap_up_by_default"                    "primary" ".config" )
		_AUTO_LOAD_KERNEL_MODS=$( __multi_chyves_zfs_property                "get" "auto_load_kernel_mods"                "primary" ".config" )
		_CONSOLIDATE_BHYVE_PCI_DEVICES=$( __multi_chyves_zfs_property        "get" "consolidate_bhyve_pci_devices"        "primary" ".config" )
		_CHECK_FOR_UPDATES=$( __multi_chyves_zfs_property                    "get" "check_for_updates"                    "primary" ".config" )
		_CHECK_FOR_UPDATES_TIMEOUT_SECONDS=$( __multi_chyves_zfs_property    "get" "check_for_updates_timeout_seconds"    "primary" ".config" )
		_CHECK_FOR_UPDATES_LAST_CHECK=$( __multi_chyves_zfs_property         "get" "check_for_updates_last_check"         "primary" ".config" )
		_CHECK_FOR_UPDATES_LAST_CHECK_STATUS=$( __multi_chyves_zfs_property  "get" "check_for_updates_last_check_status"  "primary" ".config" )
		_CHECK_FOR_UPDATES_UNIQUE_ID=$( __multi_chyves_zfs_property          "get" "check_for_updates_unique_id"          "primary" ".config" )
		_CHECK_FOR_UPDATES_URL="$_PROJECT_URL_GIT/raw/${_VERSION_BRANCH}/lib/chy-version"
	fi

	if [ "$_TAP_UP_BY_DEFAULT" = yes ]; then
		__verify_kernel_module_loaded if_tap -l
		sysctl net.link.tap.up_on_open=1 > /dev/null 2>&1
	fi
}

# Loads the library files from list contained in $_LIBRARY_PATH and exits if any are missing
__load_library_files() {
	for _lib_file in chyves-basics chyves-creation chyves-informational chyves-network chyves-properties chyves-start-guest chyves-updates
	do
		if [ -e "$_LIBRARY_PATH/$_lib_file" ]; then
			. "$_LIBRARY_PATH/$_lib_file"
		else
			__fault_detected_exit "\n\n\nMissing chyves library file $_lib_file from $_LIBRARY_PATH\n\n\n"
		fi
	done
}

# Function used to exit with a message.
__fault_detected_exit() {
  local message="$1"
  echo "Critical error detected. Exiting for following reason:"
  echo -e "${message}"
  exit 1
}

# Validates if a given pool name exists.
__verify_valid_pool() {
	local _name_to_check="$1"
	local _flags="$2"
	# Valid _flags are:
	# $null   [no flag used] Validates the supplied pool is in fact a ZFS pool
	# -p      [primary] Validates the supplied pool has the primary role set
	# -c      [chyves] Validates the supplied pool is setup for chyves
	# -n      [no-exit] Escape from a normally fatal exit. Good for __setup.

	# Check to see if pool exists
	zfs list -H $_name_to_check > /dev/null 2>&1
	if [ "$?" = 0 ]; then

		# Check to see if the pool has been setup for chyves
		if [ -n "$(echo $_flags | grep -E "c|p" )" ]; then
			zfs list -H ${_name_to_check}/chyves > /dev/null 2>&1
			if [ "$?" = 0 ]; then
				if [ -n "$(echo $_flags | grep 'n')" ]; then  # If -n flag is used, exit.
					__fault_detected_exit "${_name_to_check} has been setup with chyves."
				fi
			else
				if [ -z "$(echo $_flags | grep 'n')" ]; then  # If -n flag is not used, exit.
					__fault_detected_exit "${_name_to_check} has not been setup with chyves."
				fi
			fi
		fi

		# Check to see if the pool is in the primary dataset_role
		if [ -n "$(echo $_flags | grep 'p')" ] && [ "$( zfs get -H -o value chyves:dataset_role $_name_to_check/chyves/.config )" != "primary" ]; then
			if [ -z "$(echo $_flags | grep 'n')" ]; then  # If -n flag is not used, exit.
				__fault_detected_exit "${_name_to_check} is not a primary pool."
			fi
		fi
	else
		# If -n flag is not used, exit.
		if [ -z "$(echo $_flags | grep 'n')" ]; then
			__fault_detected_exit "Invalid pool name supplied."
		fi
	fi
}

# Validates if a given guest name on a given pool exists.
__verify_valid_guest() {
	local _guest_to_check="$1"
	local _pool="$2"
	local _flags="$3"
	# Valid _flags are:
	# $null   [no flag used] Validates the supplied pool is in fact on the supplied ZFS pool
	# -s      [start] Exits if guest is a template or on an offline pool

	# Check to see if guest name used more than once
	if [ "$(zfs list -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_to_check" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING" | wc -l )" -gt "1" ]; then
		__fault_detected_exit "More than one \"$_guest_to_check\" exists on system within active pools and guests."
	fi

	# Checks to run when validating unused guest name for create/clone/etc
	if [ -z "$_pool" ]; then

		# Check if guest name is forbidden
		[ -n  "$( echo "$_guest_to_check" | grep -E "$_FORBIDDEN_GUEST_NAMES" )" ] && __fault_detected_exit "\"$_guest_to_check\" name is forbidden."

		# Check for valid guest name and length
		[ -n "$( echo "$_guest_to_check" | grep -v -E "^[a-zA-Z0-9_.-]{1,27}$" )" ] && __fault_detected_exit "Unsuitable name: '$_guest_to_check', must be alphanumeric between 1 and 27 characters and optionally can contain dashes '-', underscores '_', and or periods '.'."

		# Check if guest name in use on active pool.
		if [ "$(zfs list -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_to_check" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" | wc -l )" -gt "0" ]; then
			__fault_detected_exit "\"$_guest_to_check\" name already in use on system within active pools and guests."
		fi

	# Normal check of guest and pool combo
	else
		# Check to see if pool has chyves setup on it.
		__verify_valid_pool "$_pool" "-c"

		# Check if valid guest name and pool given.
		if [ ! -n "$(zfs list -H $_pool/chyves/guests/$_guest_to_check | grep -v "dataset does not exist" | grep -v "No such file or directory" )" ]; then
			__fault_detected_exit "Invalid guest name (${_guest_to_check}) supplied."
		fi

		# Exits if guest is a template or on an offline pool.
		if [ -n "$(echo $_flags | grep 's')" ] && [ -z "$(zfs list -r -H -t filesystem -o name | grep "$_pool/chyves/guests/$_guest_to_check" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" )" ]; then
			__fault_detected_exit "$_guest_to_check is either a template or contained within a chyves dataset where the dataset_role is set to 'offline'."
		fi
	fi
}

# Verify kernel module loaded
__verify_kernel_module_loaded() {
	local _module="$1"
	local _flags="$2"
	local _status=$(kldstat -v | grep $_module )
	# Valid _flags are:
	# $null   [no flag used] check only
	# -l      [load] Load module if not loaded
	# -u      [unload] Unload module

	# When erroring out the following message is displayed:
	# kldload: can't load $_module: No such file or directory
	if [ -z "$_status" ]; then
		if [ "$_flags" = "-l" ]; then
			kldload $_module
			sleep 5
			__verify_kernel_module_loaded "$_module"
		else
			__fault_detected_exit "Kernel module '$_module' not loaded. Run 'chyves setup kmod=1'"
		fi
	elif [ "$_flags" = "-u" ]; then
		kldunload -v $_module
		echo "Kernel module '$_module' loaded."
	else
		# echo "Kernel module '$_module' already loaded."
	fi
}

# Verify all modules in $_KERNEL_MODULES
__verify_all_kernel_modules(){
	local _flag="$1"
	# Valid _flag are:
	# $null   [no flag used] check only
	# -l      [load] Load module if not loaded
	# -u      [unload] Unload module

	if [ -z "$_flag" ] || [ "$_flag" = "-l" ] || [ "$_flag" = "-u" ]; then
		for _module in $_KERNEL_MODULES ; do
			echo "Checking module: $_module"
			__verify_kernel_module_loaded "$_module" "$_flag"
		done
	fi
}

# Verify that a binary is available
__verify_binary_available() {
	local _binary_to_check_for="$1"
	local _path_to_binary=$( which ${_binary_to_check_for} )

	if [ ! -x "${_path_to_binary}" ]; then
		__fault_detected_exit "Failed to find executable binary: '$_binary_to_check_for'"
	fi
}

# Verifies the number of parameters and exits if met or exceeded
__verify_number_of_arguments() {
	local _number_of_minimum_parameters=$1        # Minimum number of parameters
	local _number_of_supplied_parameters=$2       # As counted by "$#"
	local _number_of_maximum_parameters=$3        # (Optional) Maximum number of parameters

	# While $3 is optional, it does need a value if not set.
	[ -z "${_number_of_maximum_parameters}" ] && local _number_of_maximum_parameters=$_number_of_supplied_parameters

	if [ "${_number_of_supplied_parameters}" -lt "${_number_of_minimum_parameters}" ] || [ "${_number_of_supplied_parameters}" -gt "${_number_of_maximum_parameters}" ]; then
		__help
		__fault_detected_exit "Incorrect number of arguments used. Please see above for correct syntax."
	fi
}

# Checks to see if on FreeNAS
# The web UI references this file to display the version
__check_if_freenas() {
	if [ -e /etc/version ]; then
		local OS=$( cat /etc/version | cut -d - -f1 )
		if [ "$OS" = "FreeNAS" ]; then
			echo 1
		fi
	fi
}

# Gets pool names from ZFS with flag options for active/inactive
__get_pool_names() {
	local _flags="$1"
	# Valid flags are:
	# -a [all] for  primary|secondary|offline pools
	# -i [inactive] only display offline pools

	if [ -n "$(echo "$_flags" | grep 'a')" ]; then
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq )"
	elif [ -n "$(echo "$_flags" | grep 'i')" ]; then
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq | grep -E "$_OFFLINE_POOLS_GREP_STRING" )"
	else
		echo "$( zfs list -r -H | grep chyves | cut -d'/' -f1 | uniq | grep -E -v "$_OFFLINE_POOLS_GREP_STRING" )"
	fi
}

# Get pool name for guest
__get_pool_for_guest() {
	local _guest_name="$1"
	[ -z $( zfs list -d 3 -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_name" | grep -v -E "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" ) ] && __fault_detected_exit "Invalid active guest name, '$_guest_name'"
	_GUEST_pool="$(zfs list -d 3 -r -H -t filesystem -o name | grep -w "chyves/guests/$_guest_name" | cut -d '/' -f 1 )"
	__verify_valid_pool "$_GUEST_pool"
	__verify_valid_guest "$_guest_name" "$_GUEST_pool"
}

# Get primary pool name
__get_primary_pool_name() {
	_PRIMARY_POOL="$( zfs get -H -o name,value -t filesystem -r chyves:dataset_role | grep "chyves/.config" | grep "primary" | cut -d'/' -f1 )"
	if [ -n "$_PRIMARY_POOL" ]; then
		__verify_valid_pool "$_PRIMARY_POOL" "-p"
	fi
}

# Get guests name by supplied pid
__get_guest_name_by_pid() {
	local _pid="$1"

	for _guest in `__get_guests_list`
	do
		local _this_guest_pid=$( __check_bhyve_process_running $_guest )
		[ -z "$_this_guest_pid" ] && continue
		if [ "$_pid" -eq "$_this_guest_pid" ]; then
			_GUEST_name_by_pid="$_guest"
			break
		fi
	done
}

#  Get all chyves properties that are set on the system
__get_property_list() {
	local _flags="$1"
	local _guest="$2"
	# $null   Get a list of guest properties
	# -a      [all] Get a list of all guest properties including .defaults
	# -d      [defaults] Get a list of .defaults only properties
	# -c      [config] Get a list of .config only properties

	if [ -n "${_guest}" ]; then
		__get_pool_for_guest $_guest
		zfs get -r -H -t filesystem -o name,property all | grep -w  "$_GUEST_pool/chyves/guests/$_guest" | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-a" ]; then
		zfs get -r -H -t filesystem -o name,property all | grep /guests/ | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-d" ]; then
		zfs get -r -H -t filesystem -o name,property all $_PRIMARY_POOL/chyves/guests/.defaults | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	elif [ "${_flags}" = "-c" ]; then
		zfs get -r -H -t filesystem -o name,property all $_PRIMARY_POOL/chyves/.config | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	else
		zfs get -r -H -t filesystem -o name,property all | grep /guests/ | grep -v .defaults | grep chyves: | cut -f2 | sort | sed -e 's/chyves://g' | uniq
	fi
}

# Get a list of guests on system
__get_guests_list() {
	local _flags="$1"
	local _pool="$2"   # Optional
	# $null   Get a list of active guests
	# -d      [disks] Get a list of guests and their disks.
	# -a      [all] Get a list of all guests regardless if dataset_role is offline or if guest_roll is set to template
	# -f      [full] List as a full dataset name.

	if [ -n "$(echo "$_flags" | grep 'd')" ]; then
		local _zfs_command='zfs list -d 4 -r -H -t filesystem,volume -o name'

		if [ -n "$(echo "$_flags" | grep 'f')" ]; then
			local _PIPE_what_type_of_cutter='cut -f1'
		else
			local _PIPE_what_type_of_cutter='cut -d/ -f4-'
		fi
	else
		local _zfs_command='zfs list -d 3 -r -H -t filesystem -o name'
		local _PIPE_what_type_of_cutter='cut -d/ -f4'
	fi

	[ -n "${_pool}" ] && local _pool="$_pool/chyves/guests"

	if [ -n "$(echo "$_flags" | grep 'a')" ]; then
		$_zfs_command $_pool | grep chyves/guests | grep -v .defaults | $_PIPE_what_type_of_cutter | sed '/^$/d'
	else
		$_zfs_command $_pool | grep -E -v "$_OFFLINE_POOLS_GREP_STRING|$_TEMPLATE_GUESTS_GREP_STRING" | grep chyves/guests | grep -v .defaults | $_PIPE_what_type_of_cutter | sed '/^$/d'
	fi
}

# Get path for dataset
__get_path_for_guest_dataset() {
	local _guest_name="$1"
	local _pool="$2"
	local _path="$( zfs list -r -H -t filesystem -o mountpoint $_pool/chyves/guests/$_guest_name )"
	echo "$_path"
}

# Pulls CPU section from boot dmesg
__get_cpu_section_from_dmesg() {
	cat /var/run/dmesg.boot | grep -B 100 "real memory" | grep -v "real memory" | grep -A 20 "CPU:"
}

# Check VMM resource allocation status
__check_vmm_alocated() {
	local _guest=$1
	local _flags=$2
	local _vmm_dev="/dev/vmm/chy-$_guest"
	# Valid flags are:
	# null    Return nothing or a 1
	# -h      [human] for a "YES" or "NO" indicator

	if [ "$_flags" = "-h" ]; then
		if [ -e "$_vmm_dev" ]; then
			echo "YES"
		else
			echo "NO"
		fi
	elif [ -e "$_vmm_dev" ]; then
		echo "1"
	fi
}

# Check bhyve process running status
__check_bhyve_process_running() {
	local _guest=$1
	local _flags=$2
	local _bhyve_process_running=$( pgrep -fx "bhyve: chy-$_guest" )
	# Valid flags are:
	# null    Return nothing or the PID
	# -h      [human] for a "YES (pid)" or "NO" indicator

	if [ "$_flags" = "-h" ]; then
		if [ -n "$_bhyve_process_running" ]; then
			echo "YES ($_bhyve_process_running)"
		else
			echo "NO"
		fi
	elif [ -n "$_bhyve_process_running" ]; then
		echo "$_bhyve_process_running"
	fi
}

# Displays the boot priority of a guest "YES (xxx)" where xxx is the priority
__display_rcboot_priority() {
	local _pool=$1
	local _guest=$2
	local _rcboot_property="$( __multi_chyves_zfs_property "get" "rcboot" "$_pool" "guests" "$_guest" )"

	if [ "$_rcboot_property" -gt '0' ]; then
		echo "YES ($_rcboot_property)"
	else
		echo "NO"
	fi
}

# Coverts a list to string that can be used for grep
# List can be delimited by a single space for each item or a new line
__convert_list_to_grep_string() {
	local _string_to_convert="$1"
	local _append_this="$2"

	if [ -z "$_string_to_convert" ]; then
		echo "$_UUID_GENERAL_USE"
	else
		local _var=$( echo "$_string_to_convert" | tr '\n' ' ' | sed -e 's/[[:space:]]*$//' | sed -e 's/ /\|/g' )
		if [ -z "$_append_this" ]; then
			echo "$_var"
		else
			echo "${_var}|${_append_this}"
		fi
	fi
}

# Setup chyves on a dataset
__setup() {
	local pool="$1"
	__verify_valid_pool "$pool" -cn
	echo "Setting up chyves on $pool..."
	zfs create $pool/chyves
	zfs create $pool/chyves/guests
	zfs create $pool/chyves/.config
	zfs set chyves:chyves_version="${_VERSION}" $pool/chyves/.config
	zfs set chyves:chyves_version_int="${_VERSION_INT}" $pool/chyves/.config
	zfs set chyves:dataset_version="${_VERSION_DATASET}" $pool/chyves/.config

	# A chyves pool is already setup, so setup as secondary pool.
	if [ -n "$_PRIMARY_POOL" ]; then
		echo "Secondary pool set up..."
		zfs set mountpoint="/chyves/$pool" $pool/chyves
		zfs set chyves:dataset_role=secondary $pool/chyves/.config

	# chyves is not set up yet, setup primary pool.
	else
		_PRIMARY_POOL=$pool
		_RESTRICT_NEW_PROPERTY_NAMES="primary-pool-initial-setup"
		zfs set mountpoint="/chyves" $_PRIMARY_POOL/chyves
		zfs create $_PRIMARY_POOL/chyves/ISO
		zfs create $_PRIMARY_POOL/chyves/Firmware

		echo "Setting up .defaults dataset and properties on primary pool..."
		zfs create $_PRIMARY_POOL/chyves/guests/.defaults
		__multi_chyves_zfs_property "set" "bargs"         "primary" "guests" ".defaults" "-A -H -P"
		__multi_chyves_zfs_property "set" "bridge"        "primary" "guests" ".defaults" "bridge0"
		__multi_chyves_zfs_property "set" "cpu"           "primary" "guests" ".defaults" "1"
		__multi_chyves_zfs_property "set" "fw"            "primary" "guests" ".defaults" "-"
		__multi_chyves_zfs_property "set" "guest_role"    "primary" "guests" ".defaults" "active"
		__multi_chyves_zfs_property "set" "loader"        "primary" "guests" ".defaults" "bhyveload"
		__multi_chyves_zfs_property "set" "network_type"  "primary" "guests" ".defaults" "bridge"
		__multi_chyves_zfs_property "set" "os"            "primary" "guests" ".defaults" "default"
		__multi_chyves_zfs_property "set" "persist"       "primary" "guests" ".defaults" "1"
		__multi_chyves_zfs_property "set" "ram"           "primary" "guests" ".defaults" "256M"
		__multi_chyves_zfs_property "set" "rcboot"        "primary" "guests" ".defaults" "0"
		__multi_chyves_zfs_property "set" "size"          "primary" "guests" ".defaults" "8G"

		__multi_chyves_zfs_property "set" "uefi_console_output"                  "primary" "guests" ".defaults" "serial"
		__multi_chyves_zfs_property "set" "uefi_mouse_type"                      "primary" "guests" ".defaults" "ps2"
		__multi_chyves_zfs_property "set" "uefi_vnc_ip"                          "primary" "guests" ".defaults" "0.0.0.0"
		__multi_chyves_zfs_property "set" "uefi_vnc_res"                         "primary" "guests" ".defaults" "800x600"
		__multi_chyves_zfs_property "set" "uefi_pause_until_vnc_client_connect"  "primary" "guests" ".defaults" "no"

		__multi_chyves_zfs_property "set" "disk_volmode"         "primary" "guests" ".defaults" "dev"
		__multi_chyves_zfs_property "set" "disk_volblocksize"    "primary" "guests" ".defaults" "512"
		__multi_chyves_zfs_property "set" "disk_dedup"           "primary" "guests" ".defaults" "inherit"
		__multi_chyves_zfs_property "set" "disk_compression"     "primary" "guests" ".defaults" "inherit"
		__multi_chyves_zfs_property "set" "disk_primarycache"    "primary" "guests" ".defaults" "inherit"
		__multi_chyves_zfs_property "set" "disk_secondarycache"  "primary" "guests" ".defaults" "inherit"

		echo "Setting up .config properties on primary pool..."
		__multi_chyves_zfs_property "set" "auto_load_kernel_mods"                "primary" ".config" "-" "yes"
		__multi_chyves_zfs_property "set" "console_start_offset"                 "primary" ".config" "-" "50"
		__multi_chyves_zfs_property "set" "consolidate_bhyve_pci_devices"        "primary" ".config" "-" "no"
		__multi_chyves_zfs_property "set" "dataset_role"                         "primary" ".config" "-" "primary"
		__multi_chyves_zfs_property "set" "dev_mode"                             "primary" ".config" "-" "on"
		__multi_chyves_zfs_property "set" "log_mode"                             "primary" ".config" "-" "on"
		__multi_chyves_zfs_property "set" "restrict_new_property_names"          "primary" ".config" "-" "on"
		__multi_chyves_zfs_property "set" "tap_start_offset"                     "primary" ".config" "-" "50"
		__multi_chyves_zfs_property "set" "tap_up_by_default"                    "primary" ".config" "-" "yes"        # net.link.tap.up_on_open
		__multi_chyves_zfs_property "set" "vlan_iface_base_name"                 "primary" ".config" "-" "vlan"
		__multi_chyves_zfs_property "set" "uefi_vnc_port_start_offset"           "primary" ".config" "-" "5900"
		__multi_chyves_zfs_property "set" "check_for_updates"                    "primary" ".config" "-" "weekly"
		__multi_chyves_zfs_property "set" "check_for_updates_timeout_seconds"    "primary" ".config" "-" "2"
		__multi_chyves_zfs_property "set" "check_for_updates_last_check"         "primary" ".config" "-" "$_DATE_YMD"
		__multi_chyves_zfs_property "set" "check_for_updates_last_check_status"  "primary" ".config" "-" "0"
		__multi_chyves_zfs_property "set" "check_for_updates_unique_id"          "primary" ".config" "-" "$_UUID_GENERAL_USE"

		echo "Creating null.iso for UEFI use..."
		touch /tmp/null.iso
		if [ -e /tmp/null.iso ]; then
			echo "importing null.iso into ISO resources..."
			__resource_functions iso import /tmp/null.iso
		fi

		echo "Done setting up primary pool: $pool"
	fi

	# If on FreeNAS do a couple of needed changes.
	if [ "$( __check_if_freenas )" ]; then
		echo "On FreeNAS installation."
		echo "Checking for symbolic link to /chyves from /mnt/chyves..."
		if [ -d /mnt/chyves ]; then
			if [ ! -e /chyves ]; then
				ln -s /mnt/chyves /chyves
				if [ -L /chyves ]; then
					echo "Symbolic link to /chyves from /mnt/chyves successfully created."
				else
					echo "Failed to create symbolic link."
					echo "Please manually do so by running the following as root:"
					echo "# ln -s /mnt/chyves /chyves"
				fi
			elif [ -L /chyves ]; then
				echo "Symbolic link to /chyves already exists."
			fi
		elif [ "$val" = "freenas-boot" ] && [ -d /chyves ]; then
			echo "Symbolic link not needed. /chyves exists."
			echo "chyves is installed on the freenas-boot pool."
			echo "This is not recommended configuration."
		else
			echo "chyves does not seem to be setup."
		fi
	fi
}

# Handles import, rename, delete, list for Firmware, ISO, and some guests resources
__resource_functions() {
	local _function="$1"
	local _subfunction="$2"
	local _arg3="$3"			# URL|File-Path\File-Name|Firmware-Name
	local _arg4="$4"			# Rename-Name

	# Sets the variable to use to for the resource
	if [ "$_function" = "firmware" ]; then
		local _resource_name="Firmware"
	elif [ "$_function" = "iso" ]; then
		local _resource_name="ISO"
	elif [ "$_function" = "guest" ]; then
		local _resource_name="guests"
	elif [ "$_function" = "disk" ]; then
		local _resource_name="guests/$_arg4/disk$_arg5"
	fi

	# Import ISO and Firmware resources into chyves
	if [ "$_subfunction" = "import" ]; then
		local _URL=$_arg3
		local _file_name="$(basename $_URL)"

		# If file ends with .gz|.xz do not use the extension as the folder name.
		if [ -n "$( echo "$_URL" | grep -E "\.gz$" )" ]; then
			local _folder_name=$(basename $_file_name .gz)
		elif [ -n "$( echo "$_URL" | grep -E "\.xz$" )" ]; then
			local _folder_name=$(basename $_file_name .xz)
		else
			local _folder_name=$_file_name
		fi

		# Check to see if file is on a remote source
		if [ -n "$(echo "$_URL" | grep -E '^http|^ftp')" ]; then
			echo "Creating ZFS dataset: $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name"
			zfs create $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name

			# Remote ISOs are downloaded using fetch and hash checked.
			if [ "$_function" = "iso" ]; then
				echo "Please enter a supported hash checksum for '$_file_name':"
				read -p "Supported cryptographic hash function are (md5|sha1|sha256|sha512|null): " _user_supplied_hash </dev/tty

				echo "Downloading $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/..."
				fetch $_URL -o /chyves/$_resource_name/$_folder_name

				local _hash_length=$( echo $_user_supplied_hash | wc | awk '{ print $3 }' )
				case "$_hash_length" in
					33)     local _calcd_chksum=$( md5 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=MD5
					;;
					41)     local _calcd_chksum=$( sha1 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA1
					;;
					65)     local _calcd_chksum=$( sha256 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA256
					;;
					129)    local _calcd_chksum=$( sha512 -q /chyves/ISO/$_folder_name/$_file_name )
					        local _hash_type=SHA512
					;;
					*)      local _calcd_chksum=""
					        local _hash_type="Unsupported hash string given. Please contact the chyves developers to have this hash function added."
				esac

				# Check if hash sums match
				if [ -z "$_user_supplied_hash" ]; then
					echo "All that is necessary for the triumph of evil is that good (wo)men do nothing..."
					echo "...like check their downloaded ISO images against a known hash checksum."
					echo "No hash checksum given, good luck with your potentially corrupt or manipulated ISO, you facilitator of evil."
				elif [ "$_calcd_chksum" = "$_user_supplied_hash" ]; then
					echo "$_hash_type hashes matched."
				else
					echo "Hashes did not match for '$_file_name':"
					echo "Supplied hash:            $_user_supplied_hash"
					echo "Reason for hash mismatch: $_hash_type"
					echo "It is recommended to delete '$_file_name', download it again, and supply a supported hash checksum."
					__resource_functions iso delete "$_folder_name"
				fi

			# Downloads remote firmware
			else
				echo "Downloading $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/..."
				fetch $_URL -o /chyves/$_resource_name/$_file_name
			fi

		# Local file copies only.
		else
			echo "Creating ZFS dataset: $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name"
			zfs create $_PRIMARY_POOL/chyves/$_resource_name/$_folder_name
			echo "Copying $_file_name from $_URL to /chyves/$_resource_name/$_folder_name/"
			cp $_URL /chyves/$_resource_name/$_folder_name
		fi

		# Decompress resource if ending in .gz|.xz
		# These programs delete the original files after decompression
		if [ -n "$( echo "$_file_name" | grep -E "\.gz$" )" ]; then
			echo "Decompressing .gz file."
			gunzip -d /chyves/ISO/$_folder_name/$_file_name
			local _file_name="$_folder_name"
		elif [ -n "$( echo "$_file_name" | grep -E "\.xz$" )" ]; then
			echo "Decompressing .xz file."
			xz -d /chyves/ISO/$_folder_name/$_file_name
			local _file_name="$_folder_name"
		fi

		# Checks to see if resource exists now.
		if [ -e /chyves/$_resource_name/$_folder_name/$_file_name ]; then
			echo "$_file_name sucessfully imported as a chyves $_resource_name resource."
		else
			echo "Operation unsucessful: delete the dataset and try again."
			__resource_functions $_function delete "$_folder_name"
		fi

	# Rename guest, ISO, and Firmware resources
	elif [ "$_subfunction" = "rename" ]; then
		# INSERT check to verify dataset is valid  __verify_valid_dataset "$pool" "$_resource_type" "$name"
		# INSERT check to verify target dataset does not exist __verify_valid_dataset "$pool" "$_resource_type" "$name" -n

		read -p "Do you want to rename $_function from '$_arg3' to '$_arg4' [y/N]? " _rename_or_no </dev/tty

		if [ "$_resource_name" = "guests" ]; then
			case "$_rename_or_no" in
				y|Y|yes)   __verify_valid_guest $_arg4
				           __get_pool_for_guest $_arg3
				           zfs rename $_GUEST_pool/chyves/guests/$_arg3 $_GUEST_pool/chyves/guests/$_arg4
				;;
				*)         echo "Guest: '$_arg3' not renamed."
			esac
		else
			local _pool="$_PRIMARY_POOL"
			case "$_rename_or_no" in
				y|Y|yes)   mv -f /chyves/$_resource_name/$_arg3/$_arg3 /chyves/$_resource_name/$_arg3/$_arg4
				           zfs rename $_pool/chyves/$_resource_name/$_arg3 $_pool/chyves/$_resource_name/$_arg4
				;;
				*)         echo "$_resource_name: '$_arg3' not renamed."
			esac
		fi

	# Delete guest, ISO, and Firmware resources
	elif [ "$_subfunction" = "delete" ]; then
		# INSERT check to verify dataset is valid  __verify_valid_dataset "$_pool" "$_resource_type" "$name"

		__resource_functions_delete_sub() {
			local _gst="$1"

			# Delete guest and their net interfaces
			if [ "$_resource_name" = "guests" ]; then
				__get_pool_for_guest $_gst
				__load_guest_parameters $_gst
				if [ -n "$_GP_tap" ]; then
					for _iface in "`echo $_GP_tap | tr ',' ' '`"
					do
						__network "$_gst" remove "$_iface"
					done
				fi

			# Delete other resources
			else
				_GUEST_pool="$_PRIMARY_POOL"
			fi

			echo -n "Deleting ${_function}: '$_guest'..."
			zfs destroy -r $_GUEST_pool/chyves/$_resource_name/$_gst
			echo "done."
		}

		for _guest in `echo $_arg3 | tr ',' ' '`
		do
			read -p "[WARNING] Do you want to delete ${_function}: '$_guest' [y/N]? " _delete_or_no </dev/tty
			case "$_delete_or_no" in
				y|Y|yes)  __resource_functions_delete_sub $_guest
				;;
				*) echo "The $_function ('$_guest') was not deleted."
			esac
		done

	# List Firmware resources
	elif [ "$_subfunction" = "list" ] && [ "$_function" = "firmware" ]; then
		__list "firmwares"

	# List ISO resources
	elif [ "$_subfunction" = "list" ] && [ "$_function" = "iso" ]; then
		__list "iso"
	fi
}

# Gracefully stop a guest
__stop() {
	local name="$1"
	__get_pool_for_guest "$name"
	local pid=$(pgrep -fx "bhyve: chy-$name")
	echo "Stopping $name..."
	kill $pid
}

# Force kill -9 everyting matching $name and destroy
# THIS WILL KILL EVERYTHING MATCHING $NAME
__forcekill() {
	local name="$1"
	__get_pool_for_guest "$name"

	# Display current running processes for guest
	__list processes $name | grep -v "/bin/sh /usr/local/sbin/chyves forcekill"

	read -p "[WARNING] Are you sure you want to kill all processes above? [y/N]? " an </dev/tty
	case "$an" in
		y|Y|yes) 	local pids="$(pgrep -f $name)"
			for apid in "$pids"; do
				kill -9 $apid
			done
			bhyvectl --force-poweroff --vm=chy-$name
			bhyvectl --destroy --vm=chy-$name
		;;
		*) echo "No action taken."
	esac
}

# Gracefully shut down all guests via ACPI (Does not destroy)
__scram() {
	echo "Shutting down all guests..."
	local pids="$(pgrep -f chy-)"
	for apid in "$pids"; do
		kill $apid
	done
	wait_for_pids $pids
}

# Destroy guest
__destroy() {
	local name="$1"
	__get_pool_for_guest "$name"
	echo "Destroying $name..."
	bhyvectl --force-poweroff --vm=chy-$name
	bhyvectl --destroy --vm=chy-$name
}

# Add a new disk to guest
__add() {
	local name="$1"
	local size="$2"
	__get_pool_for_guest "$name"
	__load_guest_default_parameters
	local _disk_options=$( __generate_zvol_disk_options_string )
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	# Find the last disk number and increment one
	local lastdisk="$(zfs list -H | grep chyves/guests/$name | grep disk | cut -d '/' -f4 | cut -f1 | sort -V | cut -c5- | tail -n1)"
	local newdisk="$(expr $lastdisk + 1)"

	echo "Creating new zvol for $name..."
	zfs create -V $size $_disk_options $_GUEST_pool/chyves/guests/$name/disk$newdisk

	# Find the last pcidev and increment by one
	local lastpci="$(zfs get -H all | grep chyves/guests/$name | grep pcidev | cut -f2 | cut -d ':' -f3 | sort -V | tail -n1)"
	if [ -z $lastpci ]; then
		local newpci='1'
	else
		local newpci="$(expr $lastpci + 1)"
	fi
	zfs set chyves:pcidev:$newpci=ahci-hd,/dev/zvol/$pool/chyves/guests/$name/disk$newdisk $dataset
}

# Remove disk from guest
__remove() {
	local flagone="$1"          # -f | name
	local flagtwo="$2"          # name | diskN
	local flagthree="$3"        # diskN | null
	if [ $flagone = "-f" ]; then
		echo "Removing $flagthree from $flagtwo"
		local pool="$(zfs list -H -o name | grep $flagtwo | grep $flagthree | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagtwo | grep pcidev | grep $flagthree | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			zfs inherit  -r $pciprop $pool/chyves/guests/$flagtwo
			zfs destroy $pool/chyves/guests/$flagtwo/$flagthree
		fi
	else
		local pool="$(zfs list -H -o name | grep $flagone | grep $flagtwo | cut -d '/' -f 1)"
		local pciprop="$(zfs get -H all $pool/chyves/guests/$flagone | grep pcidev | grep $flagtwo | cut -f2 )"
		# Make sure it's a valid pcidev property as to not shoot foot
		if [ -z $pciprop ]; then
			echo "Not a valid PCIDEV property"
		else
			read -p "Are you sure you want to remove $flagtwo from $flagone [Y/N]? " an </dev/tty
			case "$an" in
				y|Y)	zfs inherit  -r $pciprop $pool/chyves/guests/$flagone
					zfs destroy $pool/chyves/guests/$flagone/$flagtwo
				;;
				*) echo "Not removed..."
				;;
			esac
		fi
	fi
}

# Resize a disk
__resize(){
	local name="$1"
	local disk="$2"
	local size="$3"
	__get_pool_for_guest "$name"
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	# Check if guest exists
	echo "Resizing $disk to $size"
	if [ -d /chyves/$_GUEST_pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running $name )" ]; then
			zfs set volsize=$size $_GUEST_pool/chyves/guests/$name/$disk
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Snapshot a guest
__snapguest() {
	local fullsnap="$1"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	__get_pool_for_guest "$name"
	echo "Taking snapshot $fullsnap"
	zfs snap -r $_GUEST_pool/chyves/guests/$fullsnap
}

# Rollback guest
__rollguest() {
	local fullsnap="$1"
	local name="$(echo $fullsnap | cut -d '@' -f1)"
	__get_pool_for_guest "$name"
	local snap="$(echo $fullsnap | cut -d '@' -f2)"
	local disklist="$(zfs list -H | grep chyves/guests/$name | grep disk | \
				cut -f1 | cut -d '/' -f4-)"
	# Check if guest exists
	echo "Rolling back to $fullsnap"
	if [ -d /chyves/$_GUEST_pool/guests/$name ] || [ -d /chyves/guests/$name ]; then
		# Check to make sure guest isn't running
		if [ -z "$( __check_bhyve_process_running $name )" ]; then
			zfs rollback -rR $_GUEST_pool/chyves/guests/$fullsnap
			for disk in $disklist ; do
				zfs rollback -rR $_GUEST_pool/chyves/guests/$name/$disk@$snap
			done
		else
			echo "Please stop the guest first"
		fi
	else
		echo "Not a valid guest name"
	fi
}

# Run console
__console() {
	local name="$1"
	local _flag="$2"
	__get_pool_for_guest "$name"
	local dataset="${_GUEST_pool}/chyves/guests/${name}"
	local con="$(zfs get -H -o value chyves:con $dataset)"
	echo "Starting console on $name..."
	echo "~~. to escape console [uses cu(1) for console]"
	cu -l /dev/${con}B -s 9600

}

# Reset all consoles. This kills the cu(1)
__conreset() {
	__list con
	echo "Processes to kill:"
	ps -aux | grep cu
	read -p "[WARNING] Are you sure you want to kill all processes cu console processes above? [y/N]? " an </dev/tty
	case "$an" in
	  y|Y|yes) killall cu
	  ;;
	  *) echo "No action taken."
	esac
}

__preflight_check "$1"

__parse_cmd_ingress "$@"
